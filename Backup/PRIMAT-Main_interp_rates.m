(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Date[]


(* ::Input::Initialization:: *)
(* Copyright (C) 2018- Cyril Pitrou, Alain Coc *)

(* This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of
 the License,or (at your option) any later version.

This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 General Public License for more details.

You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place-Suite 330, Boston, MA 02111-1307,
  USA. 
*)


(* ::Input::Initialization:: *)
$InterpolateAnalytics=True;


(* ::Input::Initialization:: *)
$CompileNDSolve=True;


(* ::Input::Initialization:: *)
$BDFOrder=2;


(* ::Input::Initialization:: *)
PrecisionNDSolve=2;(*TODO Put 2 here !!!! *)


(* ::Input::Initialization:: *)
AccuracyNDSolve:=15+PrecisionNDSolve;


(* ::Input::Initialization:: *)
NTemperaturePoints=1200; (*1000 is enough*)


(* ::Input::Initialization:: *)
InterpOrder=3;


(* ::Input::Initialization:: *)
$FastPENRatesIntegrals=True;


(* ::Input::Initialization:: *)
$PENRatesIntegralsPoints=300;(*200 is enough *)


(* ::Input::Initialization:: *)
TabulatedReactionsFile="BBNRatesAlainCoc2018.dat";
NumberNuclearReactions=423;


(* ::Input::Initialization:: *)
MaximumNuclearMass=Infinity; 


(* ::Input::Initialization:: *)
$RandomNuclearRates=False;
$MaxVariationRate=1000;


(* ::Input::Initialization:: *)
dpTOHe3gFactor=1;


(* ::Input::Initialization:: *)
$RecomputeWeakRates=False;
$ParallelWeakRates=True;


(* ::Input::Initialization:: *)
$RadiativeCorrections=True;

$ResummedLogsRadiativeCorrections=True;
$RelativisticFermiFunction=True;


(* ::Input::Initialization:: *)
$RadiativeThermal=True;
$CorrectionBremsstrahlung=True;


(* ::Input::Initialization:: *)
$FiniteNucleonMass=True;


(* ::Input::Initialization:: *)
$CoupledFMandRC=True;


(* ::Input::Initialization:: *)
$QEDMassShift=False;


(* ::Input::Initialization:: *)
$QEDPlasmaCorrections=True;
$CompleteQEDPressure=True;


(* ::Input::Initialization:: *)
$IncompleteNeutrinoDecoupling=True;


(* ::Input::Initialization:: *)
$RecomputePlasmaCorrections=False;


(* ::Input::Initialization:: *)
$DegenerateNeutrinos=False;
\[Mu]OverT\[Nu]=0.0;


(* ::Input::Initialization:: *)
Kelvin=1;
Tstart=10^11 Kelvin;
TMiddle:=0.9999*10^10 Kelvin;
T18:=1.25 *10^9 Kelvin;
Tend=6.*10^7 Kelvin;


(* ::Input::Initialization:: *)
Ti=10^12 Kelvin;
Tf=10^7 Kelvin;
LogTi=1.Log10[Ti];
LogTf=1.Log10[Tf]; 


(* ::Input::Initialization:: *)
ListLogT=Sort@DeleteDuplicates@Join[{10.},Table[i,{i,LogTf,LogTi,(LogTi-LogTf)/NTemperaturePoints}]];
ListT=1. 10^ListLogT;


(* ::Input::Initialization:: *)
ListTRange[T1_,T2_]:=Module[{len=Length@ListT,imindown,imaxup,Tmin=Min[T1,T2],Tmax=Max[T1,T2]},
imindown=Max[1,-1+Position[ListT,SelectFirst[ListT,#>Tmin&]][[1,1]]];
imaxup=Min[len,Position[ListT,SelectFirst[ListT,#>=Tmax&]][[1,1]]];
ListT[[imindown;;imaxup]]
]


(* ::Input::Initialization:: *)
second=1;
cm=1;
gram=1;


(* ::Input::Initialization:: *)
kg=10^3 gram;
meter = 10^2 cm;
km=10^3 meter;
Joule =kg meter^2/second^2; (* This gives 10^7 ergs *)
DensityUnit=gram/cm^3;
Hz=1/second;


(* ::Input::Initialization:: *)
Giga=10^9;
Mega=10^6;
Kilo=10^3;


(* ::Input::Initialization:: *)
kB =1.3806488 10^-23 Joule / Kelvin;(* Boltzmann constant in J/K *)
clight=2.99792458*10^8*meter/second; (* speed of light in cm/s *)
hbar= 6.62606957/(2\[Pi]) 10^-34(*1.054571596 10^-34*) Joule second;
Avogadro=6.0221415 10^23;


(* ::Input::Initialization:: *)
eV=1.60217653 10^-19 Joule;
keV = Kilo eV;
MeV=Mega eV;
GeV=Giga eV;


(* ::Input::Initialization:: *)
GN=6.67384 10^-11 meter^3/kg/second^2; (* Gravitation constant *)
GF=1.1663787*10^-5/(GeV)^2; (* Fermi Constant*)
gA=1.2723; 
(* Axial current constant of structure of the nucleons Particle data group : 1.2723(+-23) PDG2016 *)
(* However post 2002 data suggest 1.2755(11) as advised by William Marciano*)


(* ::Input::Initialization:: *)
fWM=3.7058/2(*1.853*); (* Weak magnetism see 1212.0332*)
radiusproton=0.841*10^-15 meter (*(arXiv:1212.0332)*)


(* ::Input::Initialization:: *)
\[Alpha]FS=1/137.03599911;(* Fine structure constant =e^2/(4\[Pi]) *)


(* ::Input::Initialization:: *)
me=0.510998918 MeV; 
mn=939.565360 MeV;
mp=938.272029 MeV; 
Q=mn-mp; (* Mass difference between neutrons and protons *)
Subscript[m, Nucleon]=mn;

Subscript[m, W]=80.385 GeV; (* Mass of the W Boson. *) 
Subscript[m, Z]=91.1876 GeV;


(* ::Input::Initialization:: *)
Q/MeV


(* ::Input::Initialization:: *)
pc=3.0856777807 10^16 meter; (* The parsec *)
Mpc=Mega pc;
H0=100 h km/second/Mpc; (* Hubble constant today *)
H100=100 km/second/Mpc;(*Fake Hubble rate given by 100 km/s/Mpc so that h = H0/H100 *)


(* ::Input::Initialization:: *)
Subscript[\[Rho], crit]=3./(8\[Pi] GN) (H0)^2 (* in g cm^-3 by construction *)
\[Rho]crit100=(3./(8\[Pi] GN)) ((H100)^2) (* in g cm^-3 by construction *)


(* ::Input::Initialization:: *)
Mean\[Tau]neutron:=879.5(*880.2second+-1.1s was previous value from PDG2017 *);
(* Now we use 1712.05663 Section 11 which includes recente 2017 measurements.*)
\[Sigma]\[Tau]neutron:=0.8 second;
\[Tau]neutron=Mean\[Tau]neutron;


(* ::Input::Initialization:: *)
NeutrinosGenerations:=3.;
\[Xi]\[Nu]:=If[$DegenerateNeutrinos,\[Mu]OverT\[Nu],0];


(* ::Input::Initialization:: *)
\[Rho]FD[c_]=1/(2\[Pi]^2) \!\(
\*SubsuperscriptBox[\(\[Integral]\), \(0\), \(Infinity\)]\(
\*FractionBox[
SuperscriptBox[\(y\), \(3\)], \((
\*SuperscriptBox[\(E\), \(y - c\)] + 1)\)] \[DifferentialD]y\)\);
nFD[c_]=1/(2\[Pi]^2) \!\(
\*SubsuperscriptBox[\(\[Integral]\), \(0\), \(Infinity\)]\(
\*FractionBox[
SuperscriptBox[\(y\), \(2\)], \((
\*SuperscriptBox[\(E\), \(y - c\)] + 1)\)] \[DifferentialD]y\)\);
\[Rho]FDNonDegenerate=\[Rho]FD[0];


(* ::Input::Initialization:: *)
Nneu:=NeutrinosGenerations*(\[Rho]FD[\[Xi]\[Nu]]+\[Rho]FD[-\[Xi]\[Nu]])/(2\[Rho]FDNonDegenerate)


(* ::Input::Initialization:: *)
TCMB0:=2.7255Kelvin;
\[Sigma]TCMB0:=0.0006 Kelvin;(* [Planck 2015 XIII] *)


(* ::Input::Initialization:: *)
FourOverElevenQED:=4/11 (1+(25 \[Alpha]FS)/(22\[Pi]));
FourOverElevenNoQED:=4/11;
FourOverEleven:=If[$QEDPlasmaCorrections,FourOverElevenQED,FourOverElevenNoQED];

T\[Nu]0=(FourOverEleven)^(1/3) TCMB0;


(* ::Input::Initialization:: *)
h:=0.6727; (*+-0.0066 *)(*[Planck 2015 XIII]*)


(* ::Input::Initialization:: *)
Meanh2\[CapitalOmega]b0Planck=0.02225;(*[Planck 2015 XIII TT and ET and EE]*)
\[Sigma]h2\[CapitalOmega]b0Planck=0.00016;(* Standard deviation*)


(* ::Input::Initialization:: *)
Meanh2\[CapitalOmega]b0=Meanh2\[CapitalOmega]b0Planck; 
\[Sigma]h2\[CapitalOmega]b0=\[Sigma]h2\[CapitalOmega]b0Planck;
h2\[CapitalOmega]b0=Meanh2\[CapitalOmega]b0;


(* ::Input::Initialization:: *)
ReSetCosmology:=(
Meanh2\[CapitalOmega]b0=Meanh2\[CapitalOmega]b0Planck; 
NeutrinosGenerations=3;
);


(* ::Input::Initialization:: *)
Meanh2\[CapitalOmega]c0=0.1198;(* [Planck 2015 XIII]*)
\[Sigma]h2\[CapitalOmega]c0=0.0015;
h2\[CapitalOmega]c0=Meanh2\[CapitalOmega]c0;


(* ::Input::Initialization:: *)
1-(h2\[CapitalOmega]b0+h2\[CapitalOmega]c0)/h^2


(* ::Input::Initialization:: *)
aBB=((\[Pi]^2)/(15 hbar^3 (clight)^5)) 


(* ::Input::Initialization:: *)
Subscript[\[Rho], CMB0]:=aBB (kB TCMB0)^4 ;(* in g cm^-3*)

Subscript[n, CMB0]:=(2 Zeta[3])/(\[Pi]^2 hbar^3 (clight)^3) (kB TCMB0)^3


(* ::Input::Initialization:: *)
Subscript[n, CMB0]


(* ::Input::Initialization:: *)
Subscript[\[CapitalOmega], \[Gamma]0]:=Subscript[\[Rho], CMB0]/Subscript[\[Rho], crit];


(* ::Input::Initialization:: *)
Subscript[\[CapitalOmega], \[Nu]0]:=Nneu*7/8*(FourOverEleven)^(1/3) Subscript[\[CapitalOmega], \[Gamma]0];


(* ::Input::Initialization:: *)
ma = 931.494061 MeV;(* Audi2012 *)
He4Overma=4.0026032541; (* Audi2012 *)
H1Overma=1.00782503223; (* Audi2012 *)  


(* ::Input::Initialization:: *)
Subscript[x, He4]=0.24709 ;(* Chemical composition at the end of BBN. In principle one should account for He4 produced by stars...*)
Subscript[x, H1]=1-Subscript[x, He4];
mbaryon0=(Subscript[x, H1]H1Overma+Subscript[x, He4]He4Overma/4)ma;


(* ::Input::Initialization:: *)
\[Rho]B0 :=h2\[CapitalOmega]b0*\[Rho]crit100;


(* ::Input::Initialization:: *)
nbaryons0:=\[Rho]B0 /(mbaryon0/(clight)^2)


(* ::Input::Initialization:: *)
nbaryons0/Subscript[n, CMB0]


(* ::Input::Initialization:: *)
\[CapitalOmega]bh2Over\[Eta]:=Subscript[n, CMB0]/\[Rho]crit100 mbaryon0/(clight)^2


(* ::Input::Initialization:: *)
\[Eta]factor:=h2\[CapitalOmega]b0/\[CapitalOmega]bh2Over\[Eta]


(* ::Input::Initialization:: *)
\[Rho]B[av_]:=\[Rho]B0 /av^3;
nB[av_]:=nbaryons0 /av^3;


(* ::Input::Initialization:: *)
$CorrectBaryonsEnergyDensityinBBNRRates=True;
\[Rho]BForBBN[av_]:=\[Rho]B[av]If[$CorrectBaryonsEnergyDensityinBBNRRates,ma/mbaryon0,1];(* This is Eq. C8 of the companion paper *)


(* ::Input::Initialization:: *)
FD[EoverT_]=1/(Exp[EoverT]+1);(* Fermi Dirac Distribution *)
FD[Energy_,x_]=1/(Exp[x Energy]+1);
BE[EoverT_]=1/(Exp[EoverT]-1); (* Bose Einstein Distribution *)
BE[Energy_,x_]=1/(Exp[x Energy]-1);

(* For neutrinos with a chemical potential *)
FD\[Nu][Energy_,\[Phi]_,x_]=1/(Exp[x Energy-\[Phi]]+1);


(* ::Input::Initialization:: *)
FDp[Energy_,x_]=D[1/(Exp[x Energy]+1),Energy];


(* ::Input::Initialization:: *)
NP[number_]:=NumberForm[number,8]


(* ::Input::Initialization:: *)
MyGrid[Table_List]:=Grid[Table,Frame->All]


(* ::Input::Initialization:: *)
MyInterpolation[Tab_List]:=Interpolation[Tab,InterpolationOrder->InterpOrder];

(* Does not work to interpolate the log of rates because it fails when rates vanish !!!*)
MyInterpolationLog[Tab_List]:=Function[{x},Exp[Interpolation[{#[[1]],Log[#[[2]]]}&/@Tab,InterpolationOrder->InterpOrder][x]]];

$InterpolateLogRate=False;
MyInterpolationRate[Tab_List]:=If[$InterpolateLogRate,MyInterpolationLog[Tab],MyInterpolation[Tab]]


(* ::Input::Initialization:: *)
MyChop[el_?NumericQ]:=(Chop[el,$MinMachineNumber]);
SetAttributes[MyChop,Listable];


(* ::Input::Initialization:: *)
MySet[Hold[expr_],value_]:=(expr=value);
MySetDelayed[Hold[expr_],value_]:=(expr:=value);


(* ::Input::Initialization:: *)
TableSimpsonC=Compile[{{a,_Real},{b,_Real},{Np,_Integer}},With[{h=1.(b-a)/Np,n2=Np/2},With[{h3=h/3.},Join[{{a,h3}},Table[{a+2. j h,2 h3},{j,1,n2-1}],Table[{a+(2. j-1) h,4 h3},{j,1,n2}],{{b,h3}}]]],CompilationTarget->"C","RuntimeOptions"->"Speed"];


(* ::Input::Initialization:: *)
MyCompile[LV_List,Body_]:=Compile[LV,Evaluate[Body],"RuntimeOptions"->"Speed",CompilationTarget->"C",CompilationOptions->{"InlineExternalDefinitions"->True},RuntimeAttributes->{Listable}]


(* ::Input::Initialization:: *)
V1dotV2=Compile[{{V1,_Real,1},{V2,_Real,1}},V1.V2,CompilationTarget->"C","RuntimeOptions"->"Speed"];


(* ::Input::Initialization:: *)
IntegrateFunction[fun_,pemin_,pemax_,Np_]:=With[{interv=(pemax-pemin)/(Np),tab=TableSimpsonC[pemin,pemax,Np]},V1dotV2[tab[[All,2]],MyChop[fun[tab[[All,1]]]]]];


(* ::Input::Initialization:: *)
SafeImport[args__]:=Module[{out},out=Catch[Check[Import[args],Print["File ",{args}[[1]]," not found. Quiting Kernel."];Throw[$Failed];,Import::nffil]];If[out===$Failed,Quit[]];out]


(* ::Input::Initialization:: *)
MyFrameTicksLog={{Automatic,Automatic},{{{Log[10^8],"\!\(\*SuperscriptBox[\(10\), \(8\)]\)"},{Log[10^8.5],"\!\(\*SuperscriptBox[\(10\), \(8.5\)]\)"},{Log[10^9],"\!\(\*SuperscriptBox[\(10\), \(9\)]\)"},{Log[10^9.5],"\!\(\*SuperscriptBox[\(10\), \(9.5\)]\)"},{Log[10^10],"\!\(\*SuperscriptBox[\(10\), \(10\)]\)"},{Log[10^10.5],"\!\(\*SuperscriptBox[\(10\), \(10.5\)]\)"},{Log[10^11],"\!\(\*SuperscriptBox[\(10\), \(11\)]\)"},{Log[10^11.5],"\!\(\*SuperscriptBox[\(10\), \(11.5\)]\)"}},Automatic}};

MyFrameTicks={{Automatic,Automatic},{{{10^8,"\!\(\*SuperscriptBox[\(10\), \(8\)]\)"},{10^8.5,"\!\(\*SuperscriptBox[\(10\), \(8.5\)]\)"},{10^9,"\!\(\*SuperscriptBox[\(10\), \(9\)]\)"},{10^9.5,"\!\(\*SuperscriptBox[\(10\), \(9.5\)]\)"},{10^10,"\!\(\*SuperscriptBox[\(10\), \(10\)]\)"},{10^10.5,"\!\(\*SuperscriptBox[\(10\), \(10.5\)]\)"},{10^11,"\!\(\*SuperscriptBox[\(10\), \(11\)]\)"},{10^11.5,"\!\(\*SuperscriptBox[\(10\), \(11\)]\).5"}},Automatic}};


(* ::Input::Initialization:: *)
Clear[Imn]
Imn[sgn_][m_,n_][x_]:=NIntegrate[((pe^2+x^2)^((m-1)/2) pe^(n+1))/(Exp[Sqrt[pe^2+x^2]]+sgn),{pe,0,Infinity},Method->{Automatic,"SymbolicProcessing"->0}]
ImnT[sgn_][m_,n_][T_]:=Imn[sgn][m,n][me/(kB T)]

(* Interpolations *)
ImnI[sgn_][m_,n_]:=ImnI[sgn][m,n]=Interpolation@Table[{me/(kB Tv),Imn[sgn][m,n][me/(kB Tv)]},{Tv,ListT}]
ImnIT[sgn_][m_,n_][T_]:=ImnI[sgn][m,n][me/(kB T)]


(* ::Input::Initialization:: *)
dme2[T_]:=((kB T)/me)^2 ((2\[Pi] \[Alpha]FS)/3+ (4\[Alpha]FS)/\[Pi] ImnT[1][0,1][T])(* Only main part of mass shift *)
dm\[Gamma]2[T_]:= (8\[Alpha]FS)/\[Pi] ImnT[1][0,1][T]((kB T)/me)^2


(* ::Input::Initialization:: *)
dme2Tab=Check[Import["Interpolations/dme2.dat","TSV"],Print["Precomputed data not found. We recompute and store the data."];$Failed,Import::nffil];

dmg2Tab=Check[Import["Interpolations/dmg2.dat","TSV"],Print["Precomputed data not found. We recompute and store the data."];$Failed,Import::nffil];


(* ::Input::Initialization:: *)

Timing[If[dme2Tab==$Failed||dmg2Tab==$Failed||$RecomputePlasmaCorrections,

dme2Tab=Table[{T,dme2[T]},{T,ListT}];
dmg2Tab=Table[{T,dm\[Gamma]2[T]},{T,ListT}];

Export["Interpolations/dme2.dat",dme2Tab,"TSV"];
Export["Interpolations/dmg2.dat",dmg2Tab,"TSV"];
];]


(* ::Input::Initialization:: *)
dme2I=MyInterpolation@ToExpression@dme2Tab;
dm\[Gamma]2I=MyInterpolation@ToExpression@dmg2Tab;


(* ::Input::Initialization:: *)
dme2N[T_?NumericQ]:=Which[T<Tf,0,T<=Ti ,dme2I[T],T>Ti,dme2I[Ti]];
dm\[Gamma]2N[T_?NumericQ]:=Which[T<Tf,0,T<=Ti ,dm\[Gamma]2I[T],T>Ti,dme2I[Ti]];


(* ::Input::Initialization:: *)
dme2x[x_]:=dme2N[me/(kB x)];


(* ::Input::Initialization:: *)
dPa[T_]:=dPa[T]=\[Alpha]FS/\[Pi] (kB T)^4 (-(2/3)ImnT[1][0,1][T]-2/\[Pi]^2 (ImnT[1][0,1][T])^2);


(* ::Input::Initialization:: *)
Fdp1dp2=Compile[{{p1,_Real},{p2,_Real},{x,_Real}},Evaluate[With[
{e1=Sqrt[p1^2+x^2],e2=Sqrt[p2^2+x^2]},
\[Alpha]FS/\[Pi]^3 (x^2 p1^2 p2^2)/(p1 p2 e1 e2) Log[Abs[(p1+p2)/(p1-p2)]] 1/((Exp[e1]+1)(Exp[e2]+1))
]],"RuntimeOptions"->"Speed",CompilationTarget->"C"];


Fdp1dp2N[p1_?NumericQ,p2_?NumericQ,x_]:=Fdp1dp2[p1,p2,x];


Clear[dPb]
dPb[Tv_]:=dPb[Tv]=(kB Tv)^4 With[{x=me /(kB Tv)},
0.5NIntegrate[
Fdp1dp2N[(p1pp2+p1mp2)/2,(p1pp2-p1mp2)/2,x]
+Fdp1dp2N[(p1pp2-p1mp2)/2,(p1pp2+p1mp2)/2,x],
{p1mp2,0.0001,Max[20,20* x]},{p1pp2,0.0001+Abs[p1mp2],Max[20,20*x]+Abs[p1mp2]},PrecisionGoal->4]
];


(* ::Input::Initialization:: *)
dP[T_]:=dP[T]= dPa[T]+If[$CompleteQEDPressure,dPb[T],0]

dPI:=dPI=Interpolation@Table[{Tv,dP[Tv]},{Tv,ListT}]


(* ::Input::Initialization:: *)
Clear[d\[Rho]]
d\[Rho][T_]:=d\[Rho][T]=-dP[T]+T dPI'[T]


(* ::Input::Initialization:: *)
dgP[T_]:=dP[T] 90/(\[Pi]^2 (kB T)^4);
dg\[Rho][T_]:=d\[Rho][T] 30/(\[Pi]^2 (kB T)^4);


(* ::Input::Initialization:: *)
dg\[Rho]dgP=Check[Import["Interpolations/dg.dat","TSV"],Print["Precomputed data not found. We recompute and store the data."];$Failed,Import::nffil];

Timing[If[dg\[Rho]dgP==$Failed||$RecomputePlasmaCorrections,

dg\[Rho]Tab=Table[{T,dg\[Rho][T]},{T,ListT}];
dgPTab=Table[{T,dgP[T]},{T,ListT}];

dg\[Rho]dgP={dg\[Rho]Tab,dgPTab};
Export["Interpolations/dg.dat",dg\[Rho]dgP,"TSV"];
];]


(* ::Input::Initialization:: *)
dg\[Rho]I=MyInterpolation@ToExpression[dg\[Rho]dgP[[1]]];
dgPI=MyInterpolation@ToExpression[dg\[Rho]dgP[[2]]];


(* ::Input::Initialization:: *)
dg\[Rho]N[T_?NumericQ]:=Which[T<Tf,0,T<=Ti ,dg\[Rho]I[T],T>Ti,dg\[Rho]I[Ti]];
dgPN[T_?NumericQ]:=Which[T<Tf,0,T<=Ti ,dgPI[T],T>Ti,dgPI[Ti]];


(* ::Input::Initialization:: *)
dg\[Rho]x[x_]:=dg\[Rho]N[me/(kB x)];
dgPx[x_]:=dgPN[me/(kB x)];


(* ::Input::Initialization:: *)
DSTNoQED=MyInterpolation@Table[{T,With[{x=me/(kB T)},1+45/(2\[Pi]^4) (1/3 Imn[1][0,3][x]+Imn[1][2,1][x])]},{T,ListT}];
DSTQED[Tv_]:=(3dg\[Rho]N[Tv]+dgPN[Tv])/8+DSTNoQED[Tv];


DST[Tv_]:=If[$QEDPlasmaCorrections,DSTQED[Tv],DSTNoQED[Tv]]
DSTN[T_?NumericQ]=Which[T<Tf,1,T<=Ti ,DST[T],T>Ti,DST[Ti]];


(* ::Input::Initialization:: *)
D\[Rho]TNoQED=MyInterpolation@Table[{T,With[{x=me/(kB T)},30/\[Pi]^4 (Imn[1][2,1][x])]},{T,ListT}];D\[Rho]T[T_]:=If[$QEDPlasmaCorrections,dg\[Rho]N[T]/2,0]+D\[Rho]TNoQED[T];


(* ::Input::Initialization:: *)
Listnl={-10.21703221236002,61.24438067531452,-340.3323864212157,1057.2707914654834,-2045.577491331372,2605.9087171012848,-2266.1521815470196,1374.2623075963388,-586.0618273295763,174.87532902234145,-35.715878215468045,4.7538967685808755,-0.3713438862054167,0.012908416591272199};

\[ScriptCapitalN][z_]:=If[z>=4,0,Exp[Plus@@Table[Listnl[[i+1]]z^i,{i,0,13}]]]


(* ::Input::Initialization:: *)
\[ScriptCapitalN]T[Tv_]:= \[ScriptCapitalN][me/(kB Tv)];
\[ScriptCapitalN]lT[lTv_]:= \[ScriptCapitalN][me/(kB Exp@lTv)];


(* ::Input::Initialization:: *)
DS2lTQED[lTv_]:=(2*2\[Pi]^2)/45 DSTQED[Exp@lTv];
DST2QED[Tv_]:=(2*2\[Pi]^2)/45 DSTQED[Tv]

DS2lTNoQED[lTv_]:=(2*2\[Pi]^2)/45 DSTNoQED[Exp@lTv];
DST2NoQED[Tv_]:=(2*2\[Pi]^2)/45 DSTNoQED[Tv]



(* ::Input::Initialization:: *)
SolveaOFTwhenID:=(laTCQED=NDSolveValue[{laTCN'[lTv]==(\[ScriptCapitalN]lT[lTv]-DS2lTQED'[lTv])/(\[ScriptCapitalN]lT[lTv]+3*DS2lTQED[lTv]),laTCN[Log@Tf]==Log[TCMB0/DSTQED[Tf]^(1/3)]},{laTCN},{lTv,Log@Ti,Log@Tf},PrecisionGoal->40,AccuracyGoal->9][[1]];

laTCNoQED=NDSolveValue[{laTCNNoQED'[lTv]==(\[ScriptCapitalN]lT[lTv]-DS2lTNoQED'[lTv])/(\[ScriptCapitalN]lT[lTv]+3*DS2lTNoQED[lTv]),laTCNNoQED[Log@Tf]==Log[TCMB0/DSTNoQED[Tf]^(1/3)]},{laTCNNoQED},{lTv,Log@Ti,Log@Tf},PrecisionGoal->40,AccuracyGoal->9][[1]];
);


(* ::Input::Initialization:: *)
SolveaOFTwhenID


(* ::Input::Initialization:: *)
aTCQED[Tv_]:=Exp[laTCQED[Log@Tv]];
aCQED[Tv_]:=aTCQED[Tv]/Tv;


(* ::Input::Initialization:: *)
aTCNoQED[Tv_]:=Exp[laTCNoQED[Log@Tv]];
aCNoQED[Tv_]:=aTCNoQED[Tv]/Tv;


(* ::Input::Initialization:: *)
InvertaofTwhenID:=
(TofaCQED=Interpolation@Table[{aCQED[T],T},{T,ListT}];
TofaCNoQED=Interpolation@Table[{aCNoQED[T],T},{T,ListT}];

aTofaCQED=Interpolation@Table[{aCQED[T],aTCQED[T]},{T,ListT}];
aTofaCNoQED=Interpolation@Table[{aCNoQED[T],aTCNoQED[T]},{T,ListT}];
);


(* ::Input::Initialization:: *)
InvertaofTwhenID


(* ::Input::Initialization:: *)
aC[T_]:=If[$QEDPlasmaCorrections,aCQED[T],aCNoQED[T]]


(* ::Input::Initialization:: *)
Solve\[Rho]\[Nu]OFawhenID:=(Timing[a4\[Rho]\[Nu]LogaQED=NDSolveValue[{bar\[Rho]aNQED'[lav]==1/(hbar^3 clight^5)(kB aTofaCQED[Exp@lav])^4 \[ScriptCapitalN]T[TofaCQED[Exp@lav]],bar\[Rho]aNQED[Log@aCQED@Ti]==aBB (kB aTCQED[Ti])^4 7/8 Nneu},{bar\[Rho]aNQED},{lav,Log[aCQED[Ti]],Log[aCQED[Tf]]},Method->"StiffnessSwitching",PrecisionGoal->12][[1]];];

Timing[a4\[Rho]\[Nu]LogaNoQED=NDSolveValue[{bar\[Rho]aNNoQED'[lav]==1/(hbar^3 clight^5)(kB aTofaCNoQED[Exp@lav])^4 \[ScriptCapitalN]T[TofaCNoQED[Exp@lav]],bar\[Rho]aNNoQED[Log@aCNoQED@Ti]==aBB (kB aTCNoQED[Ti])^4 7/8 Nneu},{bar\[Rho]aNNoQED},{lav,Log[aCNoQED[Ti]],Log[aCNoQED[Tf]]},Method->"StiffnessSwitching",PrecisionGoal->12][[1]];];
);


(* ::Input::Initialization:: *)
Solve\[Rho]\[Nu]OFawhenID


(* ::Input::Initialization:: *)
a4\[Rho]\[Nu]CQED[av_]:=a4\[Rho]\[Nu]LogaQED[Log@av];
\[Rho]\[Nu]CQED[av_]:=a4\[Rho]\[Nu]CQED[av]/av^4;


(* ::Input::Initialization:: *)

a4\[Rho]\[Nu]CNoQED[av_]:=a4\[Rho]\[Nu]LogaNoQED[Log@av];
\[Rho]\[Nu]CNoQED[av_]:=a4\[Rho]\[Nu]CNoQED[av]/av^4;


(* ::Input::Initialization:: *)
(*\[Rho]\[Nu]C[av_]:=If[$QEDPlasmaCorrections,\[Rho]\[Nu]CQED[av],\[Rho]\[Nu]CNoQED[av]];*)

\[Rho]\[Nu]IncompleteDecoupling[av_]:=If[$QEDPlasmaCorrections,\[Rho]\[Nu]CQED[av],\[Rho]\[Nu]CNoQED[av]];


(* ::Input::Initialization:: *)
RecomputeIncompleteNeutrinoDecoupling:=(
SolveaOFTwhenID;
InvertaofTwhenID;
Solve\[Rho]\[Nu]OFawhenID;
)


(* ::Input::Initialization:: *)
T\[Nu]overTDecoupling[T_]:=(FourOverEleven DST[T])^(1/3);
\[Rho]\[Nu]Decoupling[Tv_]:=aBB (kB T\[Nu]overTDecoupling[Tv]Tv)^4 7/8 Nneu;


(* ::Input::Initialization:: *)
T\[Nu]overTIncompleteDecouplingQED[Tv_]:=(\[Rho]\[Nu]CQED[aCQED[Tv]]/(aBB (kB Tv)^4 7/8 Nneu))^(1/4);
T\[Nu]overTIncompleteDecouplingNoQED[Tv_]:=(\[Rho]\[Nu]CNoQED[aCNoQED[Tv]]/(aBB (kB Tv)^4 7/8 Nneu))^(1/4);

T\[Nu]overTIncompleteDecoupling[T_]:=If[$QEDPlasmaCorrections,T\[Nu]overTIncompleteDecouplingQED[T],T\[Nu]overTIncompleteDecouplingNoQED[T]]


(* ::Input::Initialization:: *)
If[$IncompleteNeutrinoDecoupling,
T\[Nu]overT[Tv_]:=T\[Nu]overTIncompleteDecoupling[Tv];,
T\[Nu]overT[Tv_]:=T\[Nu]overTDecoupling[Tv];];
T\[Nu]overTTable = Table[{T\[Nu]overT[ListT[[i]]], ListT[[i]]},{i,1,Length[ListT]}];


(* ::Input::Initialization:: *)
T\[Nu]overTDecouplingNoQED[T_]:=(FourOverElevenNoQED* DSTNoQED[T])^(1/3);
T\[Nu]overTDecouplingQED[T_]:=(FourOverElevenQED* DSTQED[T])^(1/3);

EffectiveNeutrinosQED[Tv_]:=3(T\[Nu]overTIncompleteDecouplingQED[Tv]/T\[Nu]overTDecouplingNoQED[Tv])^4;
EffectiveNeutrinosNoQED[Tv_]:=3(T\[Nu]overTIncompleteDecouplingNoQED[Tv]/T\[Nu]overTDecouplingNoQED[Tv])^4;


(* ::Input::Initialization:: *)
zOFTDecouplingNoQED[T_]:=(DSTNoQED[Ti]/DSTNoQED[T])^(1/3);
zOFTDecouplingQED[T_]:=(DSTQED[Ti]/DSTQED[T])^(1/3);

zOFTIncompleteDecouplingNoQED[T_]:=(aCNoQED[T]T)/(aCNoQED[Ti]Ti);
zOFTIncompleteDecouplingQED[T_]:=(aCQED[T]T)/(aCQED[Ti]Ti);


(* ::Input::Initialization:: *)
z\[Nu]OFTQED[T_]:=T\[Nu]overTIncompleteDecouplingQED[T]*zOFTIncompleteDecouplingQED[T];
z\[Nu]OFTNoQED[T_]:=T\[Nu]overTIncompleteDecouplingNoQED[T]*zOFTIncompleteDecouplingNoQED[T];
z\[Nu]OFT[T_]:=If[$QEDPlasmaCorrections,z\[Nu]OFTQED[T],z\[Nu]OFTNoQED[T]]


(* ::Input::Initialization:: *)
If[$IncompleteNeutrinoDecoupling,
a[T_]:=aC[T],
a[T_]:=TCMB0/(T DST[T]^(1/3))];


(* ::Input::Initialization:: *)
zT[T_]:=(a[T]T)/(a[Ti]Ti);
znuT[T_]:=(a[T]T\[Nu]overT[T] T)/(a[Ti]T\[Nu]overT[Ti] Ti);


(* ::Input::Initialization:: *)
InvertaOFT:=(Tofa=Interpolation@Table[{a[T],T},{T,ListT}];);
(*aI=Interpolation@Table[{T,a[T]},{T,ListT}];*)


(* ::Input::Initialization:: *)
\[Eta]factorT[Tv_]:=nB[a[Tv]]*\[Pi]^2/(2Zeta[3]) ((hbar clight)/(kB Tv))^3;


(* ::Input::Initialization:: *)
\[Eta]factorTBis[Tv_]:=\[Eta]factor*(zT[Tf]/zT[Tv])^3;


(* ::Input::Initialization:: *)
FDe2p0[en_,x_]=Simplify[FD[en,x]en^2];
FDe3p0[en_,x_]=Simplify[FD[en,x]en^3];
FDe2p2[en_,x_]=Simplify@D[D[FD[en,x]en^2,en],en];

FDe3p2[en_,x_]=Simplify@D[D[FD[en,x]en^3,en],en];
FDe4p2[en_,x_]=Simplify@D[D[FD[en,x]en^4,en],en];
FDe2p1[en_,x_]=Simplify@D[FD[en,x]en^2,en];
FDe3p1[en_,x_]=Simplify@D[FD[en,x]en^3,en];
FDe4p1[en_,x_]=Simplify@D[FD[en,x]en^4,en];


(* ::Input::Initialization:: *)
FD\[Nu]e2p0[en_,\[Phi]_,x_]=Simplify[FD\[Nu][en,\[Phi],x]en^2];
FD\[Nu]e3p0[en_,\[Phi]_,x_]=Simplify[FD\[Nu][en,\[Phi],x]en^3];
FD\[Nu]e2p2[en_,\[Phi]_,x_]=Simplify@D[D[FD\[Nu][en,\[Phi],x]en^2,en],en];

FD\[Nu]e3p2[en_,\[Phi]_,x_]=Simplify@D[D[FD\[Nu][en,\[Phi],x]en^3,en],en];
FD\[Nu]e4p2[en_,\[Phi]_,x_]=Simplify@D[D[FD\[Nu][en,\[Phi],x]en^4,en],en];
FD\[Nu]e2p1[en_,\[Phi]_,x_]=Simplify@D[FD\[Nu][en,\[Phi],x]en^2,en];
FD\[Nu]e3p1[en_,\[Phi]_,x_]=Simplify@D[FD\[Nu][en,\[Phi],x]en^3,en];
FD\[Nu]e4p1[en_,\[Phi]_,x_]=Simplify@D[FD\[Nu][en,\[Phi],x]en^4,en];


(* ::Input::Initialization:: *)
\[Lambda]BORN=With[{q=Q/me},NIntegrate[en (en-q)^2 Sqrt[en^2-1],{en,1,q}]]


(* ::Input::Initialization:: *)
AgCzarnecki=-0.34;
CCzarnecki=0.891;
mA=1.2 GeV;
ConstantSirlin =4Log[Subscript[m, Z]/mp]+Log[mp/mA]+2CCzarnecki+AgCzarnecki;


(* ::Input::Initialization:: *)
Rd[x_]:=ArcTanh[x]/x;


(* ::Input::Initialization:: *)
Lfun[x_]=Integrate[Log[1-t]/t,{t,0,x},Assumptions->x<1&&x>0](* Lfun is called the Spence function *)


(* ::Input::Initialization:: *)
LfunSeries[b_]=Normal@Series[-1/4*(1+b)^6*4/b Lfun[(2b)/(1+b)],{b,0,12(*22*)}]


(* ::Input::Initialization:: *)
$SeriesSpenceFunction=False;

SirlinGFunction[b_,y_,en_]:=(3Log[mp/(me)]-3/4+4(Rd[b]-1)(y/(3 en)-3/2+Log[2y])+Rd[b](2(1+b^2)+y^2/(6 en^2)-4 b Rd[b])+If[$SeriesSpenceFunction,-4/(1+b)^6*LfunSeries[b],4/b Lfun[(2b)/(1+b)]]);
Cd[b_,y_,en_]:=(ConstantSirlin+SirlinGFunction[b,y,en]);


(* ::Input::Initialization:: *)
LFactor=1.02094;
SFactor=1.02248;
\[Delta]factor=-0.00043*2Pi/\[Alpha]FS;
NLL=-0.0001;


(* ::Input::Initialization:: *)
RadiativeCorrectionsResummed[b_,y_,en_]:=(1+\[Alpha]FS/(2\[Pi]) (SirlinGFunction[b,y,en]-3Log[mp/(2Q)]))*
(LFactor+\[Alpha]FS/\[Pi] CCzarnecki+\[Alpha]FS/(2\[Pi]) \[Delta]factor)*(SFactor+1/(134*2*Pi)*(Log[mp/mA]+AgCzarnecki)+NLL);


(* ::Input::Initialization:: *)
RadiativeCorrections[b_,y_,en_]:=If[$ResummedLogsRadiativeCorrections,RadiativeCorrectionsResummed[b,y,en],(1+\[Alpha]FS/(2\[Pi]) Cd[b,y,en])]


(* ::Input::Initialization:: *)
FermiRelat[b_]:=With[{\[Gamma]=Sqrt[1-\[Alpha]FS^2]-1,\[Lambda]Compton=1/(me/(hbar clight))},
(1+\[Gamma]/2)*4((2radiusproton b)/\[Lambda]Compton)^(2\[Gamma])*1/Gamma[3+2\[Gamma]]^2 Exp[(\[Pi] \[Alpha]FS)/b]*1/(1-b^2)^\[Gamma] Abs[Gamma[1+\[Gamma]+I \[Alpha]FS/b]]^2];

FermiNonRelat[b_]:=(2\[Pi] \[Alpha]FS/b)/(1-Exp[-2\[Pi] \[Alpha]FS/b]);


(* ::Input::Initialization:: *)
If[$RelativisticFermiFunction,

Fermi[b_]:=FermiRelat[b];
bFermi[b_]:=b Fermi[b];,

Fermi[b_]:=FermiNonRelat[b];
bFermi[b_]:=(2\[Pi] \[Alpha]FS)/(1-Exp[-2\[Pi] \[Alpha]FS/b]);]


(* ::Input::Initialization:: *)
\[Lambda]FermiOnly=With[{q=Q/me ,b=Sqrt[en^2-1]/en,y=Q/me -en},
NIntegrate[en (en-q)^2 en*bFermi[b],{en,1.0000001,q}]]


(* ::Input::Initialization:: *)
\[Lambda]FermiOnly/(\[Lambda]BORN)


(* ::Input::Initialization:: *)
\[Lambda]Rad=With[{q=Q/me ,b=Sqrt[en^2-1]/en,y=Q/me -en},
NIntegrate[en (en-q)^2 en(RadiativeCorrections[b,y,en])*bFermi[b],{en,1.0000001,q}]]


(* ::Input::Initialization:: *)
\[Lambda]Rad/\[Lambda]FermiOnly


(* ::Input::Initialization:: *)
IntegrateCorrectionNeutronDecay[fun_]:=
NIntegrate[fun[pe],{pe,0.0000001,Sqrt[(Q/me)^2-1]},WorkingPrecision->MachinePrecision];


(* ::Input::Initialization:: *)
\[Chi]FMNeutronDecay[en_,pe_]:=
With[{M=mp/me,enu=en-Q/me,f1=((1+gA)^2+4 fWM gA)/(1+3gA^2),f2=((1-gA)^2-4fWM gA)/(1+3gA^2),f3=(gA^2-1)/(1+3gA^2)},
 f1*enu^2 (pe^2/(M*en))
+f2*enu^3(-(1/M))
+ (f1+f2+f3) 1/(2M)*(4enu^3+2enu pe^2)
+f3*1/(3M) 3enu^2  (pe^2)/(en)
];


(* ::Input::Initialization:: *)
I\[Lambda]FM[pe_]:=With[{en=Sqrt[pe^2+1]},With[{b=pe/en},pe^2*
(\[Chi]FMNeutronDecay[en,pe]*If[$RadiativeCorrections&&$CoupledFMandRC,(RadiativeCorrections[b,Abs[en- Q/me ],en])Fermi[b],1])
]];


(* ::Input::Initialization:: *)
\[Lambda]FM=If[$FiniteNucleonMass,IntegrateCorrectionNeutronDecay[I\[Lambda]FM],0]


(* ::Input::Initialization:: *)
CorrectionRate=\[Lambda]FM/\[Lambda]BORN


(* ::Input::Initialization:: *)
\[Lambda]Rad


(* ::Input::Initialization:: *)
\[Lambda]FM


(* ::Input::Initialization:: *)
\[Lambda]RadandFM=\[Lambda]Rad+\[Lambda]FM


(* ::Input::Initialization:: *)
\[Lambda]Cooper=1.03887*1.6887
\[Lambda]Czarnecki=1.0390*1.6887 (* = (1+RC)*f with f=1.6887 and RC = 0.0390(8) [Czarnecki et al. 2004]] *)


(* ::Input::Initialization:: *)
MixingCosAngle=0.97420;(* (+-16) Value taken from CKM particle data group 2017. More precisely from the review on Vud Vus of the PDG 2017.*)
MyK=MixingCosAngle^2 (GF)^2 (1+3(gA)^2)/(2\[Pi]^3)*(me )^5 /hbar
1/MyK/\[Lambda]RadandFM
1/MyK/\[Lambda]Czarnecki
1/MyK/\[Lambda]Cooper


(* ::Input::Initialization:: *)
\[Tau]neutron


(* ::Input::Initialization:: *)
pemin=0.00001;
pemiddle[x_]:=Sqrt[Max[pemin^2,(Q/me )^2-1 -If[$QEDMassShift,dme2x[x],0]]];
pemaxC[x_]:=Max[7,30/x];
pemax[x_]:=Max[7,30/x];


(* ::Input::Initialization:: *)
$TnuEqualT=False;


(* ::Input::Initialization:: *)
IntegratedpNpoints[fun_,sgnq_,Tv_,Npoints_]:=With[{x=me/(kB Tv) ,znu=me/(kB Tv T\[Nu]overT[Tv]) },
If[$FastPENRatesIntegrals,
IntegrateFunction[fun[#,x,If[$TnuEqualT,x,znu],sgnq]&,pemin,pemaxC[x],Npoints],
NIntegrate[fun[pe,x,If[$TnuEqualT,x,znu],sgnq],{pe,pemin,pemiddle[x],pemax[x]}]
]]

IntegrateRatedp[fun_,sgnq_,Tv_]:=IntegratedpNpoints[fun,sgnq,Tv,$PENRatesIntegralsPoints];



(* ::Input::Initialization:: *)
enOFpe[pe_,x_]:=Sqrt[pe^2+1 +If[$QEDMassShift,dme2x[x],0]];


(* ::Input::Initialization:: *)
IPENdpFrom\[Chi]NoCCR[en_,pe_,x_,znu_,sgnq_,\[Chi]function_]:=With[{q=Q/me },With[{b=pe/en},
pe^2*(\[Chi]function[en,pe,x,znu,sgnq]+\[Chi]function[-en,pe,x,znu,sgnq])
]];


(* ::Input::Initialization:: *)
Fermi[sgnq_,signE_,b_?NumericQ]:=If[sgnq signE >0,Fermi[b],1];
SetAttributes[Fermi,Listable];


(* ::Input::Initialization:: *)
IPENdpFrom\[Chi]CCR[en_,pe_,x_,znu_,sgnq_,\[Chi]function_]:=With[{q=Q/me ,b=pe/en},
pe^2*(\[Chi]function[en,pe,x,znu,sgnq](RadiativeCorrections[b,Abs[sgnq Q/me-en],en])Fermi[sgnq,1,b]+\[Chi]function[-en,pe,x,znu,sgnq](RadiativeCorrections[b, Abs[sgnq Q/me+en],en])Fermi[sgnq,-1,b])
];


(* ::Input::Initialization:: *)
\[Chi][en_,pe_,x_,znu_,sgnq_]:=With[{q=Q/me },FD\[Nu][en-sgnq q,sgnq \[Xi]\[Nu],znu]FD[-en,x](en-sgnq q)^2];


(* ::Input::Initialization:: *)
IPENdp[pe_,x_,znu_,sgnq_]:=IPENdpFrom\[Chi]NoCCR[enOFpe[pe,x],pe,x,If[$TnuEqualT,x,znu],sgnq,\[Chi]]


(* ::Input::Initialization:: *)
IPENdpCheatNeutrinoTemperature[pe_,x_,znu_,sgnq_]:=IPENdpFrom\[Chi]NoCCR[Sqrt[pe^2+1],pe,x,x,sgnq,\[Chi]]


(* ::Input::Initialization:: *)
\[Lambda]nTOpBORN[Tv_]:=IntegrateRatedp[IPENdp,1,Tv];
\[Lambda]pTOnBORN[Tv_]:=IntegrateRatedp[IPENdp,-1,Tv];


(* ::Input::Initialization:: *)
\[Lambda]nTOpBORNCheatNeutrino[Tv_]:=IntegrateRatedp[IPENdpCheatNeutrinoTemperature,1,Tv];
\[Lambda]pTOnBORNCheatNeutrino[Tv_]:=IntegrateRatedp[IPENdpCheatNeutrinoTemperature,-1,Tv];


(* ::Input::Initialization:: *)
\[Chi]FM[en_,pe_,x_,znu_,sgnq_]:=
With[{\[Phi]=sgnq \[Xi]\[Nu],q=Q/me ,M=(mp+mn -sgnq Q)/(2me ),Mp=mp/me ,Mn=mn /me ,enu=en-sgnq Q/me,
f1=((1+sgnq gA)^2+4fWM sgnq gA)/(1+3gA^2),
f2=((1-sgnq gA)^2-4fWM sgnq gA)/(1+3gA^2),f3=(gA^2-1)/(1+3gA^2)},
f1*FD\[Nu]e2p0[enu,\[Phi],znu]FD[-en,x](pe^2/(M*en))
+f2*FD\[Nu]e3p0[enu,\[Phi],znu]FD[-en,x](-(1/M))
+(f1+f2+f3) 1/(2x M)*(FD\[Nu]e4p2[enu,\[Phi],znu]FD[-en,x]+FD\[Nu]e2p2[enu,\[Phi],znu]FD[-en,x]pe^2)
+(f1+f2+f3) 1/(2M)*(FD\[Nu]e4p1[enu,\[Phi],znu]FD[-en,x]+FD\[Nu]e2p1[enu,\[Phi],znu]FD[-en,x]pe^2)
-(f1+f2) 1/(x M)*(FD\[Nu]e3p1[enu,\[Phi],znu]FD[-en,x]+FD\[Nu]e2p1[enu,\[Phi],znu]FD[-en,x]pe^2/(-en))
-f3*3/(x M) FD\[Nu]e2p0[enu,\[Phi],znu]FD[-en,x](* This term seems to give very small corrections *)
+f3*1/(3M) FD\[Nu]e3p1[enu,\[Phi],znu]FD[-en,x] pe^2/(en)
+f3*2/(2 x*3M) FD\[Nu]e3p2[enu,\[Phi],znu]FD[-en,x] pe^2/(en)
-(f1+f2+f3)*3/(2x)*(1-(Mn/Mp)^sgnq)*(FD\[Nu]e2p1[enu,\[Phi],znu]FD[-en,x])
];


(* ::Input::Initialization:: *)
IPENdpFMNoCCR[pe_,x_,znu_,sgnq_]:=IPENdpFrom\[Chi]NoCCR[enOFpe[pe,x],pe,x,If[$TnuEqualT,x,znu],sgnq,\[Chi]FM]
IPENdpFMCCR[pe_,x_,znu_,sgnq_]:=IPENdpFrom\[Chi]CCR[enOFpe[pe,x],pe,x,If[$TnuEqualT,x,znu],sgnq,\[Chi]FM]


(* ::Input::Initialization:: *)
IPENdpFMCheatNeutrinoTemperature[pe_,x_,znu_,sgnq_]:=IPENdpFrom\[Chi]NoCCR[enOFpe[pe,x],pe,x,x,sgnq,\[Chi]FM]


(* ::Input::Initialization:: *)
Clear[\[Lambda]nTOpFMCCR,\[Lambda]pTOnFMCCR,\[Lambda]nTOpFMNoCCR,\[Lambda]pTOnFMNoCCR,\[Lambda]nTOpCheatNeutrinoFM,\[Lambda]pTOnCheatNeutrinoFM]


(* ::Input::Initialization:: *)
\[Lambda]nTOpFMCCR[Tv_]:=IntegrateRatedp[IPENdpFMCCR,1,Tv];
\[Lambda]pTOnFMCCR[Tv_]:=IntegrateRatedp[IPENdpFMCCR,-1,Tv];


(* ::Input::Initialization:: *)
\[Lambda]nTOpFMNoCCR[Tv_]:=IntegrateRatedp[IPENdpFMNoCCR,1,Tv];
\[Lambda]pTOnFMNoCCR[Tv_]:=IntegrateRatedp[IPENdpFMNoCCR,-1,Tv];


(* ::Input::Initialization:: *)
\[Lambda]nTOpCheatNeutrinoFM[Tv_]:=IntegrateRatedp[IPENdpFMCheatNeutrinoTemperature,1,Tv];
\[Lambda]pTOnCheatNeutrinoFM[Tv_]:=IntegrateRatedp[IPENdpFMCheatNeutrinoTemperature,-1,Tv];


(* ::Input::Initialization:: *)
DetailedBalanceRatio0[T_]:=Exp[-(Q/(kB T))-\[Xi]\[Nu]];


(* ::Input::Initialization:: *)
DetailedBalance0[T_]:=(\[Lambda]nTOpBORN[T])/(\[Lambda]pTOnBORN[T])*DetailedBalanceRatio0[T];
DetailedBalanceCheatNeutrino0[T_]:=(\[Lambda]nTOpBORNCheatNeutrino[T])/(\[Lambda]pTOnBORNCheatNeutrino[T])*DetailedBalanceRatio0[T];


(* ::Input::Initialization:: *)
DetailedBalanceRatio[T_]:=Exp[-(Q/(kB T))-\[Xi]\[Nu]](1+(1+\[Alpha]) Q/mp)^(3/2);


(* ::Input::Initialization:: *)
IPENdpCCR[pe_,x_,znu_,sgnq_]:=IPENdpFrom\[Chi]CCR[enOFpe[pe,x],pe,x,If[$TnuEqualT,x,znu],sgnq,\[Chi]]


(* ::Input::Initialization:: *)
\[Lambda]nTOpCCR[Tv_]:=IntegrateRatedp[IPENdpCCR,1,Tv];
\[Lambda]pTOnCCR[Tv_]:=IntegrateRatedp[IPENdpCCR,-1,Tv];


(* ::Input::Initialization:: *)
BEQ[en_,sq_]:=sq BE[sq en];


(* ::Input::Initialization:: *)
\[Chi]tilde[en_,znu_,sgnq_]:=With[{q=Q/me },FD\[Nu][en-sgnq q,sgnq \[Xi]\[Nu],znu](en-sgnq q)^2]


(* ::Input::Initialization:: *)
IPENCCRT[en_,k_,x_,znu_,sgnq_]:=With[{p=Sqrt[en^2-1]},With[{b=p/en,A=(2 en^2+k^2)Log[(en+p)/(en-p)]-4 p en,B=2 en Log[(en+p)/(en-p)]-4p},
\[Alpha]FS/(2\[Pi])*(BE[x k]/k)*(A(FD[-en,x]Fermi[sgnq,1,b](\[Chi]tilde[en-k,znu,sgnq]+\[Chi]tilde[en+k,znu,sgnq]-2\[Chi]tilde[en,znu,sgnq])+FD[en,x]Fermi[sgnq,-1,b](\[Chi]tilde[-en+k,znu,sgnq]+\[Chi]tilde[-en-k,znu,sgnq]-2\[Chi]tilde[-en,znu,sgnq]))
-k B *(FD[-en,x]Fermi[sgnq,1,b](\[Chi]tilde[en-k,znu,sgnq]-\[Chi]tilde[en+k,znu,sgnq])+FD[en,x]Fermi[sgnq,-1,b](\[Chi]tilde[-en+k,znu,sgnq]-\[Chi]tilde[-en-k,znu,sgnq]))
)
]];

(* Compiled version to compute the integrals slightly faster *)
IPENCCRTC=MyCompile[{{en,_Real},{k,_Real},{x,_Real},{znu,_Real},{sgnq,_Integer}},Evaluate[IPENCCRT[en,k,x,znu,sgnq]]];IPENCCRTCN[en_?NumericQ,k_,x_,znu_,sgnq_]:=IPENCCRTC[en,k,x,znu,sgnq]


(* ::Input::Initialization:: *)
Clear[IPENCCRDiffBremsstrahlungCN,IPENCCRDiffBremsstrahlungC,IPENCCRDiffBremsstrahlung]
IPENCCRDiffBremsstrahlung[en_,k_,x_,znu_,sgnq_]:=With[{p=Sqrt[en^2-1],q=Q/me},With[{b=p/en,A=(2 en^2+k^2)Log[(en+p)/(en-p)]-4 p en,B=2 en Log[(en+p)/(en-p)]-4p},With[{Fp=A+k B,Fm=A-k B},
\[Alpha]FS/(2\[Pi] k) ((FD[-en,x]Fermi[sgnq,1,b](Fp \[Chi]tilde[en+k,znu,sgnq]-If[k<Abs[en-sgnq q],Fp FD[en-sgnq q,znu](Abs[en-sgnq q]-k)^2,0]))
+(FD[en,x]Fermi[sgnq,-1,b](Fm \[Chi]tilde[-en+k,znu,sgnq]-If[k<Abs[en+sgnq q],Fp FD[-en-sgnq q,znu](Abs[en+sgnq q]-k)^2,0]))
)
]]];

(* We compile for the integration *)
IPENCCRDiffBremsstrahlungC=MyCompile[{{en,_Real},{k,_Real},{x,_Real},{znu,_Real},{sgnq,_Integer}},Evaluate[IPENCCRDiffBremsstrahlung[en,k,x,znu,sgnq]]];IPENCCRDiffBremsstrahlungCN[en_?NumericQ,k_,x_,znu_,sgnq_]:=IPENCCRDiffBremsstrahlungC[en,k,x,znu,sgnq]


(* ::Input::Initialization:: *)
IPENFiveBodyT0[en_,k_,x_,znu_,sgnq_]:=With[{p=Sqrt[en^2-1]},With[{A=(2 en^2+k^2)Log[(en+p)/(en-p)]-4 p en,B=2 en Log[(en+p)/(en-p)]-4p},
\[Alpha]FS/(2\[Pi] k) (FD[en,x])\[Chi]tilde[-en+k,znu,sgnq](A-k B)]]


(* Compiled version *)
IPENFiveBodyT0C=Compile[{{en,_Real},{k,_Real},{x,_Real},{znu,_Real},{sgnq,_Integer}},Evaluate[With[{p=Sqrt[en^2-1]},With[{A=(2 en^2+k^2)Log[(en+p)/(en-p)]-4 p en,B=2 en Log[(en+p)/(en-p)]-4p},
\[Alpha]FS/(2\[Pi] k) (-BE[-k x])*(FD[en,x])\[Chi]tilde[-en+k,znu,sgnq](A-k B)]]],"RuntimeOptions"->"Speed",CompilationTarget->"C"];
IPENFiveBodyT0CN[en_?NumericQ,k_,x_,znu_,sgnq_]:=IPENFiveBodyT0C[en,k,x,znu,sgnq]


(* ::Input::Initialization:: *)
C1dE[en_,x_,znu_,sgnq_]:=With[{pe=Sqrt[en^2-1],q=Q/me },-((\[Alpha]FS en)/(2\[Pi] pe))*(2\[Pi]^2)/(3x^2) (\[Chi][en,pe,x,znu,sgnq]+\[Chi][-en,pe,x,znu,sgnq])];


(* ::Input::Initialization:: *)
C2dE1dE2[e1_,e2_,x_,znu_,sgnq_]:=With[{p1=Sqrt[e1^2-1],p2=Sqrt[e2^2-1],q=Q/me },With[{L=Log[(e1 e2 +p1 p2 +1)/(e1 e2 -p1 p2 +1)]},
\[Alpha]FS/(2\[Pi] ) (\[Chi][e1,p1,x,znu,sgnq]+\[Chi][-e1,p1,x,znu,sgnq])
*(-(1/4) Log[((p1+p2)/(p1-p2))^2]^2*(FDp[e2,x] p2/p1 e1^2/e2 (e1+e2)+FD[e2,x] e1^2/(p1 p2) (e2+e1/e2^2))
+Log[((p1+p2)/(p1-p2))^2](FDp[e2,x](p2^2 e1/e2 (1/p1^2+2)-e1^2 p2/p1 L)+FD[e2,x](e1/(p1^2 e2^2) (e2^2+2p1^2+1)-(e1^2+e2^2)/(e1+e2)-(e1^2 e2)/(p1 p2) L))
-FD[e2,x](4 e1 p2/p1+2 e2 L))
]];


(* Compiled version *)
C2dE1dE2C=Compile[{{e1,_Real},{e2,_Real},{x,_Real},{znu,_Real},{sgnq,_Integer}},Evaluate[With[{p1=Sqrt[e1^2-1],p2=Sqrt[e2^2-1],q=Q/me },With[{L=Log[(e1 e2 +p1 p2 +1)/(e1 e2 -p1 p2 +1)]},
\[Alpha]FS/(2\[Pi] ) (\[Chi][e1,p1,x,znu,sgnq]+\[Chi][-e1,p1,x,znu,sgnq])
*(-(1/4) Log[((p1+p2)/(p1-p2))^2]^2*(FDp[e2,x] p2/p1 e1^2/e2 (e1+e2)+FD[e2,x] e1^2/(p1 p2) (e2+e1/e2^2))
+Log[((p1+p2)/(p1-p2))^2](FDp[e2,x](p2^2 e1/e2 (1/p1^2+2)-e1^2 p2/p1 L)+FD[e2,x](e1/(p1^2 e2^2) (e2^2+2p1^2+1)-(e1^2+e2^2)/(e1+e2)-(e1^2 e2)/(p1 p2) L))
-FD[e2,x](4 e1 p2/p1+2 e2 L))
]]],"RuntimeOptions"->"Speed",CompilationTarget->"C"];
C2dE1dE2CN[e1_?NumericQ,e2_?NumericQ,x_,znu_,sgnq_]:=C2dE1dE2C[e1,e2,x,znu,sgnq];


(* ::Input::Initialization:: *)
\[Lambda]nTOpThermalTruePhoton[Tv_]:=(*\[Lambda]nTOpThermalTruePhoton[Tv]=*)With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[IPENCCRTCN[en,k,x,If[$TnuEqualT,x,znu],1],{k,0.001,Max[10,20/x]},{en,1.001,Max[10,20/x]},PrecisionGoal->4]
];

\[Lambda]nTOpThermalDiffBremsstrahlung[Tv_]:=(*\[Lambda]nTOpThermalDiffBremsstrahlung[Tv]=*)With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[IPENCCRDiffBremsstrahlungCN[en,k,x,If[$TnuEqualT,x,znu],1],{en,1.001,Max[10,20/x]},{k,0.001,Abs[en-q],Abs[en+q],Max[10,20/x]},PrecisionGoal->4]
];


(* ::Input::Initialization:: *)
\[Lambda]nTOpThermal[Tv_]:=(*\[Lambda]nTOpThermal[Tv]=*)With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[C1dE[en,x,If[$TnuEqualT,x,znu],1],{en,1,Max[25,150/x]}]
+NIntegrate[1/2C2dE1dE2CN[(e1pe2+e1me2)/2,(e1pe2-e1me2)/2,x,If[$TnuEqualT,x,znu],1],{e1me2,-Max[10,15/x],-0.001},{e1pe2,2.001+Abs[e1me2],2+Abs[e1me2]+Max[10,15/x]},PrecisionGoal->3,Exclusions->{0}]
+NIntegrate[1/2C2dE1dE2CN[(e1pe2+e1me2)/2,(e1pe2-e1me2)/2,x,If[$TnuEqualT,x,znu],1],{e1me2,0.001,Max[10,15/x]},{e1pe2,2.001+Abs[e1me2],2+Abs[e1me2]+Max[10,15/x]},PrecisionGoal->3]
];



(* ::Input::Initialization:: *)
\[Lambda]nTOp5bodies[Tv_]:=(*\[Lambda]nTOp5bodies[Tv]=*)With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[IPENFiveBodyT0CN[en,k,x,If[$TnuEqualT,x,znu],1],{en,1,Max[20,20/x]},{k,en+q,en+q+Max[20,20/x]},PrecisionGoal->4]
];


(* ::Input::Initialization:: *)
\[Lambda]pTOnThermalTruePhoton[Tv_]:=(*\[Lambda]pTOnThermalTruePhoton[Tv]=*)If[Tv<10^8.2 (* When the temperature is too low it is better to put 0 *),0,
With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[IPENCCRTCN[en,k,x,If[$TnuEqualT,x,znu],-1],{k,0.001,Max[10,20/x]},{en,1.001,Max[10,20/x]},PrecisionGoal->4]
]];

\[Lambda]pTOnThermalDiffBremsstrahlung[Tv_]:=(*\[Lambda]pTOnThermalDiffBremsstrahlung[Tv]=*)If[Tv<10^8.2 (* When the temperature is too low it is better to put 0 *),0,
With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[IPENCCRDiffBremsstrahlungCN[en,k,x,If[$TnuEqualT,x,znu],-1],{en,1.001,Max[10,20/x]},{k,0.001,Abs[en-q],Abs[en+q],Max[10,20/x]},PrecisionGoal->4]
]];


\[Lambda]pTOnThermal[Tv_]:=(*\[Lambda]pTOnThermal[Tv]=*)If[Tv<10^8.2 (* When the temperature is too low it is better to put 0 *),0,
With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[C1dE[en,x,If[$TnuEqualT,x,znu],-1],{en,1,Max[25,150/x]}]
+NIntegrate[1/2C2dE1dE2CN[(e1pe2+e1me2)/2,(e1pe2-e1me2)/2,x,If[$TnuEqualT,x,znu],-1],{e1me2,-Max[10,15/x],-0.001},{e1pe2,2.001+Abs[e1me2],2+Abs[e1me2]+Max[10,15/x]},PrecisionGoal->3]
+NIntegrate[1/2C2dE1dE2CN[(e1pe2+e1me2)/2,(e1pe2-e1me2)/2,x,If[$TnuEqualT,x,znu],-1],{e1me2,0.001,Max[10,15/x]},{e1pe2,2.001+Abs[e1me2],2+Abs[e1me2]+Max[10,15/x]},PrecisionGoal->3]
]];


(* ::Input::Initialization:: *)
\[Lambda]nTOpCCRTh[Tv_]:=(\[Lambda]nTOpThermal[Tv]+\[Lambda]nTOpThermalTruePhoton[Tv]+If[$CorrectionBremsstrahlung,\[Lambda]nTOpThermalDiffBremsstrahlung[Tv],\[Lambda]nTOp5bodies[Tv]]);

\[Lambda]pTOnCCRTh[Tv_]:=(\[Lambda]pTOnThermal[Tv]+\[Lambda]pTOnThermalTruePhoton[Tv]+If[$CorrectionBremsstrahlung,\[Lambda]pTOnThermalDiffBremsstrahlung[Tv],0]);


(* ::Input::Initialization:: *)
\[Lambda]0:=If[$RadiativeCorrections,\[Lambda]Rad,\[Lambda]BORN]+If[$FiniteNucleonMass,\[Lambda]FM,0]


(* ::Input::Initialization:: *)
Clear[\[Lambda]nTOp,\[Lambda]pTOn,\[Lambda]nTOpNormalized,\[Lambda]pTOnNormalized];
\[Lambda]nTOpNormalized[Tv_]:=(\[Lambda]0)^-1 (
If[$RadiativeCorrections,\[Lambda]nTOpCCR[Tv],\[Lambda]nTOpBORN[Tv]]
+If[$RadiativeThermal,\[Lambda]nTOpCCRTh[Tv],0]
+If[$FiniteNucleonMass,If[$CoupledFMandRC,\[Lambda]nTOpFMCCR[Tv],\[Lambda]nTOpFMNoCCR[Tv]],0]
);

\[Lambda]pTOnNormalized[Tv_]:=(\[Lambda]0)^-1 (
If[$RadiativeCorrections,\[Lambda]pTOnCCR[Tv],\[Lambda]pTOnBORN[Tv]]
+If[$RadiativeThermal,\[Lambda]pTOnCCRTh[Tv],0]
+If[$FiniteNucleonMass,If[$CoupledFMandRC,\[Lambda]pTOnFMCCR[Tv],\[Lambda]pTOnFMNoCCR[Tv]],0]);


(* ::Input::Initialization:: *)
Clear[\[Lambda]nTOp]
\[Lambda]nTOp[Tv_]:=1/\[Tau]neutron \[Lambda]nTOpNormalized[Tv];
\[Lambda]pTOn[Tv_]:=1/\[Tau]neutron \[Lambda]pTOnNormalized[Tv];


(* ::Input::Initialization:: *)
LetterFromBoolean[Bool_]:=If[Bool,"T","F"];
StringFromBoolean[BoolList_List]:=StringJoin[LetterFromBoolean/@BoolList];
BooleanSuffix=StringFromBoolean[{$RadiativeCorrections,$RadiativeThermal,$FiniteNucleonMass,$CoupledFMandRC,$QEDPlasmaCorrections,$IncompleteNeutrinoDecoupling}]


(* ::Input::Initialization:: *)
(*NamePENFilenp="Interpolations/PENRatenp"<>BooleanSuffix<>".dat";
NamePENFilepn="Interpolations/PENRatepn"<>BooleanSuffix<>".dat";*)
NamePENFilenp="Interpolations/NP_RATES";
NamePENFilepn="Interpolations/PN_RATES";


(* ::Input::Initialization:: *)
$BornBool=Not[$RadiativeThermal]&&Not[$RadiativeCorrections]&&Not[$FiniteNucleonMass];


(* ::Input::Initialization:: *)
MyTableWeakRate:=If[$ParallelWeakRates,ParallelEvaluate[Off[NIntegrate::slwcon];];ParallelTable,Table]

PreComputeWeakRates:=(
Off[NIntegrate::slwcon];
\[Lambda]nTOpTab=MyTableWeakRate[{T,\[Lambda]nTOpNormalized[T]},{T,ListT}];
\[Lambda]pTOnTab=MyTableWeakRate[{T,\[Lambda]pTOnNormalized[T]},{T,ListT}];
TabRatenp=\[Lambda]nTOpTab;
TabRatepn=\[Lambda]pTOnTab;
On[NIntegrate::slwcon];
\[Lambda]nTOpI=MyInterpolationRate[ToExpression[TabRatenp]];
\[Lambda]pTOnI=MyInterpolationRate[ToExpression[TabRatepn]];
);


(* ::Input::Initialization:: *)
(*TabRatenp=Check[Import[NamePENFilenp,"TSV"],Print["Precomputed n -> p rate not found. We recompute the rates and store them. This can take very long"];$Failed,Import::nffil];

TabRatepn=Check[Import[NamePENFilepn,"TSV"],Print["Precomputed p -> n rate not found. We recompute the rates and store them. This can take very long"];$Failed,Import::nffil];*)
TabRatenp=Check[Import[NamePENFilenp,"TSV"],Print["Precomputed n -> p rate not found. We recompute the rates and store them. This can take very long"];$Failed,Import::nffil];

TabRatepn=Check[Import[NamePENFilepn,"TSV"],Print["Precomputed p -> n rate not found. We recompute the rates and store them. This can take very long"];$Failed,Import::nffil];

Timing[If[TabRatenp===$Failed||TabRatepn===$Failed||$RecomputeWeakRates,
PreComputeWeakRates;
(*Export[NamePENFilenp,TabRatenp,"TSV"];
Export[NamePENFilepn,TabRatepn,"TSV"];*),
\[Lambda]nTOpIPre=MyInterpolationRate[ToExpression[TabRatenp]]@@@T\[Nu]overTTable;
\[Lambda]pTOnIPre=MyInterpolationRate[ToExpression[TabRatepn]]@@@T\[Nu]overTTable;
\[Lambda]nTOpI=MyInterpolationRate[Table[{ListT[[i]], \[Lambda]nTOpIPre[[i]]},{i,1,Length[ListT]}]];
\[Lambda]pTOnI=MyInterpolationRate[Table[{ListT[[i]], \[Lambda]pTOnIPre[[i]]},{i,1,Length[ListT]}]];
];]


(* ::Input::Initialization:: *)
LnTOp[Tv_]:=1/\[Tau]neutron*\[Lambda]nTOpI[Tv];
LpTOn[Tv_]:=1/\[Tau]neutron*\[Lambda]pTOnI[Tv];
LbarnTOp[Tv_]:=LpTOn[Tv];


(* ::Input::Initialization:: *)
1/LnTOp[Tf]


(* ::Input::Initialization:: *)
(*

Off[NIntegrate::slwcon];
TabdlambdanTOp=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]nTOpThermal[T]+\[Lambda]nTOpThermalTruePhoton[T]+\[Lambda]nTOpThermalDiffBremsstrahlung[T]))/(\[Lambda]BORN*\[Lambda]nTOpBORN[T])},{T,ListTRange[1 10^9,10^11]}];
Print[TabdlambdanTOp];

TabdlambdapTOn=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]pTOnThermal[T]+\[Lambda]pTOnThermalTruePhoton[T]+\[Lambda]pTOnThermalDiffBremsstrahlung[T]))/(\[Lambda]BORN*\[Lambda]pTOnBORN[T])},{T,ListTRange[1 10^9,10^11]}];

Export["Interpolations/TabdlambdanTOp.dat",TabdlambdanTOp,"TSV"];
Export["Interpolations/TabdlambdapTOn.dat",TabdlambdapTOn,"TSV"];

TabdlambdanTOpBrown=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]nTOpThermal[T]+\[Lambda]nTOpThermalTruePhoton[T]))/(\[Lambda]BORN*\[Lambda]nTOpBORN[T])},{T,ListTRange[1 10^9,10^11]}];
TabdlambdanTOpBrown5Bodies=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]nTOpThermal[T]+\[Lambda]nTOpThermalTruePhoton[T]+\[Lambda]nTOp5bodies[T]))/(\[Lambda]BORN*\[Lambda]nTOpBORN[T])},{T,ListTRange[1 10^9,10^11]}];
TabdlambdapTOnBrown=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]pTOnThermal[T]+\[Lambda]pTOnThermalTruePhoton[T]))/(\[Lambda]BORN*\[Lambda]pTOnBORN[T])},{T,ListTRange[1 10^9,10^11]}];

Export["Interpolations/TabdlambdanTOpBrown.dat",TabdlambdanTOpBrown,"TSV"];
Export["Interpolations/TabdlambdanTOpBrown5Bodies.dat",TabdlambdanTOpBrown5Bodies,"TSV"];
Export["Interpolations/TabdlambdapTOnBrown.dat",TabdlambdapTOnBrown,"TSV"];

TabdlambdanTOpBrehm=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]nTOpThermalDiffBremsstrahlung[T]))/(\[Lambda]BORN*\[Lambda]nTOpBORN[T])},{T,ListTRange[1 10^9,10^11]}];
TabdlambdapTOnBrehm=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]pTOnThermalDiffBremsstrahlung[T]))/(\[Lambda]BORN*\[Lambda]pTOnBORN[T])},{T,ListTRange[1 10^9,10^11]}];
On[NIntegrate::slwcon];


Export["Interpolations/TabdlambdanTOpBrehm.dat",TabdlambdanTOpBrehm,"TSV"];
Export["Interpolations/TabdlambdapTOnBrehm.dat",TabdlambdapTOnBrehm,"TSV"];*)


(* ::Input::Initialization:: *)
NamesWithWeightsAll={{"n",{1,0}},{"p",{0,1}},{"d",{1,1}},{"t",{2,1}},
{"He3",{1,2}},{"a",{2,2}},{"He5",{3,2}},{"He6",{4,2}},
{"Li6",{3,3}},{"Li7",{4,3}},{"Li8",{5,3}},{"Li9",{6,3}},
{"Be7",{3,4}},{"Be8",{4,4}},{"Be9",{5,4}},{"Be10",{6,4}},{"Be11",{7,4}},{"Be12",{8,4}},
{"B8",{3,5}},{"B9",{4,5}},{"B10",{5,5}},{"B11",{6,5}},{"B12",{7,5}},{"B13",{8,5}},{"B14",{9,5}},{"B15",{10,5}},
{"C9",{3,6}},{"C10",{4,6}},{"C11",{5,6}},{"C12",{6,6}},{"C13",{7,6}},{"C14",{8,6}},{"C15",{9,6}},{"C16",{10,6}},
{"N12",{5,7}},{"N13",{6,7}},{"N14",{7,7}},{"N15",{8,7}},{"N16",{9,7}},{"N17",{10,7}},
{"O13",{5,8}},{"O14",{6,8}},{"O15",{7,8}},{"O16",{8,8}},{"O17",{9,8}},{"O18",{10,8}},{"O19",{11,8}},{"O20",{12,8}},
{"F17",{8,9}},{"F18",{9,9}},{"F19",{10,9}},{"F20",{11,9}},
{"Ne18",{8,10}},{"Ne19",{9,10}},{"Ne20",{10,10}},{"Ne21",{11,10}},{"Ne22",{12,10}},{"Ne23",{13,10}},
{"Na20",{9,11}},{"Na21",{10,11}},{"Na22",{11,11}},{"Na23",{12,11}}};


(* ::Input::Initialization:: *)
ShortNamesAll=NamesWithWeightsAll[[All,1]];


(* ::Input::Initialization:: *)
ListNPPairs=NamesWithWeightsAll[[All,2]];


(* ::Input::Initialization:: *)
ExistName[name_]:=MemberQ[ShortNamesAll,name];
ExistPair[pair_List]:=MemberQ[ListNPPairs,pair];


NamesMassNumberAll[A_]:=Select[NamesWithWeightsAll,((Plus@@(#[[2]]))==A)&][[All,1]]


(* ::Input::Initialization:: *)
KeySpecies=Association@(Rule@@@NamesWithWeightsAll)


(* ::Input::Initialization:: *)
KeyNucleons=Association@(Rule@@@(Reverse/@NamesWithWeightsAll))


(* ::Input::Initialization:: *)
Ni["Bm"]:=1;
Ni["Bp"]:=-1;
Ni["g"]:=0;

Zi["Bm"]:=-1;
Zi["Bp"]:=1;
Zi["g"]:=0;

Ai["Bm"]:=0;
Ai["Bp"]:=0;
Ai["g"]:=0;


(* ::Input::Initialization:: *)
Ni[key_]:=KeySpecies[key][[1]]
Zi[key_]:=KeySpecies[key][[2]]
Ai[key_]:=Zi[key]+Ni[key]


(* ::Input::Initialization:: *)
SpinFromCharList[charlist_List]:=StringReplace[StringJoin@@charlist,{"("->"",")"->"",","->"","+"->"","-"->""," "->"","#"->""}]
MassFromCharList[charlist_List]:=StringReplace[StringJoin@@charlist,{" "->"","#"->""}]


(* ::Input::Initialization:: *)
StringListParticles=#[[1]]&/@Import[(*"nubtab03.asc"*)"nubase2016.asc"];
NubTabChar=Select[Characters/@StringListParticles,Length[#]>=93&];


(* ::Input::Initialization:: *)
Alist=ToExpression/@StringJoin/@(Take[#,{1,3}]&/@NubTabChar);
Zlist=#/10&/@ToExpression/@StringJoin/@(Take[#,{5,8}]&/@NubTabChar);
MassExcessesString=MassFromCharList/@(Take[#,{20,29}]&/@NubTabChar);
Spins=SpinFromCharList/@(Take[#,{80,93}]&/@NubTabChar);
Nlist=Alist-Zlist;


(* ::Input::Initialization:: *)
MyGrid[ListNPBindingSpinName=Flatten[{KeyNucleons[{#[[1]],#[[2]]}],#}]&/@Select[Transpose[{Nlist,Zlist,MassExcessesString,Spins}],ExistPair[{#[[1]],#[[2]]}]&]]


(* ::Input::Initialization:: *)
ExcessMassKeys=Association[{#[[1]]->ToExpression[#[[4]]]}&/@ListNPBindingSpinName]


(* ::Input::Initialization:: *)
SpinKeys=Association[{#[[1]]->ToExpression[#[[5]]]}&/@ListNPBindingSpinName]


(* ::Input::Initialization:: *)
Eneutron:=ExcessMassKeys["n"];
Eproton:=ExcessMassKeys["p"];


(* ::Input::Initialization:: *)
BindingEnergy[name_]:=Module[{Pair,A,Z,N},
Pair=KeySpecies[name];
Z=Pair[[2]];
N=Pair[[1]];
A=Z+N;
N Eneutron +Z Eproton-ExcessMassKeys[name]]

Mass[name_]:=Module[{Pair,A,Z,N},
Pair=KeySpecies[name];
Z=Pair[[2]];
N=Pair[[1]];
A=Z+N;
A ma+keV ExcessMassKeys[name]-Z me]


(* ::Input::Initialization:: *)
BindingEnergy["n"]
BindingEnergy["p"]
BindingEnergy["d"]
BindingEnergy["a"]


(* ::Input::Initialization:: *)
YNSE[name_,Yn_,Yp_,Tv_]:=Module[{Pair,N,A,Z,mN,A32Overmn},
mN=(mn+mp)/2;
Pair=KeySpecies[name];
Z=Pair[[2]];
N=Pair[[1]];
A=Z+N;
A32Overmn=(Mass[name]/(mn^(A-Z)*mp^Z))^(3/2);
(2*SpinKeys[name]+1)Zeta[3]^(A-1) \[Pi]^((1-A)/2) 2^((3A-5)/2) A32Overmn (kB Tv)^(3(A-1)/2) (\[Eta]factorT[Tv])^(A-1) Yp^Z Yn^(A-Z) Exp[(BindingEnergy[name]*keV)/(kB Tv)]
]


(* ::Input::Initialization:: *)
Qreaction[ListIn_,ListOut_]:=Module[{Ni=Length@ListIn,Nf=Length@ListOut,factorin,factorout,Units},
factorin=Plus@@((BindingEnergy[#])&/@ListIn);
factorout=Plus@@((BindingEnergy[#])&/@ListOut);
Units=keV;
-Units(factorin-factorout)
];


(* ::Input::Initialization:: *)
PowerT9[ListIn_,ListOut_]:=Module[{Ni=Length@ListIn,Nf=Length@ListOut},
3/2.*(Ni-Nf)
];


(* ::Input::Initialization:: *)
FactorInverseReaction[ListIn_,ListOut_]:=Module[{Ni=Length@ListIn,Nf=Length@ListOut,factorin,factorout,Units},
factorin=Times@@((((2 SpinKeys[#[[1]]]+1)(2Pi/Mass[#[[1]]]/(kB 10^9))^(-3/2))^(#[[2]])/(#[[2]]!))&/@(Tally@ListIn));
factorout=Times@@((((2 SpinKeys[#[[1]]]+1)(2Pi/Mass[#[[1]]]/(kB 10^9))^(-3/2))^(#[[2]])/(#[[2]]!))&/@(Tally@ListOut));
Units=((ma/clight^2)/(hbar clight)^3)^(Ni-Nf);
factorin/ factorout Units
];


(* ::Input::Initialization:: *)
GatherInfoReac[ListIn_,ListOut_]:={Qreaction[ListIn,ListOut]/MeV,FactorInverseReaction[ListIn,ListOut],PowerT9[ListIn,ListOut],-Qreaction[ListIn,ListOut]/kB/10^9};

RemoveNonNuclear[Species_List]:=Select[Species,#=!="g"&&#=!="Bm"&&#=!="Bp"&];
InfoReaction[{ListIn_,ListOut_}]:=GatherInfoReac[RemoveNonNuclear@ListIn,RemoveNonNuclear@ListOut];
InfoReaction[ListIn_,ListOut_]:=InfoReaction[{ListIn,ListOut}]


(* ::Input::Initialization:: *)
CheckReaction[{ListIn_,ListOut_}]:=Module[{Znet,Nnet,Anet},
Znet=-Plus@@(Zi/@ListIn)+Plus@@(Zi/@ListOut);
Nnet=-Plus@@(Ni/@ListIn)+Plus@@(Ni/@ListOut);
Anet=-Plus@@(Ai/@ListIn)+Plus@@(Ai/@ListOut);
(*Print[ListIn," ",ListOut," ",Znet,Nnet,Anet];*)
If[Znet=!=0||Nnet=!=0||Anet=!=0,
Print["ERROR! This reaction ",ListIn," -> ",ListOut," is not possible.\nThe net result for Z, N and A are ",Znet," ",Nnet," ",Anet];
Print["We abort the evaluation !"];
Quit[];
(*TODO Maybe a better handling of errors than juts a violent Quit[]... *)
];
]

CheckReaction[ListIn_,ListOut_]:=CheckReaction[{ListIn,ListOut}]


(* ::Input::Initialization:: *)
Clear[TableRandom,MyNormalRandom]
$NRandomPoints = 1000; (* We put something larger than the max number of reactions *)
TableRandom[seed_]:=TableRandom[seed]=(SeedRandom[seed];Table[RandomVariate[NormalDistribution[]],{i,1,$NRandomPoints}])


(* ::Input::Initialization:: *)
InitializeRandom[seed_]:=(IndexRandom[seed]=1);
RandomFromTable[seed_]:=With[{r=TableRandom[seed][[IndexRandom[seed]]]},IndexRandom[seed]=IndexRandom[seed]+1;r]
MyNormalRandom[seed_]:=RandomFromTable[seed]


(* ::Input::Initialization:: *)
$Seed:=0;
Initialize[$Seed];
NormalRealisation:=If[$RandomNuclearRates,MyNormalRandom[$Seed],0];


(* ::Input::Initialization:: *)
ReverseReaction[Name_,FrontFactor_,PoweronT9_,Qoverkb_]:=With[{Reversname=ToExpression["Hold@Lbar"<>Name],name=Evaluate[Symbol["L"<>Name]]},
If[FrontFactor>0,
MySet[Reversname,Function[{Tvr},With[{T9=Tvr/Giga},FrontFactor (T9)^PoweronT9*Exp[Qoverkb/T9]*name[Tvr]]]];,
MySet[Reversname,Function[{Tvr},0]];
]];



(* ::Input::Initialization:: *)
TreatData[Data_]:=Module[{reac,constants,ReferencePaper,dat,rest,list,resultat,reacreshaped,replacements},
resultat={};
list=Data;

While[Length@list>0,
reac=list[[1]];
ReferencePaper=StringDrop[list[[2,1]],2];
(*Print[ReferencePaper];*)
(*Print[reac];*)
constants=list[[3]];
rest=Drop[list,3];
dat={};
While[rest=!={}&&NumericQ[rest[[1,1]]],
dat=Append[dat,rest[[1]]];
rest=Rest@rest;
];
list=rest;
reacreshaped=Append[{Select[reac,(#=!="+"&&#=!="*-")&],constants,ReferencePaper},dat];
resultat=Append[resultat,reacreshaped];
];
replacements={"He4"->"a"};
resultat/.replacements
];


(* ::Input::Initialization:: *)
TruncateRateVariation[rate_]:=Min[$MaxVariationRate,rate]


(* ::Input::Initialization:: *)
TreatReactionLine[line_]:=Module[{rescalefactor,reac,constants,interpfunction,data,len,table,Tmin,rmin,wedgeposition,colonposition,InitialParticles,FinalParticles,BoolenFileData,Q,FrontFactor,PoweronT9,Qoverkb,Name,Lname,rv,ReferencePaper,InfoFromAudi2017},
reac=line[[1]];
(*Print["Treating reaction : ",reac];*)
constants=line[[2]];
ReferencePaper=line[[3]];
data=line[[4]];

len=Length@line;
wedgeposition=Position[reac,">"][[1,1]];
colonposition=Position[reac,";"][[1,1]];
InitialParticles=Take[reac,{1,wedgeposition-1}];
FinalParticles=Take[reac,{wedgeposition+1,colonposition-1}];

(* We quit if the reaction does not conserve formally Z or N, that is if it cannot exist *)
CheckReaction[InitialParticles,FinalParticles];


Name=StringJoin@@ToString/@InitialParticles<>"TO"<>StringJoin@@ToString/@FinalParticles;

Q=constants[[1]];
FrontFactor=constants[[2]];
PoweronT9=constants[[3]];
Qoverkb=constants[[4]];


(* We check the constants used in reverse rates *)
InfoFromAudi2017=InfoReaction[InitialParticles,FinalParticles];
(*Print[InitialParticles," ",FinalParticles," ",InfoFromAudi2017];*)

If[Abs[FrontFactor/InfoFromAudi2017[[2]]-1]>0.001,Print[Name," WARNING. We use \[Alpha]=",FrontFactor," but we should use ",InfoFromAudi2017[[2]]]
];

If[Abs[Qoverkb/InfoFromAudi2017[[4]]-1]>0.001,
Print[Name, " WARNING. We use Q/\!\(\*SubscriptBox[\(k\), \(B\)]\)=",Qoverkb," but we should use ",InfoFromAudi2017[[4]]]
];

If[PoweronT9=!=InfoFromAudi2017[[3]],
Print[Name, " WARNING. We use power on T9 =",PoweronT9," but we should use ",InfoFromAudi2017[[3]]]
];
(* ****************)


(* *** *)
(*For exploration of parameters we can redefine some front factors to recales reactions. For instance the DPG reaction*)
(* Added on request of Antony Lewis *)

rescalefactor=1;
(*Print[Name,FullForm[Name]];*)

If[Name==="dpTOHe3g",
rescalefactor=dpTOHe3gFactor;
If[rescalefactor=!=1,Print["dpTOHe3g reaction is rescaled by ",dpTOHe3gFactor," New front factor is ",rescalefactor];];];
(* *** *)



table=Map[{Giga #[[1]],#[[2]]Hz,#[[3]]}&,data];
Tmin=Last[table][[1]];
rmin=Last[table][[2]];
Lname=ToExpression["Hold@L"<>Name];
rv=NormalRealisation;
MySet[Lname,MyInterpolationRate[{#[[1]],Identity[rescalefactor #[[2]]*
If[$RandomNuclearRates,TruncateRateVariation[#[[3]]^rv],1]]}&/@table]];
(* We do not rescale the reverse because it is computed FROM the forward rate. So rescaling the forward rate by rescalefactor rescales them both *)
ReverseReaction[Name,FrontFactor,PoweronT9,Qoverkb];

{Name,InitialParticles,FinalParticles,rv,ReferencePaper}

];

SetAttributes[TreatReactionLine,SequenceHold]


(* ::Input::Initialization:: *)
ListTWagoner={0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009,0.01,0.011,0.012,0.013,0.014,0.015,0.016,0.018,0.02,0.025,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.12,0.13,0.14,0.15,0.16,0.18,0.2,0.25,0.3,0.35,0.4,0.45,0.5,0.6,0.7,0.8,0.9,1.,1.25,1.5,1.75,2.,2.5,3.,3.5,4.,5.,6.,7.,8.,9.,10.}*10^9;


(* ::Input::Initialization:: *)
$ListTWagoner = False;


(* ::Input::Initialization:: *)
TableInterpolationTemperature=If[$ListTWagoner,ListTWagoner,ListTRange[0.9 Tf,10^10]];


(* ::Input::Initialization:: *)
SimplifyReactionStringRules={"+"->" + ",">"->" > ",";"->" ; ","2n"->" n + n ","2p"->" p + p ","2g"->" g + g ","2a"->" a + a ","He4"->" a "};

ReshapheReactionString[string_String]:=Select[StringSplit[StringReplace[string,SimplifyReactionStringRules]," "],(#=!="+"&&#=!="*-"&&#=!="")&];

TreatReactionString[reac_String,source_String,f_]:=Module[{reacshaped,wedgeposition,colonposition,InitialParticles,FinalParticles,Name},
reacshaped=ReshapheReactionString[reac];
wedgeposition=Position[reacshaped,">"][[1,1]];
colonposition=Position[reacshaped,";"][[1,1]];
InitialParticles=Take[reacshaped,{1,wedgeposition-1}];
FinalParticles=Take[reacshaped,{wedgeposition+1,colonposition-1}];

(* We check tha the reaction is possible, that is it should conserve N and Z*)
(* If not the case, the code will violently quit after spitting out warning messages.*)
CheckReaction[InitialParticles,FinalParticles];

Name=StringJoin@@ToString/@InitialParticles<>"TO"<>StringJoin@@ToString/@FinalParticles;
{Name,InitialParticles,FinalParticles,NormalRealisation,source,f}
]


(* ::Input::Initialization:: *)



PostTreatT9[var_,funT9_]:=If[$InterpolateAnalytics,
MyInterpolationRate[Table[{i,var MyChop[funT9[i/10^9]]},{i,TableInterpolationTemperature}]],
(var MyChop[funT9[#/10^9]])&];

GenRateT9[var_,funT9_]:=PostTreatT9[var,funT9];


(* ::Input::Initialization:: *)
DefineAnalyticRates:=
Module[{f,Var,Name,\[Lambda]Reac,\[Lambda]barReac,treatedreac,source,reac,analyticforward,AddReaction,initialparticles,finalparticles,InfoFromAudi2017,FrontFactor,Qoverkb,PoweronT9,forward},

(* Most recent implementation with automatic computation of reverse rate *)
AddReaction[reac_String,source_String,f_,ForwardT9_,BoolBackward_]:=(
treatedreac=TreatReactionString[reac,source,f];
Name=treatedreac[[1]];

(* Building the backward ratio *)
initialparticles=treatedreac[[2]];
finalparticles=treatedreac[[3]];
InfoFromAudi2017=InfoReaction[initialparticles,finalparticles];
(*Print[InitialParticles," ",FinalParticles," ",InfoFromAudi2017];*)
FrontFactor=InfoFromAudi2017[[2]];
Qoverkb=InfoFromAudi2017[[4]];
PoweronT9=InfoFromAudi2017[[3]];
(* End of building backward ratio *)

\[Lambda]Reac=ToExpression["Hold@L"<>Name];
\[Lambda]barReac=ToExpression["Hold@Lbar"<>Name];
Sow[treatedreac];
Var=f^treatedreac[[4]];

MySet[\[Lambda]Reac,GenRateT9[Var,ForwardT9]];
(*MySet[\[Lambda]barReac,GenRateT9[Var,BackwardT9 ]];*)
If[BoolBackward,
MySet[\[Lambda]barReac,GenRateT9[Var,(FrontFactor*#^PoweronT9*Exp[Qoverkb/#]*ForwardT9[#])& ]];,
MySet[\[Lambda]barReac,GenRateT9[0,0& ]];(* No backward reaction *)
];

treatedreac);


Reap[

(* This is where all extra analytic reactions must be listed.*)
(* TODO. Explain syntax better, but it si now rather transparent *)
(* For each reactions added analytically we need to specify a String source which is the paper in which it is found *)
(* Then we give a string reac which is the reaction considered.*)
(* The factor of incertainty for Monte-Carlo is then given*)
(* The analytic function forward[T9_], which is a function of T9 (that is the temperature in GK)*)
(* With all these definitions we call AddReaction. The last argument is a boolean. If True it computes also the reverse rate from detailed balance arguments, and if False it does not do so. This is essentially for pure decay reactions that there is no need to compute the reverse rates.*)

(**=======================================================================
*4He,3He,D,7Li (Extra reactions)
	   =======================================================================*)
source="Nag06";
reac=" d + n  > t + g ; dng";
	   f=1.40;
forward[T9_]:=With[{T923=T9^(2/3)},(214. T9^0.075+7.42T9+T923)];
AddReaction[reac,source,f,forward,True];
(* End of first reaction added analytically *)


source="Nag06";
reac="t+t>a+n+n;ttn";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)},(1/T923 1.67*^9 E^(-4.872/T913) (1. -0.272 T9+0.086 T913-0.455 T923+0.148 T943+0.225 T953))];
AddReaction[reac,source,f,forward,True];


source = "Wag69";
reac="He3 +n > He4 + g ; hng";
f=3.;
forward[T9_]:=6.62*(1+905*T9);
AddReaction[reac,source,f,forward,True];


source = "CF88";
reac="He3 + t > He4 + d ; htd";
f=3.;
forward[T9_]:=With[{T9A=T9/(1.+0.128*T9),T932=T9^(3/2)},With[{T9A13=T9A^(1./3.),T9A56=T9A^(5./6.)},5.46*^9*T9A56/T932*Exp[-7.733/T9A13] 
]];
AddReaction[reac,source,f,forward,True];



source = "CF88";
reac="He3 + t > He4 + n + p ; htp";
f=3.;
forward[T9_]:=With[{T9A=T9/(1.+0.115*T9),T932=T9^(3/2)},With[{T9A13=T9A^(1./3.),T9A56=T9A^(5./6.)},
7.71*^9*T9A56/T932*Exp[-7.733/T9A13]
]];
AddReaction[reac,source,f,forward,True];


source = "NACRE";
reac="a + a + n > Be9 + g ; aang";
f=1.25;
forward[T9_]:=With[{T932=T9^(3/2),T923=T9^(2/3),T913=T9^(1/3)},
With[{he4abe8= 2.43*^9*(1.+74.5*T9)/T923*Exp[-13.49/T913-(T9/0.15)^2]+6.09*^5/T932*Exp[-1.054/T9]},
If[T9<0.03,
(he4abe8)* 6.69*^-12*(1.-192*T9+2.48*^4*T9^2-1.50*^6*T9^3+4.13*^7*T9^4-3.90*^8*T9^5),
 (he4abe8)* 2.42*^-12*(1.-1.52*Log10[T9]+0.448*(Log10[T9])^2+0.435*(Log10[T9])^3)]]];
AddReaction[reac,source,f,forward,True];


source="CF88&MF89";
reac="Li7 + t > a + a + n + n; li7ta";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},8.81*^+11/T923*Exp[-11.333/T913]];
AddReaction[reac,source,f,forward,True];
(* Problem T93 not divided in Coc's code. TODO Make sure to correct it.*)


source="CF88&MF89";
reac="Li7 + He3 > a + a + n + p; li7haa";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},1.11*^+13/T923*Exp[-17.989/T913]];
AddReaction[reac,source,f,forward,True];
(* Idem problem T93 not divided in Coc *)


(* TODO Check because the 74 at the end is strange *)
source="Bal95";
reac=" Li8 + d > Li9 + p ; li8dp";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},9.63*^6/T923*Exp[-10.324/T913]*(1.+0.404*T913)*74.];
AddReaction[reac,source,f,forward,True];


source="Has09c";
reac=" Li8 + d > Li7 + t ; li8dt";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},(3.02*^8/T9^0.624*Exp[-3.51/T9]+5.82*^11/T923*Exp[-19.72/T913]*(1.0+0.280*T913))];
AddReaction[reac,source,f,forward,True];


source="CF88";
reac="Be7 + d > a + a + p ; be7dp";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},1.07*^+12/T923*Exp[-12.428/T913]];
AddReaction[reac,source,f,forward,True];


source="CF88&MF89";
reac="Be7 + t > a + a + n + p ; be7t";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},2.91*^+12/T923*Exp[-13.729/T913]];
AddReaction[reac,source,f,forward,True];
(* Idem problem in Coc's Fortran code. *)


source="CF88&MF89";
reac="Be7 + He3 > 2a + p + p  ; be7h";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},6.11*^+13/T923*Exp[-21.793/T913]];
AddReaction[reac,source,f,forward,True];
(* Idem problem in COC since here it is a division by T93 to get the revsre reaction *)


source="Wie89";
reac="C9 + a > N12 + p ; c9an";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T932=T9^(3/2),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)},(1.668*^+15/T923*Exp[-31.272/T913-(T9/.307)^2]* (1.+1.33*^-2*T913-6.42*T923-.599*T9+14.4*T943+3.42*T953)+56.8/T932*Exp[-5.292/T9]+1.7*^+5/T932*Exp[-14.08/T9]+6.52*^7/T932*Exp[-23.09/T9])];
AddReaction[reac,source,f,forward,True];


 (* *=======================================================================
*6Li (Extra reactions)
      *=======================================================================*)

source="CF88";
f=3.;
(*(* TODO  Change this because it is presented as being endothermic. That would be better to do the opposite? *)
reac="t+a>Li6+n;tan";
forward[T9_]:=With[{T9A=T9/(1.+49.18*T9)},With[{ T9A32=T9A^(3./2.),T932=T9^(3/2)},
(1.80*^8*Exp[-55.494/T9]*(1.-.261*T9A32/T932)+2.72*^9/T932*Exp[-57.884/T9])
]];*)


(* Here is the same reaction but presented backward, such that it is exothermic in the forward direction *)
reac="Li6+n>t+a;tan";
forward[T9_]:=With[{T9A=T9/(1.+49.18*T9)},With[{ T9A32=T9A^(3./2.),T932=T9^(3/2)},
(1.80*^+8*(1.-.261*T9A32/T932)*.935+2.72*^9/T932*Exp[(55.494-57.884)/T9]*.935)
]];
AddReaction[reac,source,f,forward,True];


source="FK90";
reac="He3 + t > Li6 + g ; htg";
f=3.;forward[T9_]:=With[{T92=T9^2,T923=T9^(2/3),T932=T9^(3/2),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)}, 2.21*^5/T923*Exp[-7.720/T913]*(1.+2.68*T923+0.868*T9+0.192*T943+0.174*T953+0.044*T92)];
AddReaction[reac,source,f,forward,True];


 source="CF88";
reac="a + n + p > Li6 + g ; anpg";
f=3.;
forward[T9_]:=If[T9>1, 4.62*^-6/T9^2*(1.+0.075*T9)*Exp[-19.353/T9],0];
AddReaction[reac,source,f,forward,True];


 source="MF89";
reac="Li6 + n > Li7 + g ; li6ng";
f=3.;
forward[T9_]:= 5.10*^3;
AddReaction[reac,source,f,forward,True];

 source="MF89";
reac="Li6 + d > Li7 + p ; li6dp";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)}, 1.48*^12/T923*Exp[-10.135/T913]];
AddReaction[reac,source,f,forward,True];

 source="MF89";
reac="Li6 + d > Be7 + n ; li6dn";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)}, 1.48*^12/T923*Exp[-10.135/T913]];
AddReaction[reac,source,f,forward,True];


(**=======================================================================
*Berylium& Boron (Main reactions)
       *=======================================================================*)
source="CF88";
reac="Li6 + a > B10 + g ; li6ag";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T932=T9^(3/2),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)}, (4.06*^06/T923*Exp[-18.79/T913-(T9/1.326)^2]*(1.+0.022*T913+1.54*T923+0.239*T9+2.2*T943+0.869*T953)
+1.91*^3/T932*Exp[-3.484/T9]+1.01*^4/T9*Exp[-7.269/T9])];
AddReaction[reac,source,f,forward,True];


source="NACRE";
reac=" Li7 + a > B10 + n ; li7an / b10na";
f=1.08;
forward[T9_]:=1.325*1.66*^7*(1.+1.064*T9)*1/1.3242*Exp[-32.3755/T9];
AddReaction[reac,source,f,forward,True];

(* C MF89 remplace Wiescher et al.ApJ 464 (1989) 464.C Voir Blackmon et al.PRC 54 (1996) 383& Heil et al.ApJ 507 (1998) 997.*)
            (*%MF89Hei98   *)
source="MF89&Hei98";
            reac="Li7+n>Li8+g;li7ng";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)},(6.015*^3+ 1.141*^4/T932*Exp[-2.576/T9])];
AddReaction[reac,source,f,forward,True];


(*Replace by exothermic reaction ?*)
source="MF89";
reac="Li7 + d > Li8 + p ; li7dp ! Q<0 !";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)}, 8.31*^8/T932*Exp[-6.998/T9]];
AddReaction[reac,source,f,forward,True];


source="Rau94";
reac="Li8 + n > Li9 + g ; li8ng";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)},(3.260*^3+ 6.328*^4/T932*Exp[-2.866/T9])];
AddReaction[reac,source,f,forward,True];


source="Men12";
reac="Li8 + p > a + a + n ; li8pn";
forward[T9_]:=With[{T932=T9^(3/2),T913=T9^(1/3),T923=T9^(2/3),T92=T9^2,T93=T9^3,T94=T9^4,T95=T9^5},
If[T9<5,(
5.36*^8/T932*Exp[-4.41/T9]+1.99*^8/T932*Exp[-7.08/T9]+5.85*^10/T923*Exp[-8.50/T913]* (1.-1.70*T9+0.849*T92-0.175*T93+1.62*^-2*T94-5.60*^-4*T95)),
7.777*^7]];
AddReaction[reac,source,f,forward,True];


source="Bal95";
reac="Li8 + d > Be9 + n ; li8dn";
f=3.;forward[T9_]:=With[{T913=T9^(1/3),T923=T9^(2/3)},9.63*^6/T923*Exp[-10.324/T913]*(1.+0.404*T913)*188.];
AddReaction[reac,source,f,forward,True];

(**=======================================================================
*Berylium& Boron (Extra reactions)
      *======================================================================= *)
source="Rau94";
reac="Be9 + n > Be10 + g ; be9ng";
f=3.;
forward[T9_]:=With[{T913=T9^(1/3),T923=T9^(2/3),T932=T9^(3/2)},(1.01*^3+ 1.01*^4/T932*Exp[-6.487/T9]+5.41*^4/T932*Exp[-8.471/T9])];
AddReaction[reac,source,f,forward,True];

source="NACRE";
reac="Be9 + p > a + a + p + n ; be9pn";
f=1.05;
forward[T9_]:= 5.06*^7*Exp[-21.479/T9]*(1.+1.26*T9-0.0302*T9^2);
AddReaction[reac,source,f,forward,True];
(* I find that it is division by T93 by Coc used multiplication by T93 ! Carefull !!!*)

source="NACRE";
reac="B11 + p > C11 + n ; b11pn ! Q < 0 !";
f=1.1;
forward[T9_]:= 1.36*^8*Exp[-32.085/T9]*(1.+0.963*T9-0.285*T9^2+3.36*^-2*T9^3-1.37*^-3*T9^4);
AddReaction[reac,source,f,forward,True];


source="Rau94";
reac=" Be10 + n > Be11 + g ; be10ng";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)},(5.96*^2+ 6.67*^5/T932*Exp[-14.85/T9]) ];
AddReaction[reac,source,f,forward,True];


source="Rau94";
reac="Be11 + n > Be12 + g ; be11ng";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)}, 3.56*^2 ];
AddReaction[reac,source,f,forward,True];


source="Des99Bea01";
reac="B8 + p > C9 + g ; b8pg";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2),T913=T9^(1/3),T92=T9^2},6.253*^5*Exp[-11.971/T913]*(1.-7.03*^-2*T9+6.25*^-3*T92)];
AddReaction[reac,source,f,forward,True];

(* =====================================================================\[Equal]
*Leaks to CNO
      !*=======================================================================*)

source="NACRE";
reac="a + a + a > C12 + 2g ; aaag";
f=1.15;
forward[T9_]:=With[{T932=T9^(3/2),T923=T9^(2/3),T913=T9^(1/3)},
With[{he4abe8=2.43*^9*(1.+74.5*T9)/T923*Exp[-13.49/T913-(T9/0.15)^2]+6.09*^5/T932*Exp[-1.054/T9],
be8agc12= 2.76*^7*(1.+5.47*T9+326*T9^2)/T923*Exp[-23.570/T913-(T9/0.4)^2]+130.7/T932*Exp[-3.338/T9]+2.51*^4/T932*Exp[-20.307/T9]},
If[T9<0.03, 
he4abe8*be8agc12*3.07*^-16*(1.-29.1*T9+1308*T9^2),
he4abe8*be8agc12*3.44*^-16*(1.+0.0158/T9^0.65)]]];
AddReaction[reac,source,f,forward,True];

source="Tang03";
reac="C11+p>N12+g;c11pg";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T932=T9^(3/2),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)},(1.670*^2*Exp[-4.166/T9]/T932+2.148*^5*Exp[-13.281/T913]/T923* (1.+4.639*T913-2.641*T923-1.543*T9+2.030*T943+4.657*T953))];
AddReaction[reac,source,f,forward,True];


source="CF88";
reac="B10 + a > N13 + n ; b10an";
f=3.;forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)}, 1.2*^13/T923*Exp[-27.989/T913-(T9/9.589)^2]  ];
AddReaction[reac,source,f,forward,True];

            source="Wan91";
reac="B11+a>C14+p;b11ap";
f=3.;forward[T9_]:=With[{T923=T9^(2/3),T932=T9^(3/2),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)},(8.403*^15*Exp[-31.914/T913-(T9/0.3432)^2]*(1.+0.022*T913+5.712*T923+0.642*T9+15.982*T943+4.062*T953)
+5.44*^-3/T932*Exp[-2.868/T9]+2.419*^2/T932*Exp[-5.147/T9]+4.899*^2/T932*Exp[-5.157/T9]+4.944*^6/T9^(3/5)*Exp[-11.26/T9])];
AddReaction[reac,source,f,forward,True];


source="Rau94";
reac="C11+n>C12+g;c11ng";
f=3.;forward[T9_]:=With[{T932=T9^(3/2)},(3.18*^4+ 3.30*^3/T932*Exp[-0.917/T9]+1.05*^6/T932*Exp[-5.57/T9])];
AddReaction[reac,source,f,forward,True];


(*=======================================================================*)
(*       Decay Rates                                            *)
(*=======================================================================*)
(* %Aud03  *)
(* All decay rates from %Aud03  *)

source="Aud03";
reac="He6>Li6+Bm;";
forward[T9_]:=Log[2]/8.0670*^-1 ;
AddReaction[reac,source,1,forward,False];(* The 1 is because we do not put uncertainty on decays, and the False because we do not put reverse reactions on decays *)

reac="Li8>2a+Bm;";
forward[T9_]:=Log[2]/8.4030*^-1 ;
AddReaction[reac,source,1,forward,False];

reac="Li9>Be9+Bm;";
forward[T9_]:=Log[2]/1.7830*^-1 * 0.492 ;
AddReaction[reac,source,1,forward,False];

reac="Li9>a+a+n+Bm;";
forward[T9_]:=Log[2]/1.7830*^-1 * 0.508 ;
AddReaction[reac,source,1,forward,False];

reac="Be11>B11+Bm;";
forward[T9_]:= Log[2]/(1.3810*^1) ;
AddReaction[reac,source,1,forward,False];

reac="Be12>B12+Bm;";
forward[T9_]:=Log[2]/(2.15*^-2) ;
AddReaction[reac,source,1,forward,False];

reac="B8>a+a+Bp;";
forward[T9_]:= Log[2]/(7.70*^-1) ;
AddReaction[reac,source,1,forward,False];

reac="B12>C12+Bm;";
forward[T9_]:= Log[2]/(2.02*^-2) ;
AddReaction[reac,source,1,forward,False];

reac="B13>C13+Bm;";
(* !04/11/2010 *)
forward[T9_]:=Log[2]/(1.733*^-2) ;
AddReaction[reac,source,1,forward,False];

reac="B14>C14+Bm;";
(* !04/11/2010 *)
forward[T9_]:=Log[2]/(1.25*^-2) ;
AddReaction[reac,source,1,forward,False];

 reac="B15>C15+Bm;";
(* !04/11/2010 *)
forward[T9_]:= Log[2]/(9.87*^-3) ;
AddReaction[reac,source,1,forward,False];

reac="C9>a+a+p+Bp;";
forward[T9_]:= Log[2]/(1.26*^-1) ;
AddReaction[reac,source,1,forward,False];

reac="C10>B10+Bp;";
forward[T9_]:=Log[2]/(19.29) ;
AddReaction[reac,source,1,forward,False];

reac="C11>B11+Bp;";
forward[T9_]:= Log[2]/1.2234*^3 ;
AddReaction[reac,source,1,forward,False];

	    reac="C15>N15+Bm;";
(*28/10/2010*)
forward[T9_]:=Log[2]/2.449 ;
AddReaction[reac,source,1,forward,False];

reac="C16>N16+Bm;";
(*14/01/2011*)
forward[T9_]:= Log[2]/7.4700*^-1 ;
AddReaction[reac,source,1,forward,False];

reac="N12>C12+Bp;";
forward[T9_]:= Log[2]/1.100*^-2 ;
AddReaction[reac,source,1,forward,False];

reac="N13>C13+Bp;";
(*14/01/2011*)
forward[T9_]:=Log[2]/5.979*^2 ;
AddReaction[reac,source,1,forward,False];

reac="N16>O16+Bm;";
(*14/01/2011*)
forward[T9_]:=Log[2]/7.13 ;
AddReaction[reac,source,1,forward,False];

reac="N17>O16+n+Bm;";
(*14/01/2011*)
forward[T9_]:= Log[2]/4.1730 ;
AddReaction[reac,source,1,forward,False];

reac="O13>N13+Bp;";
(*14/01/2011*)
forward[T9_]:= Log[2]/8.58*^-3 ;
AddReaction[reac,source,1,forward,False];

reac="O14>N14+Bp;";
(*14/01/2011*)
forward[T9_]:=Log[2]/70.598 ;
AddReaction[reac,source,1,forward,False];

reac="O15>N15+Bp;";
(*14/01/2011*)
forward[T9_]:=Log[2]/122.24;
AddReaction[reac,source,1,forward,False];

reac="O19>F19+Bm;";
(*14/01/2011*)
forward[T9_]:=Log[2]/26.464;
AddReaction[reac,source,1,forward,False];

            reac="O20>F20+Bm;";
(*14/01/2011*)
forward[T9_]:=Log[2]/13.51;
AddReaction[reac,source,1,forward,False];

reac="F17>O17+Bp;";
(*04/11/2010*)
forward[T9_]:=Log[2]/64.49;
AddReaction[reac,source,1,forward,False];

reac="F18>O18+Bp;";
(*04/11/2010*)
forward[T9_]:= Log[2]/6.5863*^3;
AddReaction[reac,source,1,forward,False];

reac="F20>Ne20+Bm;";
(*04/11/2010*)
forward[T9_]:= Log[2]/11.1630;
AddReaction[reac,source,1,forward,False];

reac="Ne18>F18+Bp;";
(*04/11/2010*)
forward[T9_]:=Log[2]/1.6720;
AddReaction[reac,source,1,forward,False];

reac="Ne19>F19+Bp;";
(*04/11/2010*)
forward[T9_]:=Log[2]/17.296;
AddReaction[reac,source,1,forward,False];

reac="Ne23>Na23+Bm;";
(*04/11/2010*)
forward[T9_]:=Log[2]/37.240;
AddReaction[reac,source,1,forward,False];

reac="Na20>Ne20+Bp;";
(*14/01/2011*)
forward[T9_]:=Log[2]/4.4790*^-1;
AddReaction[reac,source,1,forward,False];

reac="Na21>Ne21+Bp;";
(*04/11/2010*)
forward[T9_]:=Log[2]/22.49;
AddReaction[reac,source,1,forward,False];

(* *=======================================================================
  *New reactions following Thomas,Schramm et al.1993;1994
      *=======================================================================*)

source="Efr96";
reac="He4 + 2n  > He6 + g ;";
f=3.;
forward[T9_]:=If[T9<2,
(2.65*^-3*T9^2.555*Exp[0.181/Max[T9,.1]]),
(2.93*^-1*T9^(-3.51*^-1)*Exp[-5.24/T9])];
AddReaction[reac,source,f,forward,True];


source="Iga95";
reac="O16 + n  > O17 + g ;";
f=3.;
forward[T9_]:=(2.7*^1+ 1.38*^4*T9 );
AddReaction[reac,source,f,forward,True];


source="CF88";
reac="N14 + n  > C14 + p ;";
f=3.;
forward[T9_]:=With[{T912=T9^(1/2)},( 7.19*^5*(1.+.361*T912+.502*T9)+3.34*^8/T912*Exp[-4.983/T9])*.333];
AddReaction[reac,source,f,forward,True];


source="CF88";
reac="O14 + n  > N14 + p ;";
f=3.;
forward[T9_]:=With[{T912=T9^(1/2)},(6.74*^7*(1.+0.658*T912+0.379*T9)*2.99 )];
AddReaction[reac,source,f,forward,True];


source="Wie87";
reac="O14 + a  > Ne18 + g ;";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)},( 1.16*^-1/T932*Exp[-11.73/T9]+3.40*^1/T932*Exp[-22.61/79]+9.10*^-3*T9^5*Exp[-12.159])];
AddReaction[reac,source,f,forward,True];


source="NACRE";
reac="C11 + a  > N14 + p ;";
f=2.;
forward[T9_]:=With[{T913=T9^(1/3),T92=T9^2},(0.2719*3.01*^16*Exp[-31.884/T913]* Exp[-1.379*T9+.215*T92-2.13*^-2*T92*T9+8*^-4*T92*T92]*(1.+0.14*Exp[-.275/T9-.210*T9]) )];
AddReaction[reac,source,f,forward,True];


source="Bar97C";
reac="O14 + a  > F17 + p ;";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2),T923=T9^(2/3),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)},
With[{offset=1.330*^5/T932*Exp[-11.86/T9]+8.42*^-47*T932*Exp[-0.453/T9]+6.74*^4/T932*Exp[-13.60/T9]+1.21*^7/T932*Exp[-22.51/T9]+1.26*^8/T932*Exp[-26.00/T9]},
(offset+If[T9<1,
7.906*^15/T923*Exp[-40.33/T913]*(1.-1.884*^1*T913+2.446*^2*T923-7.735*^2*T9+9.485*^2*T943-3.961*^2*T953),0])]];
AddReaction[reac,source,f,forward,True];


source="Koe91";
reac=" O17 + n > C14 + a ;";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)},( 3.11*^4+ 9.18*^5/T932*Exp[-1.961/T9]+7.02*^7/T932*Exp[-2.759/T9])];
AddReaction[reac,source,f,forward,True];


source="NACRE";
(* Check this one because there seems to be a typo in the exponential. Or maybe this is correct but this is strange. *)
reac="F17 + n > N14 + a ;";
f=1.05;
forward[T9_]:=(1.38*^8*T9^0.053*Exp[-(55.0-54.943)/T9]* (1.+.039*Exp[-.012/T9+.217*T9])/1.478 );
AddReaction[reac,source,f,forward,True];


source="CF88";
reac="F18 + n > N15 + a ;";
f=3.;
forward[T9_]:=With[{T912=T9^(1/2)},( 3.14*^8*(1.-0.641*T912+0.108*T9)*2.)];
AddReaction[reac,source,f,forward,True];


source="Kaw91";
reac="C14 + d  > N15 + n ;";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3)},(4.27*^13/T923*Exp[-16.939])];
AddReaction[reac,source,f,forward,True];


source="CF88";
reac="p + p + n > d + p ;";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},(1.35*^7*Exp[-3.720/T913]*(1.+0.784*T913+0.346*T923+0.690*T9)/2.3590*^9)];
AddReaction[reac,source,f,forward,True];


source="Kaw91";
reac="C14 + n > C15 + g ;";
f=3.;
forward[T9_]:=(3240. *T9 );
AddReaction[reac,source,f,forward,True];


source="CF88";
reac=" O16 + p  > N13 + a ;";
f=3.;
forward[T9_]:=With[{T953=T9^(5/3),T932=T9^(3/2)},
With[{T9A=T9/(1.+7.76*^-2*T9+2.64*^-2*T953/(1.+7.76*^-2*T9)^(2./3.))},
With[{T9A13=T9A^(1./3.),T9A56=T9A^(5./6.)},
With[{SVRev=1.88*^18*T9A56/T932*Exp[-35.829/T9A13]*1.7232*^-1},
With[{SVDir=SVRev/0.172255*Exp[-60.5573/T9]},
SVDir]]]]];
AddReaction[reac,source,f,forward,True];



(* %TUNL&Cam08  !Camargo et al.Phys.Rev.C 78,034605 (2008) pour DC
      !Tilley (TUNL) Table 9.5 pour la res.a 87 keV (dominante)  *)
source="TUNL&Cam08";
reac="Li8 + p > Be9 + g ;";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3),T932=T9^(3/2)},
(3.516*^6/T923*Exp[-8.5155/T913]+2.669*^4/T932*Exp[-1.010/T9] )];
AddReaction[reac,source,f,forward,True];


source="Wan91";
reac="B11 + a  > N15 + g ;";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)},(643./T932*Exp[-5.1526/T9] )];
AddReaction[reac,source,f,forward,True];

][[2,1]]

(* The output is the list of reactions in standard format (Name,List initial,List final,f factor) which is then used by the differential equation constructor *)

];


(* ::Input::Initialization:: *)
ReactionPEN={"nTOp",{"n"},{"p"},0,"Companion Paper"};
(* Format is name, List of initial particles, List of final particles, f factor for uncertainty*)

TabulatedReactions:=
(Select[SafeImport[TabulatedReactionsFile],(NumericQ[#[[1]]]||"*-"==#[[1]]||StringMatchQ[#[[1]],"\\*%"~~__])&]);
ReshapedTabulatedReactions:=TreatData[TabulatedReactions];


(* ::Input::Initialization:: *)
$TabulatedAnalyticReactions=False;
TabulatedReactionsAnalyticFile="BBNRatesFromAnalytic.dat";


(* ::Input::Initialization:: *)
LoadRates:=Module[{len},
len=Length@ReshapedTabulatedReactions;
ListReactionsFile=TreatReactionLine/@(Take[ReshapedTabulatedReactions,Min[NumberNuclearReactions,len]]);
(* If the number is larger than the file, we also dig into the analytic expressions *)
If [NumberNuclearReactions>len,

If[$TabulatedAnalyticReactions,

TabulatedReactionsAnalytic=Select[SafeImport[TabulatedReactionsAnalyticFile],(NumericQ[#[[1]]]||"*-"==#[[1]]||StringMatchQ[#[[1]],"\\*%"~~__])&];
ExtraAnalyticReactions=TreatReactionLine/@TreatData[TabulatedReactionsAnalytic];,

ExtraAnalyticReactions=DefineAnalyticRates;];

ListReactions=Take[Join[{ReactionPEN},ListReactionsFile,ExtraAnalyticReactions],NumberNuclearReactions+1],
ListReactions=Join[{ReactionPEN},ListReactionsFile]]
];


(* ::Input::Initialization:: *)
LoadRates;


(* ::Input::Initialization:: *)
SpeciesUpToMaximumMass[A_Integer]:=SpeciesUpToMaximumMass[A]=Union@@Table[NamesMassNumberAll[i],{i,A}];
ReactionUpToMaximumMass[A_Integer][Reaction_List]:=And@@(MemberQ[SpeciesUpToMaximumMass[A],#]&/@Flatten@Reaction[[2;;3]]);
ListReactionsUpToMass[A_Integer,ListReactions_List]:=Select[ListReactions,ReactionUpToMaximumMass[A][#]&];
ListReactionsUpToMass[Infinity,ListReactions_List]:=ListReactions;
ListReactionsUpToChosenMass:=ListReactionsUpToMass[MaximumNuclearMass,ListReactions];


(* ::Input::Initialization:: *)
ReactionWithArrow[name_String]:=StringReplace[name,"TO"->" -> "]
NiceDisplayReaction[reaction_List]:=Join[{ReactionWithArrow[First[reaction]]},Rest[reaction]]


(* ::Input::Initialization:: *)
ListReactionsNames=ListReactionsUpToChosenMass[[All,1]];


(* ::Input::Initialization:: *)
ListNuclearReactionsNames=Select[ListReactionsNames,#=!="nTOp"&];


(* ::Input::Initialization:: *)
KeyNuclearReaction=Association[#->Position[ListNuclearReactionsNames,#][[1,1]]&/@ListNuclearReactionsNames];
KeyReaction=Association[#->Position[ListReactionsNames,#][[1,1]]&/@ListReactionsNames];


(* ::Input::Initialization:: *)
VariablesInEquations=Union@Flatten[Join[RemoveNonNuclear[#[[2]]],RemoveNonNuclear[#[[3]]]]&/@ListReactionsUpToChosenMass]


(* ::Input::Initialization:: *)
NumberVariable=Length@VariablesInEquations


(* ::Input::Initialization:: *)
NamesWithWeights=Select[NamesWithWeightsAll,MemberQ[VariablesInEquations,#[[1]]]&]


(* ::Input::Initialization:: *)
WeightsNuclear=(Plus@@(#[[2]]))&/@NamesWithWeights


(* ::Input::Initialization:: *)
NamesMassNumber[A_]:=Select[NamesWithWeights,((Plus@@(#[[2]]))==A)&][[All,1]]
NamesAtomicNumber[Z_]:=Select[NamesWithWeights,(#[[2,2]]==Z)&][[All,1]]


(* ::Input::Initialization:: *)
StackY[name_]:="Y"<>ToString[name];


(* ::Input::Initialization:: *)
YName[PostString_][n_,p_]:=ToExpression@StackY["n"<>ToString[n]<>"p"<>ToString[p]<>PostString];
ShortString[nameshort_,np_List]:=(Evaluate@ToExpression["Y"<>nameshort]:=YName[""]@@np;);


(* ::Input::Initialization:: *)
ShortString@@@NamesWithWeights;


(* ::Input::Initialization:: *)
ShortNames=NamesWithWeights[[All,1]]
KeyVal=Association[#->Position[ShortNames,#][[1,1]]&/@ShortNames]


(* ::Input::Initialization:: *)
VarList=ToExpression/@(StackY/@ShortNames)


(* ::Input::Initialization:: *)
SetTimeDependence[list_List,tv_]:=#[tv]&/@list;


(* ::Input::Initialization:: *)
FunList[tv_]=SetTimeDependence[VarList,tv]
FunPrimeList[tv_]=FunList'[tv]


(* ::Input::Initialization:: *)
KeyQ[key_]:=MemberQ[NamesWithWeightsAll[[All,1]],key];

YHT[key_?KeyQ][t_]:=Y["HT"][key][t];
YMT[key_?KeyQ][t_]:=Y["MT"][key][t];
YLT[key_?KeyQ][t_]:=Y["LT"][key][t];


(* ::Input::Initialization:: *)
YPeriodTime[period_String][tv_]:=Y[period][#][tv]&/@ShortNames;


NumericalValueOrThermalEquilibriumValue[period_,ListThermal_,name_,Tv_,tv_]:=
Module[{Yv=Y[period][name][tv],Yn=Y[period]["n"][tv],Yp=Y[period]["p"][tv]},
If[ MemberQ[ListThermal,name],YNSE[name,Yn,Yp,Tv],Yv]];


(* ::Input::Initialization:: *)
YPeriodTimeOrStateEquilibrium[period_String,ListThermal_List][Tv_,tv_]:=NumericalValueOrThermalEquilibriumValue[period,ListThermal,#,Tv,tv]&/@ShortNames;


(* ::Input::Initialization:: *)
CNONuclei=KeyNucleons/@Join[Table[{i,6},{i,6,10}],Table[{i,7},{i,5,10}],Table[{i,8},{i,5,12}]]


(* ::Input::Initialization:: *)
YLT["CNO"][t_]:=Plus@@((YLT[#][t]&)/@CNONuclei)


(* ::Input::Initialization:: *)
FillReactionMatrix[listreac_List]:=Module[{Tab,i,j,nvar,TreatReaction,FactorInitialElements},
nvar=Length@VarList;
Tab=Table[0,{ii,1,nvar}];
FactorInitialElements[el_List]:=Times@@((A\[Rho]B/DensityUnit Y[KeyVal[#[[1]]]])^#[[2]]/(#[[2]]!)&/@el);
TreatReaction[reaction_List]:=Module[{
InitialParticles=Tally[RemoveNonNuclear@reaction[[2]]],
FinalParticles=Tally[RemoveNonNuclear@reaction[[3]]],
ReactionForward,ReactionBackward,FactorInitialForward,FactorInitialBackward},

ReactionForward=L[KeyReaction[reaction[[1]]]];
ReactionBackward=Lbar[KeyReaction[reaction[[1]]]];
FactorInitialForward=FactorInitialElements@InitialParticles;(* This computes the product Subscript[Y, i]^ni/ni! for initial particles*)
FactorInitialBackward=FactorInitialElements@FinalParticles;

(Tab[[KeyVal[#[[1]]]]]=Tab[[KeyVal[#[[1]]]]]-ReactionForward FactorInitialForward #[[2]]/A\[Rho]B*DensityUnit)&/@InitialParticles;
(Tab[[KeyVal[#[[1]]]]]=Tab[[KeyVal[#[[1]]]]]+ReactionForward FactorInitialForward #[[2]]/A\[Rho]B*DensityUnit)&/@FinalParticles;
(Tab[[KeyVal[#[[1]]]]]=Tab[[KeyVal[#[[1]]]]]-ReactionBackward FactorInitialBackward #[[2]]/A\[Rho]B*DensityUnit)&/@FinalParticles;
(Tab[[KeyVal[#[[1]]]]]=Tab[[KeyVal[#[[1]]]]]+ReactionBackward FactorInitialBackward #[[2]]/A\[Rho]B*DensityUnit)&/@InitialParticles;
];
TreatReaction/@listreac;
Tab
]


(* ::Input::Initialization:: *)
FormalReactions=FillReactionMatrix@ListReactionsUpToChosenMass;


(* ::Input::Initialization:: *)
NReactionsSmallNetwork=Min[NumberNuclearReactions+1,18];
FormalReactions18=FillReactionMatrix@Take[ListReactionsUpToChosenMass,Min[NReactionsSmallNetwork,Length@ListReactionsUpToChosenMass]];


(* ::Input::Initialization:: *)
WeightsNuclear.FormalReactions//Simplify


(* ::Input::Initialization:: *)
FormalReactionsOnlyPEN=FillReactionMatrix[{ReactionPEN}];


(* ::Input::Initialization:: *)
Yi:=Y[KeyVal[#]]&/@ShortNames;

RulesY[tv_]:=Thread[Rule[Yi,FunList[tv]]];


(* ::Input::Initialization:: *)
Li=L[KeyReaction[[#]]]&/@ListReactionsNames;
Lbari=Lbar[KeyReaction[[#]]]&/@ListReactionsNames;


(* ::Input::Initialization:: *)

Rules\[Lambda]RHS[Tv_]:=Symbol["L"<>#][Tv]&/@ListReactionsNames;
Rules\[Lambda]RHS[n_,Tv_]:=Symbol["L"<>#][Tv]&/@Take[ListReactionsNames,n];

Rules\[Lambda]barRHS[Tv_]:=Symbol["Lbar"<>#][Tv]&/@ListReactionsNames;
Rules\[Lambda]barRHS[n_,Tv_]:=Symbol["Lbar"<>#][Tv]&/@Take[ListReactionsNames,n];

Rules\[Lambda][Tv_]:=Thread[Rule[Li,Rules\[Lambda]RHS[Tv]]];
Rules\[Lambda]bar[Tv_]:=Thread[Rule[Lbari,Rules\[Lambda]barRHS[Tv]]];


(* ::Input::Initialization:: *)
DYOnlyPEN[Temp_,\[Rho]B_,time_]:=(FormalReactionsOnlyPEN)/.Dispatch@Rules\[Lambda][Temp]/.Dispatch@Rules\[Lambda]bar[Temp]/.Dispatch@RulesY[time]/.A\[Rho]B->\[Rho]B;

DY18[Temp_,\[Rho]B_,time_]:=(FormalReactions18)/.Dispatch@Rules\[Lambda][Temp]/.Dispatch@Rules\[Lambda]bar[Temp]/.Dispatch@RulesY[time]/.A\[Rho]B->\[Rho]B;

DY[Temp_,\[Rho]B_,time_]:=(FormalReactions)/.Dispatch@Rules\[Lambda][Temp]/.Dispatch@Rules\[Lambda]bar[Temp]/.Dispatch@RulesY[time]/.A\[Rho]B->\[Rho]B;



(* ::Input::Initialization:: *)
CompileFromFormal[FormalReactions_List]:=ReleaseHold[Hold[Compile[{{A\[Rho]B,_Real},{L,_Real,1},{Lbar,_Real,1},{Y,_Real,1}},inside,CompilationTarget->"C","RuntimeOptions"->"Speed",CompilationOptions->{"InlineExternalDefinitions"->True}]]//.{inside->FormalReactions,Y[m_]:>Y[[m]],L[m_]:>L[[m]],Lbar[m_]:>Lbar[[m]]}]


(* ::Input::Initialization:: *)
Timing[If[$CompileNDSolve,
DYC=CompileFromFormal[FormalReactions];
DY18C=CompileFromFormal[FormalReactions18];
DYCN[A\[Rho]B_?NumericQ,L_,Lbar_,Y_]:=DYC[A\[Rho]B,L,Lbar,Y];
DY18CN[A\[Rho]B_?NumericQ,L_,Lbar_,Y_]:=DY18C[A\[Rho]B,L,Lbar,Y];
];]


(* ::Input::Initialization:: *)
\[Rho]\[Nu][T_]:=If[$IncompleteNeutrinoDecoupling,\[Rho]\[Nu]IncompleteDecoupling[a[T]],\[Rho]\[Nu]Decoupling[T]];



(* ::Input::Initialization:: *)
\[Rho]tot1[T_]:=(aBB (kB T)^4 (1+D\[Rho]T[T])+\[Rho]\[Nu][T]
+nbaryons0 (mbaryon0*(1+h2\[CapitalOmega]c0/h2\[CapitalOmega]b0)+3/2 (kB T))/(clight)^2/(a[T])^3);

\[Rho]tot2[T_]:=(aBB (kB T)^4 (1+7/8 Nneu (T\[Nu]overT[T])^4+D\[Rho]T[T])
+nbaryons0 (mbaryon0*(1+h2\[CapitalOmega]c0/h2\[CapitalOmega]b0)+3/2 (kB T))/(clight)^2/(a[T])^3);


(* ::Input::Initialization:: *)
\[Rho]tot[T_]:=\[Rho]tot1[T];


(* ::Input::Initialization:: *)
H[a_]:=((8\[Pi] GN)/3 \[Rho]tot[Tofa[a]])^(1/2);


(* ::Input::Initialization:: *)
Computetofa:=(tofa=NDSolveValue[{tv'[av]==1/(av H[av]),tv[a[Ti]]==1/(2H[a[Ti]])},tv,{av,a[Ti],a[Tf]},PrecisionGoal->8,AccuracyGoal->10];)


(* ::Input::Initialization:: *)
Computeaoft:=(aoft=NDSolveValue[{av'[tv]==1/tofa'[av[tv]],av[tofa@a[Ti]]==a[Ti]},av,{tv,tofa@a[Ti],tofa@a[Tf]},PrecisionGoal->75,AccuracyGoal->20];)


(* ::Input::Initialization:: *)
Toft[tv_]:=Tofa[aoft[tv]];


(* ::Input::Initialization:: *)
Yni[Tv_]:=1/(1+(1-3/2 Q/mn )Exp[Q/(kB Tv)]);
Ypi[Tv_]:=1-Yni[Tv];


(* ::Input::Initialization:: *)
Yn2i[Tv_]:=LpTOn[Tv]/(LpTOn[Tv]+LnTOp[Tv]);
Yp2i[Tv_]:=1-Yn2i[Tv];


(* ::Input::Initialization:: *)
CIList[Tv_]:=Table[Which[i==1,Yni[Tv],i==2,Ypi[Tv],i>=3,0],{i,1,NumberVariable}]


(* ::Input::Initialization:: *)
DefineEquations:=(

(*We build the differential system for the High temperatures *)
(* So we associate the r.h.s which is constructed thanks to DYOnlyPEN, with the l.h.s made of abundances derivatives *)
SystemEquationsHT[tv_]=Thread[Equal[FunPrimeList[tv],(DYOnlyPEN[Tv,\[Rho]Bv,tv](*/.Dispatch@ReactionProbabilities*))]]/.{Tv->Toft@tv,\[Rho]Bv->\[Rho]BForBBN@a@Toft@tv};

(* For middle and low temperature we distinguish between the compiled and the uncompiled method *)

If[$CompileNDSolve,

(* If $CompileNDSolve=True, we reinterpolate the rates for the middle and the low temperatures. *)
(* The system is a matrix system in this case and it is built directly in NDSolve below *)
Rules\[Lambda]RHSI=MyInterpolationRate@Table[{Tv,MyChop@Rules\[Lambda]RHS[Tv]},{Tv,ListTRange[Tf,T18]}];
Rules\[Lambda]barRHSI=MyInterpolationRate@Table[{Tv,MyChop@Rules\[Lambda]barRHS[Tv]},{Tv,ListTRange[Tf,T18]}];
       Rules\[Lambda]RHS18I=MyInterpolationRate@Table[{Tv,Rules\[Lambda]RHS[NReactionsSmallNetwork,Tv]},{Tv,ListTRange[T18,TMiddle]}];
Rules\[Lambda]barRHS18I=MyInterpolationRate@Table[{Tv,Rules\[Lambda]barRHS[NReactionsSmallNetwork,Tv]},{Tv,ListTRange[T18,TMiddle]}];,

(* If $CompileNDSolve=False, we (re-)define the systems of equations for Middle and Low temperatures*)
(* We associate the r.h.s formed thanks to DY18 and DY, with the l.h.s made of derivatives *)
SystemEquationsMT[tv_]=Thread[Equal[FunPrimeList[tv],(DY18[Tv,\[Rho]Bv,tv])]]/.{Tv->Toft@tv,\[Rho]Bv->\[Rho]BForBBN@a@Toft@tv};
SystemEquationsLT[tv_]=Thread[Equal[FunPrimeList[tv],(DY[Tv,\[Rho]Bv,tv])]]/.{Tv->Toft@tv,\[Rho]Bv->\[Rho]BForBBN@a@Toft@tv};
]
)


(* ::Input::Initialization:: *)
t0:=tofa@a[Tstart];
tmiddle:=tofa@a[TMiddle];
t18:=tofa@a[T18];
tend:=tofa@a[Tend];


(* ::Input::Initialization:: *)
{t0,tmiddle,t18,tend}


(* ::Input::Initialization:: *)
HoldYNames[period_String]:=ToExpression/@("Hold@Y[\""<>period<>"\"][\""<>#<>"\"]"&/@ShortNames);


(* ::Input::Initialization:: *)
InitialConditionsHT[tv_]:=Thread[Equal[FunList[tv],CIList[Toft[tv]]]];


(* ::Input::Initialization:: *)
SolveValueHighTemperatures:=(Thread[MySet[Evaluate[HoldYNames["HT"]],
NDSolveValue[
Flatten@Join[SystemEquationsHT[tv],InitialConditionsHT[t0]],
VarList,{tv,t0,tmiddle},
PrecisionGoal->8+PrecisionNDSolve,AccuracyGoal->11,InterpolationOrder->InterpOrder]]];
tHT=Y["HT"]["n"][[3,1]];
);


(* ::Input::Initialization:: *)
ListThermalValuesMT={"d","t","He3","a","Be7","Li7","Li6"};
ListThermalValuesUsedMT=Intersection[VariablesInEquations,ListThermalValuesMT]


(* ::Input::Initialization:: *)
YPeriodTimeOrStateEquilibrium["HT",ListThermalValuesUsedMT][TMiddle,tmiddle]


(* ::Input::Initialization:: *)
InitialConditionsMT[Tv_,tv_]:=Thread[Equal[FunList[tv],YPeriodTimeOrStateEquilibrium["HT",ListThermalValuesUsedMT][Tv,tv]]];


(* ::Input::Initialization:: *)
SolveValueMiddleTemperatures:=(If[$CompileNDSolve,
(* Compiled version.*)
resMT=NDSolveValue[
{Ytab'[tv]==DY18CN[\[Rho]BForBBN@a@Toft@tv,Rules\[Lambda]RHS18I[Toft@tv],Rules\[Lambda]barRHS18I[Toft@tv],Ytab[tv]],Ytab[tmiddle]==YPeriodTimeOrStateEquilibrium["HT",ListThermalValuesUsedMT][TMiddle,tmiddle]},
Ytab,{tv,tmiddle,t18},
Method->{"BDF","MaxDifferenceOrder"->$BDFOrder},
PrecisionGoal->7+PrecisionNDSolve,AccuracyGoal->11,
InterpolationOrder->InterpOrder,Compiled->Automatic];
Y["MT"][key_][tv_?NumericQ]:=resMT[tv][[KeyVal[key]]];
tMT=resMT[[3,1]];,

(* Non compiled version. Slightly slower *)
Thread[MySet[Evaluate[HoldYNames["MT"]],NDSolveValue[
Flatten@Join[SystemEquationsMT[tv],InitialConditionsMT[TMiddle,tmiddle]],
VarList,{tv,tmiddle,t18},
Method->{"BDF","MaxDifferenceOrder"->$BDFOrder},
PrecisionGoal->7+PrecisionNDSolve,AccuracyGoal->11,
InterpolationOrder->InterpOrder,Compiled->False]]];
tMT=Y["MT"]["n"][[3,1]];
]);


(* ::Input::Initialization:: *)
InitialConditionsLT[tv_]:=Thread[Equal[FunList[tv],YPeriodTime["MT"][tv]]];


(* ::Input::Initialization:: *)
SolveValueLowTemperatures:=(If[$CompileNDSolve,
(* Compiled version*)
resLT=NDSolveValue[
{Ytab'[tv]==DYCN[\[Rho]BForBBN@a@Toft@tv,Rules\[Lambda]RHSI[Toft@tv],Rules\[Lambda]barRHSI[Toft@tv],Ytab[tv]],
Ytab[t18]==YPeriodTime["MT"][t18]},
Ytab,{tv,t18,tend},
Method->{"BDF","MaxDifferenceOrder"->$BDFOrder},
PrecisionGoal->5+PrecisionNDSolve,AccuracyGoal->AccuracyNDSolve,
InterpolationOrder->InterpOrder,StartingStepSize->10^-4,MaxStepSize->500];
Y["LT"][key_][tv_?NumericQ]:=resLT[tv][[KeyVal[key]]];
tLT=resLT[[3,1]];,

(* Uncompiled version. Slower. *)
Thread[MySet[Evaluate[HoldYNames["LT"]],NDSolveValue[
Flatten@Join[SystemEquationsLT[tv],InitialConditionsLT[t18]],
VarList,{tv,t18,tend},
Method->{"BDF","MaxDifferenceOrder"->$BDFOrder,"EquationSimplification"->"Solve"},
PrecisionGoal->5+PrecisionNDSolve,AccuracyGoal->AccuracyNDSolve,
InterpolationOrder->InterpOrder,StartingStepSize->10^-4]]];
tLT=Y["LT"]["n"][[3,1]];
];)


(* ::Input::Initialization:: *)
InterpolateResults=(
Clear[Yall,YI];
Yall[key_?KeyQ]:=Yall[key]=Function[{tv},Piecewise[{{Y["HT"][key][tv],tv<tmiddle},{Y["MT"][key][tv],tv<t18&&tv>=tmiddle},{Y["LT"][key][tv],tv<=tend&&tv>=t18}}]];

YI[key_?KeyQ]:=YI[key]=Interpolation[Table[{tv,Yall[key][tv]},{tv,Join[tHT,Rest@tMT,Rest@tLT]}],InterpolationOrder->1];);


(* ::Input::Initialization:: *)
RunNumericalIntegralsNuclearReactions:=(
(* Middle temperature integration *)
SolveValueMiddleTemperatures;

(* Low temperature integration *)
SolveValueLowTemperatures;
);


(* ::Input::Initialization:: *)
RunNumericalIntegrals:=(

(* In case of incomplete neutrino decoupling, we recompute all the integrations a(T) then inversion T(a), then Subscript[\[Rho], \[Nu]](a).*)
If[$IncompleteNeutrinoDecoupling,RecomputeIncompleteNeutrinoDecoupling;];

(*In case the plasma conditions have changed in a MC exploration, we recompute the inversion of a[T]*)
(* This is needed if we have recomputed the neutrino decoupling, but I am wondering if this is always needed. *)
InvertaOFT;

(* scale factor integration from Friedmann equation. *)
Computetofa;
Computeaoft;

(* Build equations. Needed since rate are modified randomly by the f factor of each reaction*)
LoadRates;
DefineEquations;

(* High temperature integration with only PEN reactions *)
SolveValueHighTemperatures;

(* Middle and Low temperature WITH nuclear reactions*)
RunNumericalIntegralsNuclearReactions;

InterpolateResults;
);


(* ::Input::Initialization:: *)
XI[key_?KeyQ][t_]:=Ai[key]YI[key][t]


(* ::Input::Initialization:: *)
Yf[key_]:=YLT[key][tend]
Xf[key_]:=Ai[key]Yf[key]


(* ::Input::Initialization:: *)
YfH[key_]:=Yf[key]/Yf["p"]


(* ::Input::Initialization:: *)
MyTickst={{Automatic,Automatic},{Automatic,{{tofa@a[10^11],"\!\(\*SuperscriptBox[\(10\), \(11\)]\)K"},{tofa@a[10^10.5],"\!\(\*SuperscriptBox[\(10\), \(10.5\)]\)K"},{tofa@a[10^10],"\!\(\*SuperscriptBox[\(10\), \(10\)]\)K"},{tofa@a[10^9.5],"\!\(\*SuperscriptBox[\(10\), \(9.5\)]\)K"},{tofa@a[10^9],"\!\(\*SuperscriptBox[\(10\), \(9\)]\)K"},{tofa@a[10^8.5],"\!\(\*SuperscriptBox[\(10\), \(8.5\)]\)K"},{tofa@a[10^8],"\!\(\*SuperscriptBox[\(10\), \(8\)]\)K"}}}};


(* ::Input::Initialization:: *)
$ParallelBool=True;
$Random\[Tau]neutron=True;
$Randomh2\[CapitalOmega]b=True;


(* ::Input::Initialization:: *)
InitializeKernels:=(
LaunchKernels[];
Print["Number of Kernels ",$KernelCount];
DistributeDefinitions[ReshapedTabulatedReactions,ListReactionsUpToChosenMass,LoadRates,DefineEquations,SystemEquationsHT,SystemEquationsMT,SystemEquationsLT,LoadRates,DY,DY18,DYOnlyPEN,LbarnTOp,LnTOp];
);


(* ::Input::Initialization:: *)
RunPRIMATMonteCarlo[number_]:=Module[{res,time,Abundances,mytabfunctions,sss,RandomVariables,CosmoParametersList},
If[number>1,Print["Running a Monte-Carlo with ",number, " points."];];
Off[CompiledFunction::cfta];
mytabfunctions=If[$ParallelBool,ParallelTable,Table];
If[$ParallelBool,InitializeKernels;
ParallelEvaluate[$HistoryLength=0;]];

(* We always use the same seed so that we always use the same sequence of random number as advocated in [Cyburt et al. 2015].*)

res=mytabfunctions[
$Seed:=i;(* We use a different seed so that for each MC point we have a different sequence of reaction rates *)
InitializeRandom[$Seed];(* We restart our random list from the beginning *)

h2\[CapitalOmega]b0=Meanh2\[CapitalOmega]b0+If[$Randomh2\[CapitalOmega]b,\[Sigma]h2\[CapitalOmega]b0 NormalRealisation,0];
\[Tau]neutron=Mean\[Tau]neutron+If[$Random\[Tau]neutron,\[Sigma]\[Tau]neutron NormalRealisation,0];
CosmoParametersList={h2\[CapitalOmega]b0,\[Tau]neutron};

time=AbsoluteTiming[RunNumericalIntegrals][[1]];
RandomVariables=Rest@ListReactionsUpToChosenMass[[All,4]];
Share[];
Print["Iteration ",i, "  Memory usage = ",MemoryInUse[]," time = ",time, "  Kernel : ",$KernelID];
Abundances=YPeriodTime["LT"][tend];
ClearSystemCache[];
If[$Verbose,Print[Abundances(*," ",RandomVariables*)]];
{Abundances,RandomVariables,CosmoParametersList},{i,1,number}];
If[$ParallelBool,CloseKernels[]];

h2\[CapitalOmega]b0=Meanh2\[CapitalOmega]b0;
\[Tau]neutron=Mean\[Tau]neutron;
MC=res[[All,1]];
RV=res[[All,2]];
Cosmo=res[[All,3]];

res];

RunPRIMAT:=RunPRIMATMonteCarlo[1];


(* ::Input::Initialization:: *)
Clear[LoadMC,DumpMC]


(* ::Input::Initialization:: *)
DumpMC[File_String]:=(
Print["Exporting ","MonteCarlo/MC"<>File<>".dat"];
Export["MonteCarlo/MC"<>File<>".dat",MC];

Print["Exporting ","MonteCarlo/RV"<>File<>".dat"];
Export["MonteCarlo/RV"<>File<>".dat",RV];

Print["Exporting ","MonteCarlo/Cosmo"<>File<>".dat"];
Export["MonteCarlo/Cosmo"<>File<>".dat",Cosmo];);

LoadMC[File_String]:=(
MCfile="MonteCarlo/MC"<>File<>".dat";
RVfile="MonteCarlo/RV"<>File<>".dat";
Cosmofile="MonteCarlo/Cosmo"<>File<>".dat";
        MC=Import[MCfile];
RV=Import[RVfile];
Cosmo=Import[Cosmofile];
TMC=Transpose[MC];
);


(* ::Input::Initialization:: *)
ElementColumn[el_]:=MC[[All,KeyVal[[el]]]];
ReactionColumn[el_]:=RV[[All,KeyNuclearReaction[el]]];
h2\[CapitalOmega]b0List:=Cosmo[[All,1]];
\[Tau]neutronList:=Cosmo[[All,2]];
