(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Date[]


(* Copyright (C) 2018- Cyril Pitrou, Alain Coc *)

(* This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of
 the License,or (at your option) any later version.

This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 General Public License for more details.

You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place-Suite 330, Boston, MA 02111-1307,
  USA. 
*)


$InterpolateAnalytics=True;


$CompileNDSolve=True;


$BDFOrder=2;


PrecisionNDSolve=2;(*TODO Put 2 here !!!! *)


AccuracyNDSolve:=15+PrecisionNDSolve;


NTemperaturePoints=1200; (*1000 is enough*)


InterpOrder=3;


$FastPENRatesIntegrals=True;


$PENRatesIntegralsPoints=300;(*200 is enough *)


TabulatedReactionsFile="BBNRates_2018_11reactions.dat";
NumberNuclearReactions=12;


MaximumNuclearMass=Infinity; 


$RandomNuclearRates=False;
$MaxVariationRate=1000;


dpTOHe3gFactor=1;


$RecomputeWeakRates=False;
$ParallelWeakRates=True;


$RadiativeCorrections=True;

$ResummedLogsRadiativeCorrections=True;
$RelativisticFermiFunction=True;


$RadiativeThermal=True;
$CorrectionBremsstrahlung=True;


$FiniteNucleonMass=True;


$CoupledFMandRC=True;


$QEDMassShift=False;


$QEDPlasmaCorrections=True;
$CompleteQEDPressure=True;


$IncompleteNeutrinoDecoupling=True;


$RecomputePlasmaCorrections=False;


$DegenerateNeutrinos=False;
\[Mu]OverT\[Nu]=0.0;


Kelvin=1;
Tstart=10^11 Kelvin;
TMiddle:=0.9999*10^10 Kelvin;
T18:=1.25 *10^9 Kelvin;
Tend=6.*10^7 Kelvin;


Ti=10^12 Kelvin;
Tf=10^7 Kelvin;
LogTi=1.Log10[Ti];
LogTf=1.Log10[Tf]; 


ListLogT=Sort@DeleteDuplicates@Join[{10.},Table[i,{i,LogTf,LogTi,(LogTi-LogTf)/NTemperaturePoints}]];
ListT=1. 10^ListLogT;


ListTRange[T1_,T2_]:=Module[{len=Length@ListT,imindown,imaxup,Tmin=Min[T1,T2],Tmax=Max[T1,T2]},
imindown=Max[1,-1+Position[ListT,SelectFirst[ListT,#>Tmin&]][[1,1]]];
imaxup=Min[len,Position[ListT,SelectFirst[ListT,#>=Tmax&]][[1,1]]];
ListT[[imindown;;imaxup]]
]


second=1;
cm=1;
gram=1;


kg=10^3 gram;
meter = 10^2 cm;
km=10^3 meter;
Joule =kg meter^2/second^2; (* This gives 10^7 ergs *)
DensityUnit=gram/cm^3;
Hz=1/second;


Giga=10^9;
Mega=10^6;
Kilo=10^3;


kB =1.3806488 10^-23 Joule / Kelvin;(* Boltzmann constant in J/K *)
clight=2.99792458*10^8*meter/second; (* speed of light in cm/s *)
hbar= 6.62606957/(2\[Pi]) 10^-34(*1.054571596 10^-34*) Joule second;
Avogadro=6.0221415 10^23;


eV=1.60217653 10^-19 Joule;
keV = Kilo eV;
MeV=Mega eV;
GeV=Giga eV;


GN=6.67384 10^-11 meter^3/kg/second^2; (* Gravitation constant *)
GF=1.1663787*10^-5/(GeV)^2; (* Fermi Constant*)
gA=1.2723; 
(* Axial current constant of structure of the nucleons Particle data group : 1.2723(+-23) PDG2016 *)
(* However post 2002 data suggest 1.2755(11) as advised by William Marciano*)


fWM=3.7058/2(*1.853*); (* Weak magnetism see 1212.0332*)
radiusproton=0.841*10^-15 meter (*(arXiv:1212.0332)*)


\[Alpha]FS=1/137.03599911;(* Fine structure constant =e^2/(4\[Pi]) *)


me=0.510998918 MeV; 
mn=939.565360 MeV;
mp=938.272029 MeV; 
Q=mn-mp; (* Mass difference between neutrons and protons *)
Subscript[m, Nucleon]=mn;

Subscript[m, W]=80.385 GeV; (* Mass of the W Boson. *) 
Subscript[m, Z]=91.1876 GeV;


Q/MeV


pc=3.0856777807 10^16 meter; (* The parsec *)
Mpc=Mega pc;
H0=100 h km/second/Mpc; (* Hubble constant today *)
H100=100 km/second/Mpc;(*Fake Hubble rate given by 100 km/s/Mpc so that h = H0/H100 *)


Subscript[\[Rho], crit]=3./(8\[Pi] GN) (H0)^2 (* in g cm^-3 by construction *)
\[Rho]crit100=(3./(8\[Pi] GN)) ((H100)^2) (* in g cm^-3 by construction *)


Mean\[Tau]neutron:=879.5(*880.2second+-1.1s was previous value from PDG2017 *);
(* Now we use 1712.05663 Section 11 which includes recente 2017 measurements.*)
\[Sigma]\[Tau]neutron:=0.8 second;
\[Tau]neutron=Mean\[Tau]neutron;


NeutrinosGenerations:=3.;
\[Xi]\[Nu]:=If[$DegenerateNeutrinos,\[Mu]OverT\[Nu],0];


\[Rho]FD[c_]=1/(2\[Pi]^2) \!\(
\*SubsuperscriptBox[\(\[Integral]\), \(0\), \(Infinity\)]\(
\*FractionBox[
SuperscriptBox[\(y\), \(3\)], \((
\*SuperscriptBox[\(E\), \(y - c\)] + 1)\)] \[DifferentialD]y\)\);
nFD[c_]=1/(2\[Pi]^2) \!\(
\*SubsuperscriptBox[\(\[Integral]\), \(0\), \(Infinity\)]\(
\*FractionBox[
SuperscriptBox[\(y\), \(2\)], \((
\*SuperscriptBox[\(E\), \(y - c\)] + 1)\)] \[DifferentialD]y\)\);
\[Rho]FDNonDegenerate=\[Rho]FD[0];


Nneu:=NeutrinosGenerations*(\[Rho]FD[\[Xi]\[Nu]]+\[Rho]FD[-\[Xi]\[Nu]])/(2\[Rho]FDNonDegenerate)


TCMB0:=2.7255Kelvin;
\[Sigma]TCMB0:=0.0006 Kelvin;(* [Planck 2015 XIII] *)


FourOverElevenQED:=4/11 (1+(25 \[Alpha]FS)/(22\[Pi]));
FourOverElevenNoQED:=4/11;
FourOverEleven:=If[$QEDPlasmaCorrections,FourOverElevenQED,FourOverElevenNoQED];

T\[Nu]0=(FourOverEleven)^(1/3) TCMB0;


h:=0.6727; (*+-0.0066 *)(*[Planck 2015 XIII]*)


Meanh2\[CapitalOmega]b0Planck=0.02225;(*[Planck 2015 XIII TT and ET and EE]*)
\[Sigma]h2\[CapitalOmega]b0Planck=0.00016;(* Standard deviation*)


Meanh2\[CapitalOmega]b0=Meanh2\[CapitalOmega]b0Planck; 
\[Sigma]h2\[CapitalOmega]b0=\[Sigma]h2\[CapitalOmega]b0Planck;
h2\[CapitalOmega]b0=Meanh2\[CapitalOmega]b0;


ReSetCosmology:=(
Meanh2\[CapitalOmega]b0=Meanh2\[CapitalOmega]b0Planck; 
NeutrinosGenerations=3;
);


Meanh2\[CapitalOmega]c0=0.1198;(* [Planck 2015 XIII]*)
\[Sigma]h2\[CapitalOmega]c0=0.0015;
h2\[CapitalOmega]c0=Meanh2\[CapitalOmega]c0;


1-(h2\[CapitalOmega]b0+h2\[CapitalOmega]c0)/h^2


aBB=((\[Pi]^2)/(15 hbar^3 (clight)^5)) 


Subscript[\[Rho], CMB0]:=aBB (kB TCMB0)^4 ;(* in g cm^-3*)

Subscript[n, CMB0]:=(2 Zeta[3])/(\[Pi]^2 hbar^3 (clight)^3) (kB TCMB0)^3


Subscript[n, CMB0]


Subscript[\[CapitalOmega], \[Gamma]0]:=Subscript[\[Rho], CMB0]/Subscript[\[Rho], crit];


Subscript[\[CapitalOmega], \[Nu]0]:=Nneu*7/8*(FourOverEleven)^(1/3) Subscript[\[CapitalOmega], \[Gamma]0];


ma = 931.494061 MeV;(* Audi2012 *)
He4Overma=4.0026032541; (* Audi2012 *)
H1Overma=1.00782503223; (* Audi2012 *)  


Subscript[x, He4]=0.24709 ;(* Chemical composition at the end of BBN. In principle one should account for He4 produced by stars...*)
Subscript[x, H1]=1-Subscript[x, He4];
mbaryon0=(Subscript[x, H1]H1Overma+Subscript[x, He4]He4Overma/4)ma;


\[Rho]B0 :=h2\[CapitalOmega]b0*\[Rho]crit100;


nbaryons0:=\[Rho]B0 /(mbaryon0/(clight)^2)


nbaryons0/Subscript[n, CMB0]


\[CapitalOmega]bh2Over\[Eta]:=Subscript[n, CMB0]/\[Rho]crit100 mbaryon0/(clight)^2


\[Eta]factor:=h2\[CapitalOmega]b0/\[CapitalOmega]bh2Over\[Eta]


\[Rho]B[av_]:=\[Rho]B0 /av^3;
nB[av_]:=nbaryons0 /av^3;


$CorrectBaryonsEnergyDensityinBBNRRates=True;
\[Rho]BForBBN[av_]:=\[Rho]B[av]If[$CorrectBaryonsEnergyDensityinBBNRRates,ma/mbaryon0,1];(* This is Eq. C8 of the companion paper *)


FD[EoverT_]=1/(Exp[EoverT]+1);(* Fermi Dirac Distribution *)
FD[Energy_,x_]=1/(Exp[x Energy]+1);
BE[EoverT_]=1/(Exp[EoverT]-1); (* Bose Einstein Distribution *)
BE[Energy_,x_]=1/(Exp[x Energy]-1);

(* For neutrinos with a chemical potential *)
FD\[Nu][Energy_,\[Phi]_,x_]=1/(Exp[x Energy-\[Phi]]+1);


FDp[Energy_,x_]=D[1/(Exp[x Energy]+1),Energy];


NP[number_]:=NumberForm[number,8]


MyGrid[Table_List]:=Grid[Table,Frame->All]


MyInterpolation[Tab_List]:=Interpolation[Tab,InterpolationOrder->InterpOrder];

(* Does not work to interpolate the log of rates because it fails when rates vanish !!!*)
MyInterpolationLog[Tab_List]:=Function[{x},Exp[Interpolation[{#[[1]],Log[#[[2]]]}&/@Tab,InterpolationOrder->InterpOrder][x]]];

$InterpolateLogRate=False;
MyInterpolationRate[Tab_List]:=If[$InterpolateLogRate,MyInterpolationLog[Tab],MyInterpolation[Tab]]


MyChop[el_?NumericQ]:=(Chop[el,$MinMachineNumber]);
SetAttributes[MyChop,Listable];


MySet[Hold[expr_],value_]:=(expr=value);
MySetDelayed[Hold[expr_],value_]:=(expr:=value);


TableSimpsonC=Compile[{{a,_Real},{b,_Real},{Np,_Integer}},With[{h=1.(b-a)/Np,n2=Np/2},With[{h3=h/3.},Join[{{a,h3}},Table[{a+2. j h,2 h3},{j,1,n2-1}],Table[{a+(2. j-1) h,4 h3},{j,1,n2}],{{b,h3}}]]],CompilationTarget->"C","RuntimeOptions"->"Speed"];


MyCompile[LV_List,Body_]:=Compile[LV,Evaluate[Body],"RuntimeOptions"->"Speed",CompilationTarget->"C",CompilationOptions->{"InlineExternalDefinitions"->True},RuntimeAttributes->{Listable}]


V1dotV2=Compile[{{V1,_Real,1},{V2,_Real,1}},V1.V2,CompilationTarget->"C","RuntimeOptions"->"Speed"];


IntegrateFunction[fun_,pemin_,pemax_,Np_]:=With[{interv=(pemax-pemin)/(Np),tab=TableSimpsonC[pemin,pemax,Np]},V1dotV2[tab[[All,2]],MyChop[fun[tab[[All,1]]]]]];


SafeImport[args__]:=Module[{out},out=Catch[Check[Import[args],Print["File ",{args}[[1]]," not found. Quiting Kernel."];Throw[$Failed];,Import::nffil]];If[out===$Failed,Quit[]];out]


MyFrameTicksLog={{Automatic,Automatic},{{{Log[10^8],"\!\(\*SuperscriptBox[\(10\), \(8\)]\)"},{Log[10^8.5],"\!\(\*SuperscriptBox[\(10\), \(8.5\)]\)"},{Log[10^9],"\!\(\*SuperscriptBox[\(10\), \(9\)]\)"},{Log[10^9.5],"\!\(\*SuperscriptBox[\(10\), \(9.5\)]\)"},{Log[10^10],"\!\(\*SuperscriptBox[\(10\), \(10\)]\)"},{Log[10^10.5],"\!\(\*SuperscriptBox[\(10\), \(10.5\)]\)"},{Log[10^11],"\!\(\*SuperscriptBox[\(10\), \(11\)]\)"},{Log[10^11.5],"\!\(\*SuperscriptBox[\(10\), \(11.5\)]\)"}},Automatic}};

MyFrameTicks={{Automatic,Automatic},{{{10^8,"\!\(\*SuperscriptBox[\(10\), \(8\)]\)"},{10^8.5,"\!\(\*SuperscriptBox[\(10\), \(8.5\)]\)"},{10^9,"\!\(\*SuperscriptBox[\(10\), \(9\)]\)"},{10^9.5,"\!\(\*SuperscriptBox[\(10\), \(9.5\)]\)"},{10^10,"\!\(\*SuperscriptBox[\(10\), \(10\)]\)"},{10^10.5,"\!\(\*SuperscriptBox[\(10\), \(10.5\)]\)"},{10^11,"\!\(\*SuperscriptBox[\(10\), \(11\)]\)"},{10^11.5,"\!\(\*SuperscriptBox[\(10\), \(11\)]\).5"}},Automatic}};


Clear[Imn]
Imn[sgn_][m_,n_][x_]:=NIntegrate[((pe^2+x^2)^((m-1)/2) pe^(n+1))/(Exp[Sqrt[pe^2+x^2]]+sgn),{pe,0,Infinity},Method->{Automatic,"SymbolicProcessing"->0}]
ImnT[sgn_][m_,n_][T_]:=Imn[sgn][m,n][me/(kB T)]

(* Interpolations *)
ImnI[sgn_][m_,n_]:=ImnI[sgn][m,n]=Interpolation@Table[{me/(kB Tv),Imn[sgn][m,n][me/(kB Tv)]},{Tv,ListT}]
ImnIT[sgn_][m_,n_][T_]:=ImnI[sgn][m,n][me/(kB T)]


dme2[T_]:=((kB T)/me)^2 ((2\[Pi] \[Alpha]FS)/3+ (4\[Alpha]FS)/\[Pi] ImnT[1][0,1][T])(* Only main part of mass shift *)
dm\[Gamma]2[T_]:= (8\[Alpha]FS)/\[Pi] ImnT[1][0,1][T]((kB T)/me)^2


dme2Tab=Check[Import["Interpolations/dme2.dat","TSV"],Print["Precomputed data not found. We recompute and store the data."];$Failed,Import::nffil];

dmg2Tab=Check[Import["Interpolations/dmg2.dat","TSV"],Print["Precomputed data not found. We recompute and store the data."];$Failed,Import::nffil];



Timing[If[dme2Tab==$Failed||dmg2Tab==$Failed||$RecomputePlasmaCorrections,

dme2Tab=Table[{T,dme2[T]},{T,ListT}];
dmg2Tab=Table[{T,dm\[Gamma]2[T]},{T,ListT}];

Export["Interpolations/dme2.dat",dme2Tab,"TSV"];
Export["Interpolations/dmg2.dat",dmg2Tab,"TSV"];
];]


dme2I=MyInterpolation@ToExpression@dme2Tab;
dm\[Gamma]2I=MyInterpolation@ToExpression@dmg2Tab;


dme2N[T_?NumericQ]:=Which[T<Tf,0,T<=Ti ,dme2I[T],T>Ti,dme2I[Ti]];
dm\[Gamma]2N[T_?NumericQ]:=Which[T<Tf,0,T<=Ti ,dm\[Gamma]2I[T],T>Ti,dme2I[Ti]];


dme2x[x_]:=dme2N[me/(kB x)];


dPa[T_]:=dPa[T]=\[Alpha]FS/\[Pi] (kB T)^4 (-(2/3)ImnT[1][0,1][T]-2/\[Pi]^2 (ImnT[1][0,1][T])^2);


Fdp1dp2=Compile[{{p1,_Real},{p2,_Real},{x,_Real}},Evaluate[With[
{e1=Sqrt[p1^2+x^2],e2=Sqrt[p2^2+x^2]},
\[Alpha]FS/\[Pi]^3 (x^2 p1^2 p2^2)/(p1 p2 e1 e2) Log[Abs[(p1+p2)/(p1-p2)]] 1/((Exp[e1]+1)(Exp[e2]+1))
]],"RuntimeOptions"->"Speed",CompilationTarget->"C"];


Fdp1dp2N[p1_?NumericQ,p2_?NumericQ,x_]:=Fdp1dp2[p1,p2,x];


Clear[dPb]
dPb[Tv_]:=dPb[Tv]=(kB Tv)^4 With[{x=me /(kB Tv)},
0.5NIntegrate[
Fdp1dp2N[(p1pp2+p1mp2)/2,(p1pp2-p1mp2)/2,x]
+Fdp1dp2N[(p1pp2-p1mp2)/2,(p1pp2+p1mp2)/2,x],
{p1mp2,0.0001,Max[20,20* x]},{p1pp2,0.0001+Abs[p1mp2],Max[20,20*x]+Abs[p1mp2]},PrecisionGoal->4]
];


dP[T_]:=dP[T]= dPa[T]+If[$CompleteQEDPressure,dPb[T],0]

dPI:=dPI=Interpolation@Table[{Tv,dP[Tv]},{Tv,ListT}]


Clear[d\[Rho]]
d\[Rho][T_]:=d\[Rho][T]=-dP[T]+T dPI'[T]


dgP[T_]:=dP[T] 90/(\[Pi]^2 (kB T)^4);
dg\[Rho][T_]:=d\[Rho][T] 30/(\[Pi]^2 (kB T)^4);


dg\[Rho]dgP=Check[Import["Interpolations/dg.dat","TSV"],Print["Precomputed data not found. We recompute and store the data."];$Failed,Import::nffil];

Timing[If[dg\[Rho]dgP==$Failed||$RecomputePlasmaCorrections,

dg\[Rho]Tab=Table[{T,dg\[Rho][T]},{T,ListT}];
dgPTab=Table[{T,dgP[T]},{T,ListT}];

dg\[Rho]dgP={dg\[Rho]Tab,dgPTab};
Export["Interpolations/dg.dat",dg\[Rho]dgP,"TSV"];
];]


dg\[Rho]I=MyInterpolation@ToExpression[dg\[Rho]dgP[[1]]];
dgPI=MyInterpolation@ToExpression[dg\[Rho]dgP[[2]]];


dg\[Rho]N[T_?NumericQ]:=Which[T<Tf,0,T<=Ti ,dg\[Rho]I[T],T>Ti,dg\[Rho]I[Ti]];
dgPN[T_?NumericQ]:=Which[T<Tf,0,T<=Ti ,dgPI[T],T>Ti,dgPI[Ti]];


dg\[Rho]x[x_]:=dg\[Rho]N[me/(kB x)];
dgPx[x_]:=dgPN[me/(kB x)];


DSTNoQED=MyInterpolation@Table[{T,With[{x=me/(kB T)},1+45/(2\[Pi]^4) (1/3 Imn[1][0,3][x]+Imn[1][2,1][x])]},{T,ListT}];
DSTQED[Tv_]:=(3dg\[Rho]N[Tv]+dgPN[Tv])/8+DSTNoQED[Tv];


DST[Tv_]:=If[$QEDPlasmaCorrections,DSTQED[Tv],DSTNoQED[Tv]]
DSTN[T_?NumericQ]=Which[T<Tf,1,T<=Ti ,DST[T],T>Ti,DST[Ti]];


D\[Rho]TNoQED=MyInterpolation@Table[{T,With[{x=me/(kB T)},30/\[Pi]^4 (Imn[1][2,1][x])]},{T,ListT}];D\[Rho]T[T_]:=If[$QEDPlasmaCorrections,dg\[Rho]N[T]/2,0]+D\[Rho]TNoQED[T];


Listnl={-10.21703221236002,61.24438067531452,-340.3323864212157,1057.2707914654834,-2045.577491331372,2605.9087171012848,-2266.1521815470196,1374.2623075963388,-586.0618273295763,174.87532902234145,-35.715878215468045,4.7538967685808755,-0.3713438862054167,0.012908416591272199};

\[ScriptCapitalN][z_]:=If[z>=4,0,Exp[Plus@@Table[Listnl[[i+1]]z^i,{i,0,13}]]]


\[ScriptCapitalN]T[Tv_]:= \[ScriptCapitalN][me/(kB Tv)];
\[ScriptCapitalN]lT[lTv_]:= \[ScriptCapitalN][me/(kB Exp@lTv)];


DS2lTQED[lTv_]:=(2*2\[Pi]^2)/45 DSTQED[Exp@lTv];
DST2QED[Tv_]:=(2*2\[Pi]^2)/45 DSTQED[Tv]

DS2lTNoQED[lTv_]:=(2*2\[Pi]^2)/45 DSTNoQED[Exp@lTv];
DST2NoQED[Tv_]:=(2*2\[Pi]^2)/45 DSTNoQED[Tv]



SolveaOFTwhenID:=(laTCQED=NDSolveValue[{laTCN'[lTv]==(\[ScriptCapitalN]lT[lTv]-DS2lTQED'[lTv])/(\[ScriptCapitalN]lT[lTv]+3*DS2lTQED[lTv]),laTCN[Log@Tf]==Log[TCMB0/DSTQED[Tf]^(1/3)]},{laTCN},{lTv,Log@Ti,Log@Tf},PrecisionGoal->40,AccuracyGoal->9][[1]];

laTCNoQED=NDSolveValue[{laTCNNoQED'[lTv]==(\[ScriptCapitalN]lT[lTv]-DS2lTNoQED'[lTv])/(\[ScriptCapitalN]lT[lTv]+3*DS2lTNoQED[lTv]),laTCNNoQED[Log@Tf]==Log[TCMB0/DSTNoQED[Tf]^(1/3)]},{laTCNNoQED},{lTv,Log@Ti,Log@Tf},PrecisionGoal->40,AccuracyGoal->9][[1]];
);


SolveaOFTwhenID


aTCQED[Tv_]:=Exp[laTCQED[Log@Tv]];
aCQED[Tv_]:=aTCQED[Tv]/Tv;


aTCNoQED[Tv_]:=Exp[laTCNoQED[Log@Tv]];
aCNoQED[Tv_]:=aTCNoQED[Tv]/Tv;


InvertaofTwhenID:=
(TofaCQED=Interpolation@Table[{aCQED[T],T},{T,ListT}];
TofaCNoQED=Interpolation@Table[{aCNoQED[T],T},{T,ListT}];

aTofaCQED=Interpolation@Table[{aCQED[T],aTCQED[T]},{T,ListT}];
aTofaCNoQED=Interpolation@Table[{aCNoQED[T],aTCNoQED[T]},{T,ListT}];
);


InvertaofTwhenID


aC[T_]:=If[$QEDPlasmaCorrections,aCQED[T],aCNoQED[T]]


Solve\[Rho]\[Nu]OFawhenID:=(Timing[a4\[Rho]\[Nu]LogaQED=NDSolveValue[{bar\[Rho]aNQED'[lav]==1/(hbar^3 clight^5)(kB aTofaCQED[Exp@lav])^4 \[ScriptCapitalN]T[TofaCQED[Exp@lav]],bar\[Rho]aNQED[Log@aCQED@Ti]==aBB (kB aTCQED[Ti])^4 7/8 Nneu},{bar\[Rho]aNQED},{lav,Log[aCQED[Ti]],Log[aCQED[Tf]]},Method->"StiffnessSwitching",PrecisionGoal->12][[1]];];

Timing[a4\[Rho]\[Nu]LogaNoQED=NDSolveValue[{bar\[Rho]aNNoQED'[lav]==1/(hbar^3 clight^5)(kB aTofaCNoQED[Exp@lav])^4 \[ScriptCapitalN]T[TofaCNoQED[Exp@lav]],bar\[Rho]aNNoQED[Log@aCNoQED@Ti]==aBB (kB aTCNoQED[Ti])^4 7/8 Nneu},{bar\[Rho]aNNoQED},{lav,Log[aCNoQED[Ti]],Log[aCNoQED[Tf]]},Method->"StiffnessSwitching",PrecisionGoal->12][[1]];];
);


Solve\[Rho]\[Nu]OFawhenID


a4\[Rho]\[Nu]CQED[av_]:=a4\[Rho]\[Nu]LogaQED[Log@av];
\[Rho]\[Nu]CQED[av_]:=a4\[Rho]\[Nu]CQED[av]/av^4;



a4\[Rho]\[Nu]CNoQED[av_]:=a4\[Rho]\[Nu]LogaNoQED[Log@av];
\[Rho]\[Nu]CNoQED[av_]:=a4\[Rho]\[Nu]CNoQED[av]/av^4;


(*\[Rho]\[Nu]C[av_]:=If[$QEDPlasmaCorrections,\[Rho]\[Nu]CQED[av],\[Rho]\[Nu]CNoQED[av]];*)

\[Rho]\[Nu]IncompleteDecoupling[av_]:=If[$QEDPlasmaCorrections,\[Rho]\[Nu]CQED[av],\[Rho]\[Nu]CNoQED[av]];


RecomputeIncompleteNeutrinoDecoupling:=(
SolveaOFTwhenID;
InvertaofTwhenID;
Solve\[Rho]\[Nu]OFawhenID;
)


T\[Nu]overTDecoupling[T_]:=(FourOverEleven DST[T])^(1/3);
\[Rho]\[Nu]Decoupling[Tv_]:=aBB (kB T\[Nu]overTDecoupling[Tv]Tv)^4 7/8 Nneu;


T\[Nu]overTIncompleteDecouplingQED[Tv_]:=(\[Rho]\[Nu]CQED[aCQED[Tv]]/(aBB (kB Tv)^4 7/8 Nneu))^(1/4);
T\[Nu]overTIncompleteDecouplingNoQED[Tv_]:=(\[Rho]\[Nu]CNoQED[aCNoQED[Tv]]/(aBB (kB Tv)^4 7/8 Nneu))^(1/4);

T\[Nu]overTIncompleteDecoupling[T_]:=If[$QEDPlasmaCorrections,T\[Nu]overTIncompleteDecouplingQED[T],T\[Nu]overTIncompleteDecouplingNoQED[T]]


If[$IncompleteNeutrinoDecoupling,
T\[Nu]overT[Tv_]:=T\[Nu]overTIncompleteDecoupling[Tv];,
T\[Nu]overT[Tv_]:=T\[Nu]overTDecoupling[Tv];];


T\[Nu]overTDecouplingNoQED[T_]:=(FourOverElevenNoQED* DSTNoQED[T])^(1/3);
T\[Nu]overTDecouplingQED[T_]:=(FourOverElevenQED* DSTQED[T])^(1/3);

EffectiveNeutrinosQED[Tv_]:=3(T\[Nu]overTIncompleteDecouplingQED[Tv]/T\[Nu]overTDecouplingNoQED[Tv])^4;
EffectiveNeutrinosNoQED[Tv_]:=3(T\[Nu]overTIncompleteDecouplingNoQED[Tv]/T\[Nu]overTDecouplingNoQED[Tv])^4;


zOFTDecouplingNoQED[T_]:=(DSTNoQED[Ti]/DSTNoQED[T])^(1/3);
zOFTDecouplingQED[T_]:=(DSTQED[Ti]/DSTQED[T])^(1/3);

zOFTIncompleteDecouplingNoQED[T_]:=(aCNoQED[T]T)/(aCNoQED[Ti]Ti);
zOFTIncompleteDecouplingQED[T_]:=(aCQED[T]T)/(aCQED[Ti]Ti);


z\[Nu]OFTQED[T_]:=T\[Nu]overTIncompleteDecouplingQED[T]*zOFTIncompleteDecouplingQED[T];
z\[Nu]OFTNoQED[T_]:=T\[Nu]overTIncompleteDecouplingNoQED[T]*zOFTIncompleteDecouplingNoQED[T];
z\[Nu]OFT[T_]:=If[$QEDPlasmaCorrections,z\[Nu]OFTQED[T],z\[Nu]OFTNoQED[T]]


If[$IncompleteNeutrinoDecoupling,
a[T_]:=aC[T],
a[T_]:=TCMB0/(T DST[T]^(1/3))];


zT[T_]:=(a[T]T)/(a[Ti]Ti);
znuT[T_]:=(a[T]T\[Nu]overT[T] T)/(a[Ti]T\[Nu]overT[Ti] Ti);


InvertaOFT:=(Tofa=Interpolation@Table[{a[T],T},{T,ListT}];);
(*aI=Interpolation@Table[{T,a[T]},{T,ListT}];*)


\[Eta]factorT[Tv_]:=nB[a[Tv]]*\[Pi]^2/(2Zeta[3]) ((hbar clight)/(kB Tv))^3;


\[Eta]factorTBis[Tv_]:=\[Eta]factor*(zT[Tf]/zT[Tv])^3;


FDe2p0[en_,x_]=Simplify[FD[en,x]en^2];
FDe3p0[en_,x_]=Simplify[FD[en,x]en^3];
FDe2p2[en_,x_]=Simplify@D[D[FD[en,x]en^2,en],en];

FDe3p2[en_,x_]=Simplify@D[D[FD[en,x]en^3,en],en];
FDe4p2[en_,x_]=Simplify@D[D[FD[en,x]en^4,en],en];
FDe2p1[en_,x_]=Simplify@D[FD[en,x]en^2,en];
FDe3p1[en_,x_]=Simplify@D[FD[en,x]en^3,en];
FDe4p1[en_,x_]=Simplify@D[FD[en,x]en^4,en];


FD\[Nu]e2p0[en_,\[Phi]_,x_]=Simplify[FD\[Nu][en,\[Phi],x]en^2];
FD\[Nu]e3p0[en_,\[Phi]_,x_]=Simplify[FD\[Nu][en,\[Phi],x]en^3];
FD\[Nu]e2p2[en_,\[Phi]_,x_]=Simplify@D[D[FD\[Nu][en,\[Phi],x]en^2,en],en];

FD\[Nu]e3p2[en_,\[Phi]_,x_]=Simplify@D[D[FD\[Nu][en,\[Phi],x]en^3,en],en];
FD\[Nu]e4p2[en_,\[Phi]_,x_]=Simplify@D[D[FD\[Nu][en,\[Phi],x]en^4,en],en];
FD\[Nu]e2p1[en_,\[Phi]_,x_]=Simplify@D[FD\[Nu][en,\[Phi],x]en^2,en];
FD\[Nu]e3p1[en_,\[Phi]_,x_]=Simplify@D[FD\[Nu][en,\[Phi],x]en^3,en];
FD\[Nu]e4p1[en_,\[Phi]_,x_]=Simplify@D[FD\[Nu][en,\[Phi],x]en^4,en];


\[Lambda]BORN=With[{q=Q/me},NIntegrate[en (en-q)^2 Sqrt[en^2-1],{en,1,q}]]


AgCzarnecki=-0.34;
CCzarnecki=0.891;
mA=1.2 GeV;
ConstantSirlin =4Log[Subscript[m, Z]/mp]+Log[mp/mA]+2CCzarnecki+AgCzarnecki;


Rd[x_]:=ArcTanh[x]/x;


Lfun[x_]=Integrate[Log[1-t]/t,{t,0,x},Assumptions->x<1&&x>0](* Lfun is called the Spence function *)


LfunSeries[b_]=Normal@Series[-1/4*(1+b)^6*4/b Lfun[(2b)/(1+b)],{b,0,12(*22*)}]


$SeriesSpenceFunction=False;

SirlinGFunction[b_,y_,en_]:=(3Log[mp/(me)]-3/4+4(Rd[b]-1)(y/(3 en)-3/2+Log[2y])+Rd[b](2(1+b^2)+y^2/(6 en^2)-4 b Rd[b])+If[$SeriesSpenceFunction,-4/(1+b)^6*LfunSeries[b],4/b Lfun[(2b)/(1+b)]]);
Cd[b_,y_,en_]:=(ConstantSirlin+SirlinGFunction[b,y,en]);


LFactor=1.02094;
SFactor=1.02248;
\[Delta]factor=-0.00043*2Pi/\[Alpha]FS;
NLL=-0.0001;


RadiativeCorrectionsResummed[b_,y_,en_]:=(1+\[Alpha]FS/(2\[Pi]) (SirlinGFunction[b,y,en]-3Log[mp/(2Q)]))*
(LFactor+\[Alpha]FS/\[Pi] CCzarnecki+\[Alpha]FS/(2\[Pi]) \[Delta]factor)*(SFactor+1/(134*2*Pi)*(Log[mp/mA]+AgCzarnecki)+NLL);


RadiativeCorrections[b_,y_,en_]:=If[$ResummedLogsRadiativeCorrections,RadiativeCorrectionsResummed[b,y,en],(1+\[Alpha]FS/(2\[Pi]) Cd[b,y,en])]


FermiRelat[b_]:=With[{\[Gamma]=Sqrt[1-\[Alpha]FS^2]-1,\[Lambda]Compton=1/(me/(hbar clight))},
(1+\[Gamma]/2)*4((2radiusproton b)/\[Lambda]Compton)^(2\[Gamma])*1/Gamma[3+2\[Gamma]]^2 Exp[(\[Pi] \[Alpha]FS)/b]*1/(1-b^2)^\[Gamma] Abs[Gamma[1+\[Gamma]+I \[Alpha]FS/b]]^2];

FermiNonRelat[b_]:=(2\[Pi] \[Alpha]FS/b)/(1-Exp[-2\[Pi] \[Alpha]FS/b]);


If[$RelativisticFermiFunction,

Fermi[b_]:=FermiRelat[b];
bFermi[b_]:=b Fermi[b];,

Fermi[b_]:=FermiNonRelat[b];
bFermi[b_]:=(2\[Pi] \[Alpha]FS)/(1-Exp[-2\[Pi] \[Alpha]FS/b]);]


\[Lambda]FermiOnly=With[{q=Q/me ,b=Sqrt[en^2-1]/en,y=Q/me -en},
NIntegrate[en (en-q)^2 en*bFermi[b],{en,1.0000001,q}]]


\[Lambda]FermiOnly/(\[Lambda]BORN)


\[Lambda]Rad=With[{q=Q/me ,b=Sqrt[en^2-1]/en,y=Q/me -en},
NIntegrate[en (en-q)^2 en(RadiativeCorrections[b,y,en])*bFermi[b],{en,1.0000001,q}]]


\[Lambda]Rad/\[Lambda]FermiOnly


IntegrateCorrectionNeutronDecay[fun_]:=
NIntegrate[fun[pe],{pe,0.0000001,Sqrt[(Q/me)^2-1]},WorkingPrecision->MachinePrecision];


\[Chi]FMNeutronDecay[en_,pe_]:=
With[{M=mp/me,enu=en-Q/me,f1=((1+gA)^2+4 fWM gA)/(1+3gA^2),f2=((1-gA)^2-4fWM gA)/(1+3gA^2),f3=(gA^2-1)/(1+3gA^2)},
 f1*enu^2 (pe^2/(M*en))
+f2*enu^3(-(1/M))
+ (f1+f2+f3) 1/(2M)*(4enu^3+2enu pe^2)
+f3*1/(3M) 3enu^2  (pe^2)/(en)
];


I\[Lambda]FM[pe_]:=With[{en=Sqrt[pe^2+1]},With[{b=pe/en},pe^2*
(\[Chi]FMNeutronDecay[en,pe]*If[$RadiativeCorrections&&$CoupledFMandRC,(RadiativeCorrections[b,Abs[en- Q/me ],en])Fermi[b],1])
]];


\[Lambda]FM=If[$FiniteNucleonMass,IntegrateCorrectionNeutronDecay[I\[Lambda]FM],0]


CorrectionRate=\[Lambda]FM/\[Lambda]BORN


\[Lambda]Rad


\[Lambda]FM


\[Lambda]RadandFM=\[Lambda]Rad+\[Lambda]FM


\[Lambda]Cooper=1.03887*1.6887
\[Lambda]Czarnecki=1.0390*1.6887 (* = (1+RC)*f with f=1.6887 and RC = 0.0390(8) [Czarnecki et al. 2004]] *)


MixingCosAngle=0.97420;(* (+-16) Value taken from CKM particle data group 2017. More precisely from the review on Vud Vus of the PDG 2017.*)
MyK=MixingCosAngle^2 (GF)^2 (1+3(gA)^2)/(2\[Pi]^3)*(me )^5 /hbar
1/MyK/\[Lambda]RadandFM
1/MyK/\[Lambda]Czarnecki
1/MyK/\[Lambda]Cooper


\[Tau]neutron


pemin=0.00001;
pemiddle[x_]:=Sqrt[Max[pemin^2,(Q/me )^2-1 -If[$QEDMassShift,dme2x[x],0]]];
pemaxC[x_]:=Max[7,30/x];
pemax[x_]:=Max[7,30/x];


$TnuEqualT=False;


IntegratedpNpoints[fun_,sgnq_,Tv_,Npoints_]:=With[{x=me/(kB Tv) ,znu=me/(kB Tv T\[Nu]overT[Tv]) },
If[$FastPENRatesIntegrals,
IntegrateFunction[fun[#,x,If[$TnuEqualT,x,znu],sgnq]&,pemin,pemaxC[x],Npoints],
NIntegrate[fun[pe,x,If[$TnuEqualT,x,znu],sgnq],{pe,pemin,pemiddle[x],pemax[x]}]
]]

IntegrateRatedp[fun_,sgnq_,Tv_]:=IntegratedpNpoints[fun,sgnq,Tv,$PENRatesIntegralsPoints];



enOFpe[pe_,x_]:=Sqrt[pe^2+1 +If[$QEDMassShift,dme2x[x],0]];


IPENdpFrom\[Chi]NoCCR[en_,pe_,x_,znu_,sgnq_,\[Chi]function_]:=With[{q=Q/me },With[{b=pe/en},
pe^2*(\[Chi]function[en,pe,x,znu,sgnq]+\[Chi]function[-en,pe,x,znu,sgnq])
]];


Fermi[sgnq_,signE_,b_?NumericQ]:=If[sgnq signE >0,Fermi[b],1];
SetAttributes[Fermi,Listable];


IPENdpFrom\[Chi]CCR[en_,pe_,x_,znu_,sgnq_,\[Chi]function_]:=With[{q=Q/me ,b=pe/en},
pe^2*(\[Chi]function[en,pe,x,znu,sgnq](RadiativeCorrections[b,Abs[sgnq Q/me-en],en])Fermi[sgnq,1,b]+\[Chi]function[-en,pe,x,znu,sgnq](RadiativeCorrections[b, Abs[sgnq Q/me+en],en])Fermi[sgnq,-1,b])
];


\[Chi][en_,pe_,x_,znu_,sgnq_]:=With[{q=Q/me },FD\[Nu][en-sgnq q,sgnq \[Xi]\[Nu],znu]FD[-en,x](en-sgnq q)^2];


IPENdp[pe_,x_,znu_,sgnq_]:=IPENdpFrom\[Chi]NoCCR[enOFpe[pe,x],pe,x,If[$TnuEqualT,x,znu],sgnq,\[Chi]]


IPENdpCheatNeutrinoTemperature[pe_,x_,znu_,sgnq_]:=IPENdpFrom\[Chi]NoCCR[Sqrt[pe^2+1],pe,x,x,sgnq,\[Chi]]


\[Lambda]nTOpBORN[Tv_]:=IntegrateRatedp[IPENdp,1,Tv];
\[Lambda]pTOnBORN[Tv_]:=IntegrateRatedp[IPENdp,-1,Tv];


\[Lambda]nTOpBORNCheatNeutrino[Tv_]:=IntegrateRatedp[IPENdpCheatNeutrinoTemperature,1,Tv];
\[Lambda]pTOnBORNCheatNeutrino[Tv_]:=IntegrateRatedp[IPENdpCheatNeutrinoTemperature,-1,Tv];


\[Chi]FM[en_,pe_,x_,znu_,sgnq_]:=
With[{\[Phi]=sgnq \[Xi]\[Nu],q=Q/me ,M=(mp+mn -sgnq Q)/(2me ),Mp=mp/me ,Mn=mn /me ,enu=en-sgnq Q/me,
f1=((1+sgnq gA)^2+4fWM sgnq gA)/(1+3gA^2),
f2=((1-sgnq gA)^2-4fWM sgnq gA)/(1+3gA^2),f3=(gA^2-1)/(1+3gA^2)},
f1*FD\[Nu]e2p0[enu,\[Phi],znu]FD[-en,x](pe^2/(M*en))
+f2*FD\[Nu]e3p0[enu,\[Phi],znu]FD[-en,x](-(1/M))
+(f1+f2+f3) 1/(2x M)*(FD\[Nu]e4p2[enu,\[Phi],znu]FD[-en,x]+FD\[Nu]e2p2[enu,\[Phi],znu]FD[-en,x]pe^2)
+(f1+f2+f3) 1/(2M)*(FD\[Nu]e4p1[enu,\[Phi],znu]FD[-en,x]+FD\[Nu]e2p1[enu,\[Phi],znu]FD[-en,x]pe^2)
-(f1+f2) 1/(x M)*(FD\[Nu]e3p1[enu,\[Phi],znu]FD[-en,x]+FD\[Nu]e2p1[enu,\[Phi],znu]FD[-en,x]pe^2/(-en))
-f3*3/(x M) FD\[Nu]e2p0[enu,\[Phi],znu]FD[-en,x](* This term seems to give very small corrections *)
+f3*1/(3M) FD\[Nu]e3p1[enu,\[Phi],znu]FD[-en,x] pe^2/(en)
+f3*2/(2 x*3M) FD\[Nu]e3p2[enu,\[Phi],znu]FD[-en,x] pe^2/(en)
-(f1+f2+f3)*3/(2x)*(1-(Mn/Mp)^sgnq)*(FD\[Nu]e2p1[enu,\[Phi],znu]FD[-en,x])
];


IPENdpFMNoCCR[pe_,x_,znu_,sgnq_]:=IPENdpFrom\[Chi]NoCCR[enOFpe[pe,x],pe,x,If[$TnuEqualT,x,znu],sgnq,\[Chi]FM]
IPENdpFMCCR[pe_,x_,znu_,sgnq_]:=IPENdpFrom\[Chi]CCR[enOFpe[pe,x],pe,x,If[$TnuEqualT,x,znu],sgnq,\[Chi]FM]


IPENdpFMCheatNeutrinoTemperature[pe_,x_,znu_,sgnq_]:=IPENdpFrom\[Chi]NoCCR[enOFpe[pe,x],pe,x,x,sgnq,\[Chi]FM]


Clear[\[Lambda]nTOpFMCCR,\[Lambda]pTOnFMCCR,\[Lambda]nTOpFMNoCCR,\[Lambda]pTOnFMNoCCR,\[Lambda]nTOpCheatNeutrinoFM,\[Lambda]pTOnCheatNeutrinoFM]


\[Lambda]nTOpFMCCR[Tv_]:=IntegrateRatedp[IPENdpFMCCR,1,Tv];
\[Lambda]pTOnFMCCR[Tv_]:=IntegrateRatedp[IPENdpFMCCR,-1,Tv];


\[Lambda]nTOpFMNoCCR[Tv_]:=IntegrateRatedp[IPENdpFMNoCCR,1,Tv];
\[Lambda]pTOnFMNoCCR[Tv_]:=IntegrateRatedp[IPENdpFMNoCCR,-1,Tv];


\[Lambda]nTOpCheatNeutrinoFM[Tv_]:=IntegrateRatedp[IPENdpFMCheatNeutrinoTemperature,1,Tv];
\[Lambda]pTOnCheatNeutrinoFM[Tv_]:=IntegrateRatedp[IPENdpFMCheatNeutrinoTemperature,-1,Tv];


DetailedBalanceRatio0[T_]:=Exp[-(Q/(kB T))-\[Xi]\[Nu]];


DetailedBalance0[T_]:=(\[Lambda]nTOpBORN[T])/(\[Lambda]pTOnBORN[T])*DetailedBalanceRatio0[T];
DetailedBalanceCheatNeutrino0[T_]:=(\[Lambda]nTOpBORNCheatNeutrino[T])/(\[Lambda]pTOnBORNCheatNeutrino[T])*DetailedBalanceRatio0[T];


DetailedBalanceRatio[T_]:=Exp[-(Q/(kB T))-\[Xi]\[Nu]](1+(1+\[Alpha]) Q/mp)^(3/2);


IPENdpCCR[pe_,x_,znu_,sgnq_]:=IPENdpFrom\[Chi]CCR[enOFpe[pe,x],pe,x,If[$TnuEqualT,x,znu],sgnq,\[Chi]]


\[Lambda]nTOpCCR[Tv_]:=IntegrateRatedp[IPENdpCCR,1,Tv];
\[Lambda]pTOnCCR[Tv_]:=IntegrateRatedp[IPENdpCCR,-1,Tv];


BEQ[en_,sq_]:=sq BE[sq en];


\[Chi]tilde[en_,znu_,sgnq_]:=With[{q=Q/me },FD\[Nu][en-sgnq q,sgnq \[Xi]\[Nu],znu](en-sgnq q)^2]


IPENCCRT[en_,k_,x_,znu_,sgnq_]:=With[{p=Sqrt[en^2-1]},With[{b=p/en,A=(2 en^2+k^2)Log[(en+p)/(en-p)]-4 p en,B=2 en Log[(en+p)/(en-p)]-4p},
\[Alpha]FS/(2\[Pi])*(BE[x k]/k)*(A(FD[-en,x]Fermi[sgnq,1,b](\[Chi]tilde[en-k,znu,sgnq]+\[Chi]tilde[en+k,znu,sgnq]-2\[Chi]tilde[en,znu,sgnq])+FD[en,x]Fermi[sgnq,-1,b](\[Chi]tilde[-en+k,znu,sgnq]+\[Chi]tilde[-en-k,znu,sgnq]-2\[Chi]tilde[-en,znu,sgnq]))
-k B *(FD[-en,x]Fermi[sgnq,1,b](\[Chi]tilde[en-k,znu,sgnq]-\[Chi]tilde[en+k,znu,sgnq])+FD[en,x]Fermi[sgnq,-1,b](\[Chi]tilde[-en+k,znu,sgnq]-\[Chi]tilde[-en-k,znu,sgnq]))
)
]];

(* Compiled version to compute the integrals slightly faster *)
IPENCCRTC=MyCompile[{{en,_Real},{k,_Real},{x,_Real},{znu,_Real},{sgnq,_Integer}},Evaluate[IPENCCRT[en,k,x,znu,sgnq]]];IPENCCRTCN[en_?NumericQ,k_,x_,znu_,sgnq_]:=IPENCCRTC[en,k,x,znu,sgnq]


Clear[IPENCCRDiffBremsstrahlungCN,IPENCCRDiffBremsstrahlungC,IPENCCRDiffBremsstrahlung]
IPENCCRDiffBremsstrahlung[en_,k_,x_,znu_,sgnq_]:=With[{p=Sqrt[en^2-1],q=Q/me},With[{b=p/en,A=(2 en^2+k^2)Log[(en+p)/(en-p)]-4 p en,B=2 en Log[(en+p)/(en-p)]-4p},With[{Fp=A+k B,Fm=A-k B},
\[Alpha]FS/(2\[Pi] k) ((FD[-en,x]Fermi[sgnq,1,b](Fp \[Chi]tilde[en+k,znu,sgnq]-If[k<Abs[en-sgnq q],Fp FD[en-sgnq q,znu](Abs[en-sgnq q]-k)^2,0]))
+(FD[en,x]Fermi[sgnq,-1,b](Fm \[Chi]tilde[-en+k,znu,sgnq]-If[k<Abs[en+sgnq q],Fp FD[-en-sgnq q,znu](Abs[en+sgnq q]-k)^2,0]))
)
]]];

(* We compile for the integration *)
IPENCCRDiffBremsstrahlungC=MyCompile[{{en,_Real},{k,_Real},{x,_Real},{znu,_Real},{sgnq,_Integer}},Evaluate[IPENCCRDiffBremsstrahlung[en,k,x,znu,sgnq]]];IPENCCRDiffBremsstrahlungCN[en_?NumericQ,k_,x_,znu_,sgnq_]:=IPENCCRDiffBremsstrahlungC[en,k,x,znu,sgnq]


IPENFiveBodyT0[en_,k_,x_,znu_,sgnq_]:=With[{p=Sqrt[en^2-1]},With[{A=(2 en^2+k^2)Log[(en+p)/(en-p)]-4 p en,B=2 en Log[(en+p)/(en-p)]-4p},
\[Alpha]FS/(2\[Pi] k) (FD[en,x])\[Chi]tilde[-en+k,znu,sgnq](A-k B)]]


(* Compiled version *)
IPENFiveBodyT0C=Compile[{{en,_Real},{k,_Real},{x,_Real},{znu,_Real},{sgnq,_Integer}},Evaluate[With[{p=Sqrt[en^2-1]},With[{A=(2 en^2+k^2)Log[(en+p)/(en-p)]-4 p en,B=2 en Log[(en+p)/(en-p)]-4p},
\[Alpha]FS/(2\[Pi] k) (-BE[-k x])*(FD[en,x])\[Chi]tilde[-en+k,znu,sgnq](A-k B)]]],"RuntimeOptions"->"Speed",CompilationTarget->"C"];
IPENFiveBodyT0CN[en_?NumericQ,k_,x_,znu_,sgnq_]:=IPENFiveBodyT0C[en,k,x,znu,sgnq]


C1dE[en_,x_,znu_,sgnq_]:=With[{pe=Sqrt[en^2-1],q=Q/me },-((\[Alpha]FS en)/(2\[Pi] pe))*(2\[Pi]^2)/(3x^2) (\[Chi][en,pe,x,znu,sgnq]+\[Chi][-en,pe,x,znu,sgnq])];


C2dE1dE2[e1_,e2_,x_,znu_,sgnq_]:=With[{p1=Sqrt[e1^2-1],p2=Sqrt[e2^2-1],q=Q/me },With[{L=Log[(e1 e2 +p1 p2 +1)/(e1 e2 -p1 p2 +1)]},
\[Alpha]FS/(2\[Pi] ) (\[Chi][e1,p1,x,znu,sgnq]+\[Chi][-e1,p1,x,znu,sgnq])
*(-(1/4) Log[((p1+p2)/(p1-p2))^2]^2*(FDp[e2,x] p2/p1 e1^2/e2 (e1+e2)+FD[e2,x] e1^2/(p1 p2) (e2+e1/e2^2))
+Log[((p1+p2)/(p1-p2))^2](FDp[e2,x](p2^2 e1/e2 (1/p1^2+2)-e1^2 p2/p1 L)+FD[e2,x](e1/(p1^2 e2^2) (e2^2+2p1^2+1)-(e1^2+e2^2)/(e1+e2)-(e1^2 e2)/(p1 p2) L))
-FD[e2,x](4 e1 p2/p1+2 e2 L))
]];


(* Compiled version *)
C2dE1dE2C=Compile[{{e1,_Real},{e2,_Real},{x,_Real},{znu,_Real},{sgnq,_Integer}},Evaluate[With[{p1=Sqrt[e1^2-1],p2=Sqrt[e2^2-1],q=Q/me },With[{L=Log[(e1 e2 +p1 p2 +1)/(e1 e2 -p1 p2 +1)]},
\[Alpha]FS/(2\[Pi] ) (\[Chi][e1,p1,x,znu,sgnq]+\[Chi][-e1,p1,x,znu,sgnq])
*(-(1/4) Log[((p1+p2)/(p1-p2))^2]^2*(FDp[e2,x] p2/p1 e1^2/e2 (e1+e2)+FD[e2,x] e1^2/(p1 p2) (e2+e1/e2^2))
+Log[((p1+p2)/(p1-p2))^2](FDp[e2,x](p2^2 e1/e2 (1/p1^2+2)-e1^2 p2/p1 L)+FD[e2,x](e1/(p1^2 e2^2) (e2^2+2p1^2+1)-(e1^2+e2^2)/(e1+e2)-(e1^2 e2)/(p1 p2) L))
-FD[e2,x](4 e1 p2/p1+2 e2 L))
]]],"RuntimeOptions"->"Speed",CompilationTarget->"C"];
C2dE1dE2CN[e1_?NumericQ,e2_?NumericQ,x_,znu_,sgnq_]:=C2dE1dE2C[e1,e2,x,znu,sgnq];


\[Lambda]nTOpThermalTruePhoton[Tv_]:=(*\[Lambda]nTOpThermalTruePhoton[Tv]=*)With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[IPENCCRTCN[en,k,x,If[$TnuEqualT,x,znu],1],{k,0.001,Max[10,20/x]},{en,1.001,Max[10,20/x]},PrecisionGoal->4]
];

\[Lambda]nTOpThermalDiffBremsstrahlung[Tv_]:=(*\[Lambda]nTOpThermalDiffBremsstrahlung[Tv]=*)With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[IPENCCRDiffBremsstrahlungCN[en,k,x,If[$TnuEqualT,x,znu],1],{en,1.001,Max[10,20/x]},{k,0.001,Abs[en-q],Abs[en+q],Max[10,20/x]},PrecisionGoal->4]
];


\[Lambda]nTOpThermal[Tv_]:=(*\[Lambda]nTOpThermal[Tv]=*)With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[C1dE[en,x,If[$TnuEqualT,x,znu],1],{en,1,Max[25,150/x]}]
+NIntegrate[1/2C2dE1dE2CN[(e1pe2+e1me2)/2,(e1pe2-e1me2)/2,x,If[$TnuEqualT,x,znu],1],{e1me2,-Max[10,15/x],-0.001},{e1pe2,2.001+Abs[e1me2],2+Abs[e1me2]+Max[10,15/x]},PrecisionGoal->3,Exclusions->{0}]
+NIntegrate[1/2C2dE1dE2CN[(e1pe2+e1me2)/2,(e1pe2-e1me2)/2,x,If[$TnuEqualT,x,znu],1],{e1me2,0.001,Max[10,15/x]},{e1pe2,2.001+Abs[e1me2],2+Abs[e1me2]+Max[10,15/x]},PrecisionGoal->3]
];



\[Lambda]nTOp5bodies[Tv_]:=(*\[Lambda]nTOp5bodies[Tv]=*)With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[IPENFiveBodyT0CN[en,k,x,If[$TnuEqualT,x,znu],1],{en,1,Max[20,20/x]},{k,en+q,en+q+Max[20,20/x]},PrecisionGoal->4]
];


\[Lambda]pTOnThermalTruePhoton[Tv_]:=(*\[Lambda]pTOnThermalTruePhoton[Tv]=*)If[Tv<10^8.2 (* When the temperature is too low it is better to put 0 *),0,
With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[IPENCCRTCN[en,k,x,If[$TnuEqualT,x,znu],-1],{k,0.001,Max[10,20/x]},{en,1.001,Max[10,20/x]},PrecisionGoal->4]
]];

\[Lambda]pTOnThermalDiffBremsstrahlung[Tv_]:=(*\[Lambda]pTOnThermalDiffBremsstrahlung[Tv]=*)If[Tv<10^8.2 (* When the temperature is too low it is better to put 0 *),0,
With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[IPENCCRDiffBremsstrahlungCN[en,k,x,If[$TnuEqualT,x,znu],-1],{en,1.001,Max[10,20/x]},{k,0.001,Abs[en-q],Abs[en+q],Max[10,20/x]},PrecisionGoal->4]
]];


\[Lambda]pTOnThermal[Tv_]:=(*\[Lambda]pTOnThermal[Tv]=*)If[Tv<10^8.2 (* When the temperature is too low it is better to put 0 *),0,
With[{x=me/(kB Tv),znu=me/(kB Tv T\[Nu]overT[Tv]),q=Q/me },
NIntegrate[C1dE[en,x,If[$TnuEqualT,x,znu],-1],{en,1,Max[25,150/x]}]
+NIntegrate[1/2C2dE1dE2CN[(e1pe2+e1me2)/2,(e1pe2-e1me2)/2,x,If[$TnuEqualT,x,znu],-1],{e1me2,-Max[10,15/x],-0.001},{e1pe2,2.001+Abs[e1me2],2+Abs[e1me2]+Max[10,15/x]},PrecisionGoal->3]
+NIntegrate[1/2C2dE1dE2CN[(e1pe2+e1me2)/2,(e1pe2-e1me2)/2,x,If[$TnuEqualT,x,znu],-1],{e1me2,0.001,Max[10,15/x]},{e1pe2,2.001+Abs[e1me2],2+Abs[e1me2]+Max[10,15/x]},PrecisionGoal->3]
]];


\[Lambda]nTOpCCRTh[Tv_]:=(\[Lambda]nTOpThermal[Tv]+\[Lambda]nTOpThermalTruePhoton[Tv]+If[$CorrectionBremsstrahlung,\[Lambda]nTOpThermalDiffBremsstrahlung[Tv],\[Lambda]nTOp5bodies[Tv]]);

\[Lambda]pTOnCCRTh[Tv_]:=(\[Lambda]pTOnThermal[Tv]+\[Lambda]pTOnThermalTruePhoton[Tv]+If[$CorrectionBremsstrahlung,\[Lambda]pTOnThermalDiffBremsstrahlung[Tv],0]);


\[Lambda]0:=If[$RadiativeCorrections,\[Lambda]Rad,\[Lambda]BORN]+If[$FiniteNucleonMass,\[Lambda]FM,0]


Clear[\[Lambda]nTOp,\[Lambda]pTOn,\[Lambda]nTOpNormalized,\[Lambda]pTOnNormalized];
\[Lambda]nTOpNormalized[Tv_]:=(\[Lambda]0)^-1 (
If[$RadiativeCorrections,\[Lambda]nTOpCCR[Tv],\[Lambda]nTOpBORN[Tv]]
+If[$RadiativeThermal,\[Lambda]nTOpCCRTh[Tv],0]
+If[$FiniteNucleonMass,If[$CoupledFMandRC,\[Lambda]nTOpFMCCR[Tv],\[Lambda]nTOpFMNoCCR[Tv]],0]
);

\[Lambda]pTOnNormalized[Tv_]:=(\[Lambda]0)^-1 (
If[$RadiativeCorrections,\[Lambda]pTOnCCR[Tv],\[Lambda]pTOnBORN[Tv]]
+If[$RadiativeThermal,\[Lambda]pTOnCCRTh[Tv],0]
+If[$FiniteNucleonMass,If[$CoupledFMandRC,\[Lambda]pTOnFMCCR[Tv],\[Lambda]pTOnFMNoCCR[Tv]],0]);


Clear[\[Lambda]nTOp]
\[Lambda]nTOp[Tv_]:=1/\[Tau]neutron \[Lambda]nTOpNormalized[Tv];
\[Lambda]pTOn[Tv_]:=1/\[Tau]neutron \[Lambda]pTOnNormalized[Tv];


LetterFromBoolean[Bool_]:=If[Bool,"T","F"];
StringFromBoolean[BoolList_List]:=StringJoin[LetterFromBoolean/@BoolList];
BooleanSuffix=StringFromBoolean[{$RadiativeCorrections,$RadiativeThermal,$FiniteNucleonMass,$CoupledFMandRC,$QEDPlasmaCorrections,$IncompleteNeutrinoDecoupling}]


NamePENFilenp="Interpolations/PENRatenp"<>BooleanSuffix<>".dat";
NamePENFilepn="Interpolations/PENRatepn"<>BooleanSuffix<>".dat";


$BornBool=Not[$RadiativeThermal]&&Not[$RadiativeCorrections]&&Not[$FiniteNucleonMass];


MyTableWeakRate:=If[$ParallelWeakRates,ParallelEvaluate[Off[NIntegrate::slwcon];];ParallelTable,Table]

PreComputeWeakRates:=(
Off[NIntegrate::slwcon];
\[Lambda]nTOpTab=MyTableWeakRate[{T,\[Lambda]nTOpNormalized[T]},{T,ListT}];
\[Lambda]pTOnTab=MyTableWeakRate[{T,\[Lambda]pTOnNormalized[T]},{T,ListT}];
TabRatenp=\[Lambda]nTOpTab;
TabRatepn=\[Lambda]pTOnTab;
On[NIntegrate::slwcon];
\[Lambda]nTOpI=MyInterpolationRate[ToExpression[TabRatenp]];
\[Lambda]pTOnI=MyInterpolationRate[ToExpression[TabRatepn]];
);


TabRatenp=Check[Import[NamePENFilenp,"TSV"],Print["Precomputed n -> p rate not found. We recompute the rates and store them. This can take very long"];$Failed,Import::nffil];

TabRatepn=Check[Import[NamePENFilepn,"TSV"],Print["Precomputed p -> n rate not found. We recompute the rates and store them. This can take very long"];$Failed,Import::nffil];

Timing[If[TabRatenp===$Failed||TabRatepn===$Failed||$RecomputeWeakRates,
PreComputeWeakRates;
Export[NamePENFilenp,TabRatenp,"TSV"];
Export[NamePENFilepn,TabRatepn,"TSV"];,
\[Lambda]nTOpI=MyInterpolationRate[ToExpression[TabRatenp]];
\[Lambda]pTOnI=MyInterpolationRate[ToExpression[TabRatepn]];
];]


LnTOp[Tv_]:=1/\[Tau]neutron*\[Lambda]nTOpI[Tv];
LpTOn[Tv_]:=1/\[Tau]neutron*\[Lambda]pTOnI[Tv];
LbarnTOp[Tv_]:=LpTOn[Tv];


1/LnTOp[Tf]


(*

Off[NIntegrate::slwcon];
TabdlambdanTOp=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]nTOpThermal[T]+\[Lambda]nTOpThermalTruePhoton[T]+\[Lambda]nTOpThermalDiffBremsstrahlung[T]))/(\[Lambda]BORN*\[Lambda]nTOpBORN[T])},{T,ListTRange[1 10^9,10^11]}];
Print[TabdlambdanTOp];

TabdlambdapTOn=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]pTOnThermal[T]+\[Lambda]pTOnThermalTruePhoton[T]+\[Lambda]pTOnThermalDiffBremsstrahlung[T]))/(\[Lambda]BORN*\[Lambda]pTOnBORN[T])},{T,ListTRange[1 10^9,10^11]}];

Export["Interpolations/TabdlambdanTOp.dat",TabdlambdanTOp,"TSV"];
Export["Interpolations/TabdlambdapTOn.dat",TabdlambdapTOn,"TSV"];

TabdlambdanTOpBrown=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]nTOpThermal[T]+\[Lambda]nTOpThermalTruePhoton[T]))/(\[Lambda]BORN*\[Lambda]nTOpBORN[T])},{T,ListTRange[1 10^9,10^11]}];
TabdlambdanTOpBrown5Bodies=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]nTOpThermal[T]+\[Lambda]nTOpThermalTruePhoton[T]+\[Lambda]nTOp5bodies[T]))/(\[Lambda]BORN*\[Lambda]nTOpBORN[T])},{T,ListTRange[1 10^9,10^11]}];
TabdlambdapTOnBrown=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]pTOnThermal[T]+\[Lambda]pTOnThermalTruePhoton[T]))/(\[Lambda]BORN*\[Lambda]pTOnBORN[T])},{T,ListTRange[1 10^9,10^11]}];

Export["Interpolations/TabdlambdanTOpBrown.dat",TabdlambdanTOpBrown,"TSV"];
Export["Interpolations/TabdlambdanTOpBrown5Bodies.dat",TabdlambdanTOpBrown5Bodies,"TSV"];
Export["Interpolations/TabdlambdapTOnBrown.dat",TabdlambdapTOnBrown,"TSV"];

TabdlambdanTOpBrehm=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]nTOpThermalDiffBremsstrahlung[T]))/(\[Lambda]BORN*\[Lambda]nTOpBORN[T])},{T,ListTRange[1 10^9,10^11]}];
TabdlambdapTOnBrehm=MyTableWeakRate[{T,(\[Lambda]RadandFM*(\[Lambda]pTOnThermalDiffBremsstrahlung[T]))/(\[Lambda]BORN*\[Lambda]pTOnBORN[T])},{T,ListTRange[1 10^9,10^11]}];
On[NIntegrate::slwcon];


Export["Interpolations/TabdlambdanTOpBrehm.dat",TabdlambdanTOpBrehm,"TSV"];
Export["Interpolations/TabdlambdapTOnBrehm.dat",TabdlambdapTOnBrehm,"TSV"];*)


NamesWithWeightsAll={{"n",{1,0}},{"p",{0,1}},{"d",{1,1}},{"t",{2,1}},
{"He3",{1,2}},{"a",{2,2}},{"Li7",{4,3}},{"Be7",{3,4}}};


ShortNamesAll=NamesWithWeightsAll[[All,1]];


ListNPPairs=NamesWithWeightsAll[[All,2]];


ExistName[name_]:=MemberQ[ShortNamesAll,name];
ExistPair[pair_List]:=MemberQ[ListNPPairs,pair];


NamesMassNumberAll[A_]:=Select[NamesWithWeightsAll,((Plus@@(#[[2]]))==A)&][[All,1]]


KeySpecies=Association@(Rule@@@NamesWithWeightsAll)


KeyNucleons=Association@(Rule@@@(Reverse/@NamesWithWeightsAll))


Ni["Bm"]:=1;
Ni["Bp"]:=-1;
Ni["g"]:=0;

Zi["Bm"]:=-1;
Zi["Bp"]:=1;
Zi["g"]:=0;

Ai["Bm"]:=0;
Ai["Bp"]:=0;
Ai["g"]:=0;


Ni[key_]:=KeySpecies[key][[1]]
Zi[key_]:=KeySpecies[key][[2]]
Ai[key_]:=Zi[key]+Ni[key]


SpinFromCharList[charlist_List]:=StringReplace[StringJoin@@charlist,{"("->"",")"->"",","->"","+"->"","-"->""," "->"","#"->""}]
MassFromCharList[charlist_List]:=StringReplace[StringJoin@@charlist,{" "->"","#"->""}]


StringListParticles=#[[1]]&/@Import[(*"nubtab03.asc"*)"nubase2016.asc"];
NubTabChar=Select[Characters/@StringListParticles,Length[#]>=93&];


Alist=ToExpression/@StringJoin/@(Take[#,{1,3}]&/@NubTabChar);
Zlist=#/10&/@ToExpression/@StringJoin/@(Take[#,{5,8}]&/@NubTabChar);
MassExcessesString=MassFromCharList/@(Take[#,{20,29}]&/@NubTabChar);
Spins=SpinFromCharList/@(Take[#,{80,93}]&/@NubTabChar);
Nlist=Alist-Zlist;


MyGrid[ListNPBindingSpinName=Flatten[{KeyNucleons[{#[[1]],#[[2]]}],#}]&/@Select[Transpose[{Nlist,Zlist,MassExcessesString,Spins}],ExistPair[{#[[1]],#[[2]]}]&]]


ExcessMassKeys=Association[{#[[1]]->ToExpression[#[[4]]]}&/@ListNPBindingSpinName]


SpinKeys=Association[{#[[1]]->ToExpression[#[[5]]]}&/@ListNPBindingSpinName]


Eneutron:=ExcessMassKeys["n"];
Eproton:=ExcessMassKeys["p"];


BindingEnergy[name_]:=Module[{Pair,A,Z,N},
Pair=KeySpecies[name];
Z=Pair[[2]];
N=Pair[[1]];
A=Z+N;
N Eneutron +Z Eproton-ExcessMassKeys[name]]

Mass[name_]:=Module[{Pair,A,Z,N},
Pair=KeySpecies[name];
Z=Pair[[2]];
N=Pair[[1]];
A=Z+N;
A ma+keV ExcessMassKeys[name]-Z me]


BindingEnergy["n"]
BindingEnergy["p"]
BindingEnergy["d"]
BindingEnergy["a"]


YNSE[name_,Yn_,Yp_,Tv_]:=Module[{Pair,N,A,Z,mN,A32Overmn},
mN=(mn+mp)/2;
Pair=KeySpecies[name];
Z=Pair[[2]];
N=Pair[[1]];
A=Z+N;
A32Overmn=(Mass[name]/(mn^(A-Z)*mp^Z))^(3/2);
(2*SpinKeys[name]+1)Zeta[3]^(A-1) \[Pi]^((1-A)/2) 2^((3A-5)/2) A32Overmn (kB Tv)^(3(A-1)/2) (\[Eta]factorT[Tv])^(A-1) Yp^Z Yn^(A-Z) Exp[(BindingEnergy[name]*keV)/(kB Tv)]
]


Qreaction[ListIn_,ListOut_]:=Module[{Ni=Length@ListIn,Nf=Length@ListOut,factorin,factorout,Units},
factorin=Plus@@((BindingEnergy[#])&/@ListIn);
factorout=Plus@@((BindingEnergy[#])&/@ListOut);
Units=keV;
-Units(factorin-factorout)
];


PowerT9[ListIn_,ListOut_]:=Module[{Ni=Length@ListIn,Nf=Length@ListOut},
3/2.*(Ni-Nf)
];


FactorInverseReaction[ListIn_,ListOut_]:=Module[{Ni=Length@ListIn,Nf=Length@ListOut,factorin,factorout,Units},
factorin=Times@@((((2 SpinKeys[#[[1]]]+1)(2Pi/Mass[#[[1]]]/(kB 10^9))^(-3/2))^(#[[2]])/(#[[2]]!))&/@(Tally@ListIn));
factorout=Times@@((((2 SpinKeys[#[[1]]]+1)(2Pi/Mass[#[[1]]]/(kB 10^9))^(-3/2))^(#[[2]])/(#[[2]]!))&/@(Tally@ListOut));
Units=((ma/clight^2)/(hbar clight)^3)^(Ni-Nf);
factorin/ factorout Units
];


GatherInfoReac[ListIn_,ListOut_]:={Qreaction[ListIn,ListOut]/MeV,FactorInverseReaction[ListIn,ListOut],PowerT9[ListIn,ListOut],-Qreaction[ListIn,ListOut]/kB/10^9};

RemoveNonNuclear[Species_List]:=Select[Species,#=!="g"&&#=!="Bm"&&#=!="Bp"&];
InfoReaction[{ListIn_,ListOut_}]:=GatherInfoReac[RemoveNonNuclear@ListIn,RemoveNonNuclear@ListOut];
InfoReaction[ListIn_,ListOut_]:=InfoReaction[{ListIn,ListOut}]


CheckReaction[{ListIn_,ListOut_}]:=Module[{Znet,Nnet,Anet},
Znet=-Plus@@(Zi/@ListIn)+Plus@@(Zi/@ListOut);
Nnet=-Plus@@(Ni/@ListIn)+Plus@@(Ni/@ListOut);
Anet=-Plus@@(Ai/@ListIn)+Plus@@(Ai/@ListOut);
(*Print[ListIn," ",ListOut," ",Znet,Nnet,Anet];*)
If[Znet=!=0||Nnet=!=0||Anet=!=0,
Print["ERROR! This reaction ",ListIn," -> ",ListOut," is not possible.\nThe net result for Z, N and A are ",Znet," ",Nnet," ",Anet];
Print["We abort the evaluation !"];
Quit[];
(*TODO Maybe a better handling of errors than juts a violent Quit[]... *)
];
]

CheckReaction[ListIn_,ListOut_]:=CheckReaction[{ListIn,ListOut}]


Clear[TableRandom,MyNormalRandom]
$NRandomPoints = 1000; (* We put something larger than the max number of reactions *)
TableRandom[seed_]:=TableRandom[seed]=(SeedRandom[seed];Table[RandomVariate[NormalDistribution[]],{i,1,$NRandomPoints}])


InitializeRandom[seed_]:=(IndexRandom[seed]=1);
RandomFromTable[seed_]:=With[{r=TableRandom[seed][[IndexRandom[seed]]]},IndexRandom[seed]=IndexRandom[seed]+1;r]
MyNormalRandom[seed_]:=RandomFromTable[seed]


$Seed:=0;
Initialize[$Seed];
NormalRealisation:=If[$RandomNuclearRates,MyNormalRandom[$Seed],0];


ReverseReaction[Name_,FrontFactor_,PoweronT9_,Qoverkb_]:=With[{Reversname=ToExpression["Hold@Lbar"<>Name],name=Evaluate[Symbol["L"<>Name]]},
If[FrontFactor>0,
MySet[Reversname,Function[{Tvr},With[{T9=Tvr/Giga},FrontFactor (T9)^PoweronT9*Exp[Qoverkb/T9]*name[Tvr]]]];,
MySet[Reversname,Function[{Tvr},0]];
]];



TreatData[Data_]:=Module[{reac,constants,ReferencePaper,dat,rest,list,resultat,reacreshaped,replacements},
resultat={};
list=Data;

While[Length@list>0,
reac=list[[1]];
ReferencePaper=StringDrop[list[[2,1]],2];
(*Print[ReferencePaper];*)
(*Print[reac];*)
constants=list[[3]];
rest=Drop[list,3];
dat={};
While[rest=!={}&&NumericQ[rest[[1,1]]],
dat=Append[dat,rest[[1]]];
rest=Rest@rest;
];
list=rest;
reacreshaped=Append[{Select[reac,(#=!="+"&&#=!="*-")&],constants,ReferencePaper},dat];
resultat=Append[resultat,reacreshaped];
];
replacements={"He4"->"a"};
resultat/.replacements
];


TruncateRateVariation[rate_]:=Min[$MaxVariationRate,rate]


TreatReactionLine[line_]:=Module[{rescalefactor,reac,constants,interpfunction,data,len,table,Tmin,rmin,wedgeposition,colonposition,InitialParticles,FinalParticles,BoolenFileData,Q,FrontFactor,PoweronT9,Qoverkb,Name,Lname,rv,ReferencePaper,InfoFromAudi2017},
reac=line[[1]];
(*Print["Treating reaction : ",reac];*)
constants=line[[2]];
ReferencePaper=line[[3]];
data=line[[4]];

len=Length@line;
wedgeposition=Position[reac,">"][[1,1]];
colonposition=Position[reac,";"][[1,1]];
InitialParticles=Take[reac,{1,wedgeposition-1}];
FinalParticles=Take[reac,{wedgeposition+1,colonposition-1}];

(* We quit if the reaction does not conserve formally Z or N, that is if it cannot exist *)
CheckReaction[InitialParticles,FinalParticles];


Name=StringJoin@@ToString/@InitialParticles<>"TO"<>StringJoin@@ToString/@FinalParticles;

Q=constants[[1]];
FrontFactor=constants[[2]];
PoweronT9=constants[[3]];
Qoverkb=constants[[4]];


(* We check the constants used in reverse rates *)
InfoFromAudi2017=InfoReaction[InitialParticles,FinalParticles];
(*Print[InitialParticles," ",FinalParticles," ",InfoFromAudi2017];*)

If[Abs[FrontFactor/InfoFromAudi2017[[2]]-1]>0.001,Print[Name," WARNING. We use \[Alpha]=",FrontFactor," but we should use ",InfoFromAudi2017[[2]]]
];

If[Abs[Qoverkb/InfoFromAudi2017[[4]]-1]>0.001,
Print[Name, " WARNING. We use Q/\!\(\*SubscriptBox[\(k\), \(B\)]\)=",Qoverkb," but we should use ",InfoFromAudi2017[[4]]]
];

If[PoweronT9=!=InfoFromAudi2017[[3]],
Print[Name, " WARNING. We use power on T9 =",PoweronT9," but we should use ",InfoFromAudi2017[[3]]]
];
(* ****************)


(* *** *)
(*For exploration of parameters we can redefine some front factors to recales reactions. For instance the DPG reaction*)
(* Added on request of Antony Lewis *)

rescalefactor=1;
(*Print[Name,FullForm[Name]];*)

If[Name==="dpTOHe3g",
rescalefactor=dpTOHe3gFactor;
If[rescalefactor=!=1,Print["dpTOHe3g reaction is rescaled by ",dpTOHe3gFactor," New front factor is ",rescalefactor];];];
(* *** *)



table=Map[{Giga #[[1]],#[[2]]Hz,#[[3]]}&,data];
Tmin=Last[table][[1]];
rmin=Last[table][[2]];
Lname=ToExpression["Hold@L"<>Name];
rv=NormalRealisation;
MySet[Lname,MyInterpolationRate[{#[[1]],Identity[rescalefactor #[[2]]*
If[$RandomNuclearRates,TruncateRateVariation[#[[3]]^rv],1]]}&/@table]];
(* We do not rescale the reverse because it is computed FROM the forward rate. So rescaling the forward rate by rescalefactor rescales them both *)
ReverseReaction[Name,FrontFactor,PoweronT9,Qoverkb];

{Name,InitialParticles,FinalParticles,rv,ReferencePaper}

];

SetAttributes[TreatReactionLine,SequenceHold]


ListTWagoner={0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009,0.01,0.011,0.012,0.013,0.014,0.015,0.016,0.018,0.02,0.025,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.12,0.13,0.14,0.15,0.16,0.18,0.2,0.25,0.3,0.35,0.4,0.45,0.5,0.6,0.7,0.8,0.9,1.,1.25,1.5,1.75,2.,2.5,3.,3.5,4.,5.,6.,7.,8.,9.,10.}*10^9;


$ListTWagoner = False;


TableInterpolationTemperature=If[$ListTWagoner,ListTWagoner,ListTRange[0.9 Tf,10^10]];


SimplifyReactionStringRules={"+"->" + ",">"->" > ",";"->" ; ","2n"->" n + n ","2p"->" p + p ","2g"->" g + g ","2a"->" a + a ","He4"->" a "};

ReshapheReactionString[string_String]:=Select[StringSplit[StringReplace[string,SimplifyReactionStringRules]," "],(#=!="+"&&#=!="*-"&&#=!="")&];

TreatReactionString[reac_String,source_String,f_]:=Module[{reacshaped,wedgeposition,colonposition,InitialParticles,FinalParticles,Name},
reacshaped=ReshapheReactionString[reac];
wedgeposition=Position[reacshaped,">"][[1,1]];
colonposition=Position[reacshaped,";"][[1,1]];
InitialParticles=Take[reacshaped,{1,wedgeposition-1}];
FinalParticles=Take[reacshaped,{wedgeposition+1,colonposition-1}];

(* We check tha the reaction is possible, that is it should conserve N and Z*)
(* If not the case, the code will violently quit after spitting out warning messages.*)
CheckReaction[InitialParticles,FinalParticles];

Name=StringJoin@@ToString/@InitialParticles<>"TO"<>StringJoin@@ToString/@FinalParticles;
{Name,InitialParticles,FinalParticles,NormalRealisation,source,f}
]





PostTreatT9[var_,funT9_]:=If[$InterpolateAnalytics,
MyInterpolationRate[Table[{i,var MyChop[funT9[i/10^9]]},{i,TableInterpolationTemperature}]],
(var MyChop[funT9[#/10^9]])&];

GenRateT9[var_,funT9_]:=PostTreatT9[var,funT9];


DefineAnalyticRates:=
Module[{f,Var,Name,\[Lambda]Reac,\[Lambda]barReac,treatedreac,source,reac,analyticforward,AddReaction,initialparticles,finalparticles,InfoFromAudi2017,FrontFactor,Qoverkb,PoweronT9,forward},

(* Most recent implementation with automatic computation of reverse rate *)
AddReaction[reac_String,source_String,f_,ForwardT9_,BoolBackward_]:=(
treatedreac=TreatReactionString[reac,source,f];
Name=treatedreac[[1]];

(* Building the backward ratio *)
initialparticles=treatedreac[[2]];
finalparticles=treatedreac[[3]];
InfoFromAudi2017=InfoReaction[initialparticles,finalparticles];
(*Print[InitialParticles," ",FinalParticles," ",InfoFromAudi2017];*)
FrontFactor=InfoFromAudi2017[[2]];
Qoverkb=InfoFromAudi2017[[4]];
PoweronT9=InfoFromAudi2017[[3]];
(* End of building backward ratio *)

\[Lambda]Reac=ToExpression["Hold@L"<>Name];
\[Lambda]barReac=ToExpression["Hold@Lbar"<>Name];
Sow[treatedreac];
Var=f^treatedreac[[4]];

MySet[\[Lambda]Reac,GenRateT9[Var,ForwardT9]];
(*MySet[\[Lambda]barReac,GenRateT9[Var,BackwardT9 ]];*)
If[BoolBackward,
MySet[\[Lambda]barReac,GenRateT9[Var,(FrontFactor*#^PoweronT9*Exp[Qoverkb/#]*ForwardT9[#])& ]];,
MySet[\[Lambda]barReac,GenRateT9[0,0& ]];(* No backward reaction *)
];

treatedreac);


Reap[

(* This is where all extra analytic reactions must be listed.*)
(* TODO. Explain syntax better, but it si now rather transparent *)
(* For each reactions added analytically we need to specify a String source which is the paper in which it is found *)
(* Then we give a string reac which is the reaction considered.*)
(* The factor of incertainty for Monte-Carlo is then given*)
(* The analytic function forward[T9_], which is a function of T9 (that is the temperature in GK)*)
(* With all these definitions we call AddReaction. The last argument is a boolean. If True it computes also the reverse rate from detailed balance arguments, and if False it does not do so. This is essentially for pure decay reactions that there is no need to compute the reverse rates.*)

(**=======================================================================
Example of analytic reaction which is commented and not used
	   =======================================================================*)
Print["Adding analytic reactions"];
(*Uncomment from here to add the reaction 1*)
(*source="SourceName";
reac=" d + n  > t + g ; dng";
	   f=1.40;
forward[T9_]:=With[{T923=T9^(2/3)},(214. T9^0.075+7.42T9+T923)];
AddReaction[reac,source,f,forward,True];*)
(*End of analytic reaction 1 definition *)

(*Uncomment from here to add the reaction 2*)
(*source="SourceName";
reac=" d + n  > t + g ; dng";
	   f=1.40;
forward[T9_]:=With[{T923=T9^(2/3)},(214. T9^0.075+7.42T9+T923)];
AddReaction[reac,source,f,forward,True];*)
(*End of analytic reaction 2 definition *)

][[2,1]]

(* The output is the list of reactions in standard format (Name,List initial,List final,f factor) which is then used by the differential equation constructor *)

];


ReactionPEN={"nTOp",{"n"},{"p"},0,"Companion Paper"};
(* Format is name, List of initial particles, List of final particles, f factor for uncertainty*)

TabulatedReactions:=
(Select[SafeImport[TabulatedReactionsFile],(NumericQ[#[[1]]]||"*-"==#[[1]]||StringMatchQ[#[[1]],"\\*%"~~__])&]);
ReshapedTabulatedReactions:=TreatData[TabulatedReactions];


$TabulatedAnalyticReactions=False;
TabulatedReactionsAnalyticFile="BBNRatesFromAnalytic.dat";


LoadRates:=Module[{len},
len=Length@ReshapedTabulatedReactions;
ListReactionsFile=TreatReactionLine/@(Take[ReshapedTabulatedReactions,Min[NumberNuclearReactions,len]]);
(* If the number is larger than the file, we also dig into the analytic expressions *)
If [NumberNuclearReactions>len,

If[$TabulatedAnalyticReactions,

TabulatedReactionsAnalytic=Select[SafeImport[TabulatedReactionsAnalyticFile],(NumericQ[#[[1]]]||"*-"==#[[1]]||StringMatchQ[#[[1]],"\\*%"~~__])&];
ExtraAnalyticReactions=TreatReactionLine/@TreatData[TabulatedReactionsAnalytic];,

ExtraAnalyticReactions=DefineAnalyticRates;];

ListReactions=Take[Join[{ReactionPEN},ListReactionsFile,ExtraAnalyticReactions],NumberNuclearReactions+1],
ListReactions=Join[{ReactionPEN},ListReactionsFile]]
];


LoadRates;


SpeciesUpToMaximumMass[A_Integer]:=SpeciesUpToMaximumMass[A]=Union@@Table[NamesMassNumberAll[i],{i,A}];
ReactionUpToMaximumMass[A_Integer][Reaction_List]:=And@@(MemberQ[SpeciesUpToMaximumMass[A],#]&/@Flatten@Reaction[[2;;3]]);
ListReactionsUpToMass[A_Integer,ListReactions_List]:=Select[ListReactions,ReactionUpToMaximumMass[A][#]&];
ListReactionsUpToMass[Infinity,ListReactions_List]:=ListReactions;
ListReactionsUpToChosenMass:=ListReactionsUpToMass[MaximumNuclearMass,ListReactions];


ReactionWithArrow[name_String]:=StringReplace[name,"TO"->" -> "]
NiceDisplayReaction[reaction_List]:=Join[{ReactionWithArrow[First[reaction]]},Rest[reaction]]


ListReactionsNames=ListReactionsUpToChosenMass[[All,1]];


ListNuclearReactionsNames=Select[ListReactionsNames,#=!="nTOp"&];


KeyNuclearReaction=Association[#->Position[ListNuclearReactionsNames,#][[1,1]]&/@ListNuclearReactionsNames];
KeyReaction=Association[#->Position[ListReactionsNames,#][[1,1]]&/@ListReactionsNames];


VariablesInEquations=Union@Flatten[Join[RemoveNonNuclear[#[[2]]],RemoveNonNuclear[#[[3]]]]&/@ListReactionsUpToChosenMass]


NumberVariable=Length@VariablesInEquations


NamesWithWeights=Select[NamesWithWeightsAll,MemberQ[VariablesInEquations,#[[1]]]&]


WeightsNuclear=(Plus@@(#[[2]]))&/@NamesWithWeights


NamesMassNumber[A_]:=Select[NamesWithWeights,((Plus@@(#[[2]]))==A)&][[All,1]]
NamesAtomicNumber[Z_]:=Select[NamesWithWeights,(#[[2,2]]==Z)&][[All,1]]


StackY[name_]:="Y"<>ToString[name];


YName[PostString_][n_,p_]:=ToExpression@StackY["n"<>ToString[n]<>"p"<>ToString[p]<>PostString];
ShortString[nameshort_,np_List]:=(Evaluate@ToExpression["Y"<>nameshort]:=YName[""]@@np;);


ShortString@@@NamesWithWeights;


ShortNames=NamesWithWeights[[All,1]]
KeyVal=Association[#->Position[ShortNames,#][[1,1]]&/@ShortNames]


VarList=ToExpression/@(StackY/@ShortNames)


SetTimeDependence[list_List,tv_]:=#[tv]&/@list;


FunList[tv_]=SetTimeDependence[VarList,tv]
FunPrimeList[tv_]=FunList'[tv]


KeyQ[key_]:=MemberQ[NamesWithWeightsAll[[All,1]],key];

YHT[key_?KeyQ][t_]:=Y["HT"][key][t];
YMT[key_?KeyQ][t_]:=Y["MT"][key][t];
YLT[key_?KeyQ][t_]:=Y["LT"][key][t];


YPeriodTime[period_String][tv_]:=Y[period][#][tv]&/@ShortNames;


NumericalValueOrThermalEquilibriumValue[period_,ListThermal_,name_,Tv_,tv_]:=
Module[{Yv=Y[period][name][tv],Yn=Y[period]["n"][tv],Yp=Y[period]["p"][tv]},
If[ MemberQ[ListThermal,name],YNSE[name,Yn,Yp,Tv],Yv]];


YPeriodTimeOrStateEquilibrium[period_String,ListThermal_List][Tv_,tv_]:=NumericalValueOrThermalEquilibriumValue[period,ListThermal,#,Tv,tv]&/@ShortNames;


FillReactionMatrix[listreac_List]:=Module[{Tab,i,j,nvar,TreatReaction,FactorInitialElements},
nvar=Length@VarList;
Tab=Table[0,{ii,1,nvar}];
FactorInitialElements[el_List]:=Times@@((A\[Rho]B/DensityUnit Y[KeyVal[#[[1]]]])^#[[2]]/(#[[2]]!)&/@el);
TreatReaction[reaction_List]:=Module[{
InitialParticles=Tally[RemoveNonNuclear@reaction[[2]]],
FinalParticles=Tally[RemoveNonNuclear@reaction[[3]]],
ReactionForward,ReactionBackward,FactorInitialForward,FactorInitialBackward},

ReactionForward=L[KeyReaction[reaction[[1]]]];
ReactionBackward=Lbar[KeyReaction[reaction[[1]]]];
FactorInitialForward=FactorInitialElements@InitialParticles;(* This computes the product Subscript[Y, i]^ni/ni! for initial particles*)
FactorInitialBackward=FactorInitialElements@FinalParticles;

(Tab[[KeyVal[#[[1]]]]]=Tab[[KeyVal[#[[1]]]]]-ReactionForward FactorInitialForward #[[2]]/A\[Rho]B*DensityUnit)&/@InitialParticles;
(Tab[[KeyVal[#[[1]]]]]=Tab[[KeyVal[#[[1]]]]]+ReactionForward FactorInitialForward #[[2]]/A\[Rho]B*DensityUnit)&/@FinalParticles;
(Tab[[KeyVal[#[[1]]]]]=Tab[[KeyVal[#[[1]]]]]-ReactionBackward FactorInitialBackward #[[2]]/A\[Rho]B*DensityUnit)&/@FinalParticles;
(Tab[[KeyVal[#[[1]]]]]=Tab[[KeyVal[#[[1]]]]]+ReactionBackward FactorInitialBackward #[[2]]/A\[Rho]B*DensityUnit)&/@InitialParticles;
];
TreatReaction/@listreac;
Tab
]


FormalReactions=FillReactionMatrix@ListReactionsUpToChosenMass;


NReactionsSmallNetwork=Min[NumberNuclearReactions+1,18];
FormalReactions18=FillReactionMatrix@Take[ListReactionsUpToChosenMass,Min[NReactionsSmallNetwork,Length@ListReactionsUpToChosenMass]];


WeightsNuclear.FormalReactions//Simplify


FormalReactionsOnlyPEN=FillReactionMatrix[{ReactionPEN}];


Yi:=Y[KeyVal[#]]&/@ShortNames;

RulesY[tv_]:=Thread[Rule[Yi,FunList[tv]]];


Li=L[KeyReaction[[#]]]&/@ListReactionsNames;
Lbari=Lbar[KeyReaction[[#]]]&/@ListReactionsNames;



Rules\[Lambda]RHS[Tv_]:=Symbol["L"<>#][Tv]&/@ListReactionsNames;
Rules\[Lambda]RHS[n_,Tv_]:=Symbol["L"<>#][Tv]&/@Take[ListReactionsNames,n];

Rules\[Lambda]barRHS[Tv_]:=Symbol["Lbar"<>#][Tv]&/@ListReactionsNames;
Rules\[Lambda]barRHS[n_,Tv_]:=Symbol["Lbar"<>#][Tv]&/@Take[ListReactionsNames,n];

Rules\[Lambda][Tv_]:=Thread[Rule[Li,Rules\[Lambda]RHS[Tv]]];
Rules\[Lambda]bar[Tv_]:=Thread[Rule[Lbari,Rules\[Lambda]barRHS[Tv]]];


DYOnlyPEN[Temp_,\[Rho]B_,time_]:=(FormalReactionsOnlyPEN)/.Dispatch@Rules\[Lambda][Temp]/.Dispatch@Rules\[Lambda]bar[Temp]/.Dispatch@RulesY[time]/.A\[Rho]B->\[Rho]B;

DY18[Temp_,\[Rho]B_,time_]:=(FormalReactions18)/.Dispatch@Rules\[Lambda][Temp]/.Dispatch@Rules\[Lambda]bar[Temp]/.Dispatch@RulesY[time]/.A\[Rho]B->\[Rho]B;

DY[Temp_,\[Rho]B_,time_]:=(FormalReactions)/.Dispatch@Rules\[Lambda][Temp]/.Dispatch@Rules\[Lambda]bar[Temp]/.Dispatch@RulesY[time]/.A\[Rho]B->\[Rho]B;



CompileFromFormal[FormalReactions_List]:=ReleaseHold[Hold[Compile[{{A\[Rho]B,_Real},{L,_Real,1},{Lbar,_Real,1},{Y,_Real,1}},inside,CompilationTarget->"C","RuntimeOptions"->"Speed",CompilationOptions->{"InlineExternalDefinitions"->True}]]//.{inside->FormalReactions,Y[m_]:>Y[[m]],L[m_]:>L[[m]],Lbar[m_]:>Lbar[[m]]}]


Timing[If[$CompileNDSolve,
DYC=CompileFromFormal[FormalReactions];
DY18C=CompileFromFormal[FormalReactions18];
DYCN[A\[Rho]B_?NumericQ,L_,Lbar_,Y_]:=DYC[A\[Rho]B,L,Lbar,Y];
DY18CN[A\[Rho]B_?NumericQ,L_,Lbar_,Y_]:=DY18C[A\[Rho]B,L,Lbar,Y];
];]


\[Rho]\[Nu][T_]:=If[$IncompleteNeutrinoDecoupling,\[Rho]\[Nu]IncompleteDecoupling[a[T]],\[Rho]\[Nu]Decoupling[T]];



\[Rho]tot1[T_]:=(aBB (kB T)^4 (1+D\[Rho]T[T])+\[Rho]\[Nu][T]
+nbaryons0 (mbaryon0*(1+h2\[CapitalOmega]c0/h2\[CapitalOmega]b0)+3/2 (kB T))/(clight)^2/(a[T])^3);

\[Rho]tot2[T_]:=(aBB (kB T)^4 (1+7/8 Nneu (T\[Nu]overT[T])^4+D\[Rho]T[T])
+nbaryons0 (mbaryon0*(1+h2\[CapitalOmega]c0/h2\[CapitalOmega]b0)+3/2 (kB T))/(clight)^2/(a[T])^3);


\[Rho]tot[T_]:=\[Rho]tot1[T];


H[a_]:=((8\[Pi] GN)/3 \[Rho]tot[Tofa[a]])^(1/2);


Computetofa:=(tofa=NDSolveValue[{tv'[av]==1/(av H[av]),tv[a[Ti]]==1/(2H[a[Ti]])},tv,{av,a[Ti],a[Tf]},PrecisionGoal->8,AccuracyGoal->10];)


Computeaoft:=(aoft=NDSolveValue[{av'[tv]==1/tofa'[av[tv]],av[tofa@a[Ti]]==a[Ti]},av,{tv,tofa@a[Ti],tofa@a[Tf]},PrecisionGoal->75,AccuracyGoal->20];)


Toft[tv_]:=Tofa[aoft[tv]];


Yni[Tv_]:=1/(1+(1-3/2 Q/mn )Exp[Q/(kB Tv)]);
Ypi[Tv_]:=1-Yni[Tv];


Yn2i[Tv_]:=LpTOn[Tv]/(LpTOn[Tv]+LnTOp[Tv]);
Yp2i[Tv_]:=1-Yn2i[Tv];


CIList[Tv_]:=Table[Which[i==1,Yni[Tv],i==2,Ypi[Tv],i>=3,0],{i,1,NumberVariable}]


DefineEquations:=(

(*We build the differential system for the High temperatures *)
(* So we associate the r.h.s which is constructed thanks to DYOnlyPEN, with the l.h.s made of abundances derivatives *)
SystemEquationsHT[tv_]=Thread[Equal[FunPrimeList[tv],(DYOnlyPEN[Tv,\[Rho]Bv,tv](*/.Dispatch@ReactionProbabilities*))]]/.{Tv->Toft@tv,\[Rho]Bv->\[Rho]BForBBN@a@Toft@tv};

(* For middle and low temperature we distinguish between the compiled and the uncompiled method *)

If[$CompileNDSolve,

(* If $CompileNDSolve=True, we reinterpolate the rates for the middle and the low temperatures. *)
(* The system is a matrix system in this case and it is built directly in NDSolve below *)
Rules\[Lambda]RHSI=MyInterpolationRate@Table[{Tv,MyChop@Rules\[Lambda]RHS[Tv]},{Tv,ListTRange[Tf,T18]}];
Rules\[Lambda]barRHSI=MyInterpolationRate@Table[{Tv,MyChop@Rules\[Lambda]barRHS[Tv]},{Tv,ListTRange[Tf,T18]}];
       Rules\[Lambda]RHS18I=MyInterpolationRate@Table[{Tv,Rules\[Lambda]RHS[NReactionsSmallNetwork,Tv]},{Tv,ListTRange[T18,TMiddle]}];
Rules\[Lambda]barRHS18I=MyInterpolationRate@Table[{Tv,Rules\[Lambda]barRHS[NReactionsSmallNetwork,Tv]},{Tv,ListTRange[T18,TMiddle]}];,

(* If $CompileNDSolve=False, we (re-)define the systems of equations for Middle and Low temperatures*)
(* We associate the r.h.s formed thanks to DY18 and DY, with the l.h.s made of derivatives *)
SystemEquationsMT[tv_]=Thread[Equal[FunPrimeList[tv],(DY18[Tv,\[Rho]Bv,tv])]]/.{Tv->Toft@tv,\[Rho]Bv->\[Rho]BForBBN@a@Toft@tv};
SystemEquationsLT[tv_]=Thread[Equal[FunPrimeList[tv],(DY[Tv,\[Rho]Bv,tv])]]/.{Tv->Toft@tv,\[Rho]Bv->\[Rho]BForBBN@a@Toft@tv};
]
)


t0:=tofa@a[Tstart];
tmiddle:=tofa@a[TMiddle];
t18:=tofa@a[T18];
tend:=tofa@a[Tend];


{t0,tmiddle,t18,tend}


HoldYNames[period_String]:=ToExpression/@("Hold@Y[\""<>period<>"\"][\""<>#<>"\"]"&/@ShortNames);


InitialConditionsHT[tv_]:=Thread[Equal[FunList[tv],CIList[Toft[tv]]]];


SolveValueHighTemperatures:=(Thread[MySet[Evaluate[HoldYNames["HT"]],
NDSolveValue[
Flatten@Join[SystemEquationsHT[tv],InitialConditionsHT[t0]],
VarList,{tv,t0,tmiddle},
PrecisionGoal->8+PrecisionNDSolve,AccuracyGoal->11,InterpolationOrder->InterpOrder]]];
tHT=Y["HT"]["n"][[3,1]];
);


ListThermalValuesMT={"d","t","He3","a","Be7","Li7"};
ListThermalValuesUsedMT=Intersection[VariablesInEquations,ListThermalValuesMT]


YPeriodTimeOrStateEquilibrium["HT",ListThermalValuesUsedMT][TMiddle,tmiddle]


InitialConditionsMT[Tv_,tv_]:=Thread[Equal[FunList[tv],YPeriodTimeOrStateEquilibrium["HT",ListThermalValuesUsedMT][Tv,tv]]];


SolveValueMiddleTemperatures:=(If[$CompileNDSolve,
(* Compiled version.*)
resMT=NDSolveValue[
{Ytab'[tv]==DY18CN[\[Rho]BForBBN@a@Toft@tv,Rules\[Lambda]RHS18I[Toft@tv],Rules\[Lambda]barRHS18I[Toft@tv],Ytab[tv]],Ytab[tmiddle]==YPeriodTimeOrStateEquilibrium["HT",ListThermalValuesUsedMT][TMiddle,tmiddle]},
Ytab,{tv,tmiddle,t18},
Method->{"BDF","MaxDifferenceOrder"->$BDFOrder},
PrecisionGoal->7+PrecisionNDSolve,AccuracyGoal->11,
InterpolationOrder->InterpOrder,Compiled->Automatic];
Y["MT"][key_][tv_?NumericQ]:=resMT[tv][[KeyVal[key]]];
tMT=resMT[[3,1]];,

(* Non compiled version. Slightly slower *)
Thread[MySet[Evaluate[HoldYNames["MT"]],NDSolveValue[
Flatten@Join[SystemEquationsMT[tv],InitialConditionsMT[TMiddle,tmiddle]],
VarList,{tv,tmiddle,t18},
Method->{"BDF","MaxDifferenceOrder"->$BDFOrder},
PrecisionGoal->7+PrecisionNDSolve,AccuracyGoal->11,
InterpolationOrder->InterpOrder,Compiled->False]]];
tMT=Y["MT"]["n"][[3,1]];
]);


InitialConditionsLT[tv_]:=Thread[Equal[FunList[tv],YPeriodTime["MT"][tv]]];


SolveValueLowTemperatures:=(If[$CompileNDSolve,
(* Compiled version*)
resLT=NDSolveValue[
{Ytab'[tv]==DYCN[\[Rho]BForBBN@a@Toft@tv,Rules\[Lambda]RHSI[Toft@tv],Rules\[Lambda]barRHSI[Toft@tv],Ytab[tv]],
Ytab[t18]==YPeriodTime["MT"][t18]},
Ytab,{tv,t18,tend},
Method->{"BDF","MaxDifferenceOrder"->$BDFOrder},
PrecisionGoal->5+PrecisionNDSolve,AccuracyGoal->AccuracyNDSolve,
InterpolationOrder->InterpOrder,StartingStepSize->10^-4,MaxStepSize->500];
Y["LT"][key_][tv_?NumericQ]:=resLT[tv][[KeyVal[key]]];
tLT=resLT[[3,1]];,

(* Uncompiled version. Slower. *)
Thread[MySet[Evaluate[HoldYNames["LT"]],NDSolveValue[
Flatten@Join[SystemEquationsLT[tv],InitialConditionsLT[t18]],
VarList,{tv,t18,tend},
Method->{"BDF","MaxDifferenceOrder"->$BDFOrder,"EquationSimplification"->"Solve"},
PrecisionGoal->5+PrecisionNDSolve,AccuracyGoal->AccuracyNDSolve,
InterpolationOrder->InterpOrder,StartingStepSize->10^-4]]];
tLT=Y["LT"]["n"][[3,1]];
];)


InterpolateResults=(
Clear[Yall,YI];
Yall[key_?KeyQ]:=Yall[key]=Function[{tv},Piecewise[{{Y["HT"][key][tv],tv<tmiddle},{Y["MT"][key][tv],tv<t18&&tv>=tmiddle},{Y["LT"][key][tv],tv<=tend&&tv>=t18}}]];

YI[key_?KeyQ]:=YI[key]=Interpolation[Table[{tv,Yall[key][tv]},{tv,Join[tHT,Rest@tMT,Rest@tLT]}],InterpolationOrder->1];);


RunNumericalIntegralsNuclearReactions:=(
(* Middle temperature integration *)
SolveValueMiddleTemperatures;

(* Low temperature integration *)
SolveValueLowTemperatures;
);


RunNumericalIntegrals:=(

(* In case of incomplete neutrino decoupling, we recompute all the integrations a(T) then inversion T(a), then Subscript[\[Rho], \[Nu]](a).*)
If[$IncompleteNeutrinoDecoupling,RecomputeIncompleteNeutrinoDecoupling;];

(*In case the plasma conditions have changed in a MC exploration, we recompute the inversion of a[T]*)
(* This is needed if we have recomputed the neutrino decoupling, but I am wondering if this is always needed. *)
InvertaOFT;

(* scale factor integration from Friedmann equation. *)
Computetofa;
Computeaoft;

(* Build equations. Needed since rate are modified randomly by the f factor of each reaction*)
LoadRates;
DefineEquations;

(* High temperature integration with only PEN reactions *)
SolveValueHighTemperatures;

(* Middle and Low temperature WITH nuclear reactions*)
RunNumericalIntegralsNuclearReactions;

InterpolateResults;
);


XI[key_?KeyQ][t_]:=Ai[key]YI[key][t]


Yf[key_]:=YLT[key][tend]
Xf[key_]:=Ai[key]Yf[key]


YfH[key_]:=Yf[key]/Yf["p"]


MyTickst={{Automatic,Automatic},{Automatic,{{tofa@a[10^11],"\!\(\*SuperscriptBox[\(10\), \(11\)]\)K"},{tofa@a[10^10.5],"\!\(\*SuperscriptBox[\(10\), \(10.5\)]\)K"},{tofa@a[10^10],"\!\(\*SuperscriptBox[\(10\), \(10\)]\)K"},{tofa@a[10^9.5],"\!\(\*SuperscriptBox[\(10\), \(9.5\)]\)K"},{tofa@a[10^9],"\!\(\*SuperscriptBox[\(10\), \(9\)]\)K"},{tofa@a[10^8.5],"\!\(\*SuperscriptBox[\(10\), \(8.5\)]\)K"},{tofa@a[10^8],"\!\(\*SuperscriptBox[\(10\), \(8\)]\)K"}}}};


$ParallelBool=True;
$Random\[Tau]neutron=True;
$Randomh2\[CapitalOmega]b=True;


InitializeKernels:=(
LaunchKernels[];
Print["Number of Kernels ",$KernelCount];
DistributeDefinitions[ReshapedTabulatedReactions,ListReactionsUpToChosenMass,LoadRates,DefineEquations,SystemEquationsHT,SystemEquationsMT,SystemEquationsLT,LoadRates,DY,DY18,DYOnlyPEN,LbarnTOp,LnTOp];
);


RunPRIMATMonteCarlo[number_]:=Module[{res,time,Abundances,mytabfunctions,sss,RandomVariables,CosmoParametersList},
If[number>1,Print["Running a Monte-Carlo with ",number, " points."];];
Off[CompiledFunction::cfta];
mytabfunctions=If[$ParallelBool,ParallelTable,Table];
If[$ParallelBool,InitializeKernels;
ParallelEvaluate[$HistoryLength=0;]];

(* We always use the same seed so that we always use the same sequence of random number as advocated in [Cyburt et al. 2015].*)

res=mytabfunctions[
$Seed:=i;(* We use a different seed so that for each MC point we have a different sequence of reaction rates *)
InitializeRandom[$Seed];(* We restart our random list from the beginning *)

h2\[CapitalOmega]b0=Meanh2\[CapitalOmega]b0+If[$Randomh2\[CapitalOmega]b,\[Sigma]h2\[CapitalOmega]b0 NormalRealisation,0];
\[Tau]neutron=Mean\[Tau]neutron+If[$Random\[Tau]neutron,\[Sigma]\[Tau]neutron NormalRealisation,0];
CosmoParametersList={h2\[CapitalOmega]b0,\[Tau]neutron};

time=AbsoluteTiming[RunNumericalIntegrals][[1]];
RandomVariables=Rest@ListReactionsUpToChosenMass[[All,4]];
Share[];
Print["Iteration ",i, "  Memory usage = ",MemoryInUse[]," time = ",time, "  Kernel : ",$KernelID];
Abundances=YPeriodTime["LT"][tend];
ClearSystemCache[];
If[$Verbose,Print[Abundances(*," ",RandomVariables*)]];
{Abundances,RandomVariables,CosmoParametersList},{i,1,number}];
If[$ParallelBool,CloseKernels[]];

h2\[CapitalOmega]b0=Meanh2\[CapitalOmega]b0;
\[Tau]neutron=Mean\[Tau]neutron;
MC=res[[All,1]];
RV=res[[All,2]];
Cosmo=res[[All,3]];

res];

RunPRIMAT:=RunPRIMATMonteCarlo[1];


Clear[LoadMC,DumpMC]


DumpMC[File_String]:=(
Print["Exporting ","MonteCarlo/MC"<>File<>".dat"];
Export["MonteCarlo/MC"<>File<>".dat",MC];

Print["Exporting ","MonteCarlo/RV"<>File<>".dat"];
Export["MonteCarlo/RV"<>File<>".dat",RV];

Print["Exporting ","MonteCarlo/Cosmo"<>File<>".dat"];
Export["MonteCarlo/Cosmo"<>File<>".dat",Cosmo];);

LoadMC[File_String]:=(
MCfile="MonteCarlo/MC"<>File<>".dat";
RVfile="MonteCarlo/RV"<>File<>".dat";
Cosmofile="MonteCarlo/Cosmo"<>File<>".dat";
        MC=Import[MCfile];
RV=Import[RVfile];
Cosmo=Import[Cosmofile];
TMC=Transpose[MC];
);


ElementColumn[el_]:=MC[[All,KeyVal[[el]]]];
ReactionColumn[el_]:=RV[[All,KeyNuclearReaction[el]]];
h2\[CapitalOmega]b0List:=Cosmo[[All,1]];
\[Tau]neutronList:=Cosmo[[All,2]];
