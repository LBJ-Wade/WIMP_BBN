(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Print["[PrimiNuc]: Setting up options"];
timingStartNuc = AbsoluteTime[];


SetDirectory[NotebookDirectory[]]


Print["[PrimiNuc]: The current Directory is ", Directory[]]


(* ::Input::Initialization:: *)
TabulatedReactionsFile="BBNRatesAlainCoc2018.dat";
NumberNuclearReactions=12;


(* ::Input::Initialization:: *)
MaximumNuclearMass=Infinity; 


(* ::Input::Initialization:: *)
$RandomNuclearRates=False;
$MaxVariationRate=1000;


(* ::Input::Initialization:: *)
dpTOHe3gFactor=1;


(* ::Input::Initialization:: *)
Meanh2\[CapitalOmega]b0Planck=0.02225;(*[Planck 2015 XIII TT and ET and EE]*)
\[Sigma]h2\[CapitalOmega]b0Planck=0.00016;(* Standard deviation*)


(* ::Input::Initialization:: *)
Meanh2\[CapitalOmega]b0=Meanh2\[CapitalOmega]b0Planck; 
\[Sigma]h2\[CapitalOmega]b0=\[Sigma]h2\[CapitalOmega]b0Planck;
(*h2\[CapitalOmega]b0=Meanh2\[CapitalOmega]b0;*)
Print["[PrimiNuc]: \!\(\*SubscriptBox[\(\[CapitalOmega]\), \(b, 0\)]\)\!\(\*SuperscriptBox[\(h\), \(2\)]\) = ", h2\[CapitalOmega]b0]


(* ::Input::Initialization:: *)
ma = 931.494061 MeV;(* Audi2012 *)
He4Overma=4.0026032541; (* Audi2012 *)
H1Overma=1.00782503223; (* Audi2012 *)  


(* ::Input::Initialization:: *)
Subscript[x, He4]=0.24709 ;(* Chemical composition at the end of BBN. In principle one should account for He4 produced by stars...*)
Subscript[x, H1]=1-Subscript[x, He4];
mbaryon0=(Subscript[x, H1]H1Overma+Subscript[x, He4]He4Overma/4)ma;


mbaryon0/ma
ma/mbaryon0


(He4Overma/4-H1Overma)/H1Overma
%*Subscript[x, He4]


(* ::Input::Initialization:: *)
\[Rho]B0 :=h2\[CapitalOmega]b0*\[Rho]crit100;


(* ::Input::Initialization:: *)
nbaryons0:=\[Rho]B0 /(mbaryon0/(clight)^2)


(* ::Input::Initialization:: *)
nbaryons0/Subscript[n, CMB0]


(* ::Input::Initialization:: *)
\[CapitalOmega]bh2Over\[Eta]:=Subscript[n, CMB0]/\[Rho]crit100 mbaryon0/(clight)^2


\[CapitalOmega]bh2Over\[Eta]


(* ::Input::Initialization:: *)
\[Eta]factor:=h2\[CapitalOmega]b0/\[CapitalOmega]bh2Over\[Eta]


(* ::Input::Initialization:: *)
\[Rho]B[av_]:=\[Rho]B0 /av^3;
nB[av_]:=nbaryons0 /av^3;


(* ::Input::Initialization:: *)
$CorrectBaryonsEnergyDensityinBBNRRates=True;
\[Rho]BForBBN[av_]:=\[Rho]B[av]If[$CorrectBaryonsEnergyDensityinBBNRRates,ma/mbaryon0,1];(* This is Eq. C8 of the companion paper *)


(* ::Input::Initialization:: *)
\[Eta]factorT[Tv_]:=nB[a[Tv]]*\[Pi]^2/(2Zeta[3]) ((hbar clight)/(kB Tv))^3;


Print["[PrimiNuc]: Defining reaction network"]


(* ::Input::Initialization:: *)
NamesWithWeightsAll={{"n",{1,0}},{"p",{0,1}},{"d",{1,1}},{"t",{2,1}},
{"He3",{1,2}},{"a",{2,2}},{"He5",{3,2}},{"He6",{4,2}},
{"Li6",{3,3}},{"Li7",{4,3}},{"Li8",{5,3}},{"Li9",{6,3}},
{"Be7",{3,4}},{"Be8",{4,4}},{"Be9",{5,4}},{"Be10",{6,4}},{"Be11",{7,4}},{"Be12",{8,4}},
{"B8",{3,5}},{"B9",{4,5}},{"B10",{5,5}},{"B11",{6,5}},{"B12",{7,5}},{"B13",{8,5}},{"B14",{9,5}},{"B15",{10,5}},
{"C9",{3,6}},{"C10",{4,6}},{"C11",{5,6}},{"C12",{6,6}},{"C13",{7,6}},{"C14",{8,6}},{"C15",{9,6}},{"C16",{10,6}},
{"N12",{5,7}},{"N13",{6,7}},{"N14",{7,7}},{"N15",{8,7}},{"N16",{9,7}},{"N17",{10,7}},
{"O13",{5,8}},{"O14",{6,8}},{"O15",{7,8}},{"O16",{8,8}},{"O17",{9,8}},{"O18",{10,8}},{"O19",{11,8}},{"O20",{12,8}},
{"F17",{8,9}},{"F18",{9,9}},{"F19",{10,9}},{"F20",{11,9}},
{"Ne18",{8,10}},{"Ne19",{9,10}},{"Ne20",{10,10}},{"Ne21",{11,10}},{"Ne22",{12,10}},{"Ne23",{13,10}},
{"Na20",{9,11}},{"Na21",{10,11}},{"Na22",{11,11}},{"Na23",{12,11}}};


TableNZNucleons=Table[" ",{i,0,13},{j,0,11}];
Map[(TableNZNucleons[[Sequence@@(#[[2]]+{1,1})]]=#[[1]])&,NamesWithWeightsAll];


Grid[Transpose@TableNZNucleons,Frame->All](* This is table III in companion paper*)


(* ::Input::Initialization:: *)
ShortNamesAll=NamesWithWeightsAll[[All,1]];


(* ::Input::Initialization:: *)
ListNPPairs=NamesWithWeightsAll[[All,2]];


(* ::Input::Initialization:: *)
ExistName[name_]:=MemberQ[ShortNamesAll,name];
ExistPair[pair_List]:=MemberQ[ListNPPairs,pair];


NamesMassNumberAll[A_]:=Select[NamesWithWeightsAll,((Plus@@(#[[2]]))==A)&][[All,1]]


(* ::Input::Initialization:: *)
KeySpecies=Association@(Rule@@@NamesWithWeightsAll)


(* ::Input::Initialization:: *)
KeyNucleons=Association@(Rule@@@(Reverse/@NamesWithWeightsAll))


(* ::Input::Initialization:: *)
Ni["Bm"]:=1;
Ni["Bp"]:=-1;
Ni["g"]:=0;

Zi["Bm"]:=-1;
Zi["Bp"]:=1;
Zi["g"]:=0;

Ai["Bm"]:=0;
Ai["Bp"]:=0;
Ai["g"]:=0;


(* ::Input::Initialization:: *)
Ni[key_]:=KeySpecies[key][[1]]
Zi[key_]:=KeySpecies[key][[2]]
Ai[key_]:=Zi[key]+Ni[key]


(* ::Input::Initialization:: *)
SpinFromCharList[charlist_List]:=StringReplace[StringJoin@@charlist,{"("->"",")"->"",","->"","+"->"","-"->""," "->"","#"->""}]
MassFromCharList[charlist_List]:=StringReplace[StringJoin@@charlist,{" "->"","#"->""}]


(* ::Input::Initialization:: *)
StringListParticles=#[[1]]&/@Import["nubase2016.asc"];
NubTabChar=Select[Characters/@StringListParticles,Length[#]>=93&];


(* ::Input::Initialization:: *)
Alist=ToExpression/@StringJoin/@(Take[#,{1,3}]&/@NubTabChar);
Zlist=#/10&/@ToExpression/@StringJoin/@(Take[#,{5,8}]&/@NubTabChar);
MassExcessesString=MassFromCharList/@(Take[#,{20,29}]&/@NubTabChar);
Spins=SpinFromCharList/@(Take[#,{80,93}]&/@NubTabChar);
Nlist=Alist-Zlist;


(* ::Input::Initialization:: *)
MyGrid[ListNPBindingSpinName=Flatten[{KeyNucleons[{#[[1]],#[[2]]}],#}]&/@Select[Transpose[{Nlist,Zlist,MassExcessesString,Spins}],ExistPair[{#[[1]],#[[2]]}]&]]


(* ::Input::Initialization:: *)
ExcessMassKeys=Association[{#[[1]]->ToExpression[#[[4]]]}&/@ListNPBindingSpinName]


(* ::Input::Initialization:: *)
SpinKeys=Association[{#[[1]]->ToExpression[#[[5]]]}&/@ListNPBindingSpinName]


(* ::Input::Initialization:: *)
Eneutron:=ExcessMassKeys["n"];
Eproton:=ExcessMassKeys["p"];


(* ::Input::Initialization:: *)
BindingEnergy[name_]:=Module[{Pair,A,Z,N},
Pair=KeySpecies[name];
Z=Pair[[2]];
N=Pair[[1]];
A=Z+N;
N Eneutron +Z Eproton-ExcessMassKeys[name]]

Mass[name_]:=Module[{Pair,A,Z,N},
Pair=KeySpecies[name];
Z=Pair[[2]];
N=Pair[[1]];
A=Z+N;
A ma+keV ExcessMassKeys[name]-Z me]


(* ::Input::Initialization:: *)
BindingEnergy["n"]
BindingEnergy["p"]
BindingEnergy["d"]
BindingEnergy["a"]


(* ::Input::Initialization:: *)
YNSE[name_,Yn_,Yp_,Tv_]:=Module[{Pair,N,A,Z,mN,A32Overmn},
mN=(mn+mp)/2;
Pair=KeySpecies[name];
Z=Pair[[2]];
N=Pair[[1]];
A=Z+N;
A32Overmn=(Mass[name]/(mn^(A-Z)*mp^Z))^(3/2);
(2*SpinKeys[name]+1)Zeta[3]^(A-1) \[Pi]^((1-A)/2) 2^((3A-5)/2) A32Overmn (kB Tv)^(3(A-1)/2) (\[Eta]factorT[Tv])^(A-1) Yp^Z Yn^(A-Z) Exp[(BindingEnergy[name]*keV)/(kB Tv)]
]


(* ::Input::Initialization:: *)
Qreaction[ListIn_,ListOut_]:=Module[{Ni=Length@ListIn,Nf=Length@ListOut,factorin,factorout,Units},
factorin=Plus@@((BindingEnergy[#])&/@ListIn);
factorout=Plus@@((BindingEnergy[#])&/@ListOut);
Units=keV;
-Units(factorin-factorout)
];


(* ::Input::Initialization:: *)
PowerT9[ListIn_,ListOut_]:=Module[{Ni=Length@ListIn,Nf=Length@ListOut},
3/2.*(Ni-Nf)
];


(* ::Input::Initialization:: *)
FactorInverseReaction[ListIn_,ListOut_]:=Module[{Ni=Length@ListIn,Nf=Length@ListOut,factorin,factorout,Units},
factorin=Times@@((((2 SpinKeys[#[[1]]]+1)(2Pi/Mass[#[[1]]]/(kB 10^9))^(-3/2))^(#[[2]])/(#[[2]]!))&/@(Tally@ListIn));
factorout=Times@@((((2 SpinKeys[#[[1]]]+1)(2Pi/Mass[#[[1]]]/(kB 10^9))^(-3/2))^(#[[2]])/(#[[2]]!))&/@(Tally@ListOut));
Units=((ma/clight^2)/(hbar clight)^3)^(Ni-Nf);
factorin/ factorout Units
];


(* ::Input::Initialization:: *)
GatherInfoReac[ListIn_,ListOut_]:={Qreaction[ListIn,ListOut]/MeV,FactorInverseReaction[ListIn,ListOut],PowerT9[ListIn,ListOut],-Qreaction[ListIn,ListOut]/kB/10^9};

RemoveNonNuclear[Species_List]:=Select[Species,#=!="g"&&#=!="Bm"&&#=!="Bp"&];
InfoReaction[{ListIn_,ListOut_}]:=GatherInfoReac[RemoveNonNuclear@ListIn,RemoveNonNuclear@ListOut];
InfoReaction[ListIn_,ListOut_]:=InfoReaction[{ListIn,ListOut}]


(* ::Input::Initialization:: *)
CheckReaction[{ListIn_,ListOut_}]:=Module[{Znet,Nnet,Anet},
Znet=-Plus@@(Zi/@ListIn)+Plus@@(Zi/@ListOut);
Nnet=-Plus@@(Ni/@ListIn)+Plus@@(Ni/@ListOut);
Anet=-Plus@@(Ai/@ListIn)+Plus@@(Ai/@ListOut);
(*Print[ListIn," ",ListOut," ",Znet,Nnet,Anet];*)
If[Znet=!=0||Nnet=!=0||Anet=!=0,
Print["ERROR! This reaction ",ListIn," -> ",ListOut," is not possible.\nThe net result for Z, N and A are ",Znet," ",Nnet," ",Anet];
Print["We abort the evaluation !"];
Quit[];
(*TODO Maybe a better handling of errors than juts a violent Quit[]... *)
];
]

CheckReaction[ListIn_,ListOut_]:=CheckReaction[{ListIn,ListOut}]


(* ::Input::Initialization:: *)
Clear[TableRandom,MyNormalRandom]
$NRandomPoints = 1000; (* We put something larger than the max number of reactions *)
TableRandom[seed_]:=TableRandom[seed]=(SeedRandom[seed];Table[RandomVariate[NormalDistribution[]],{i,1,$NRandomPoints}])


(* ::Input::Initialization:: *)
InitializeRandom[seed_]:=(IndexRandom[seed]=1);
RandomFromTable[seed_]:=With[{r=TableRandom[seed][[IndexRandom[seed]]]},IndexRandom[seed]=IndexRandom[seed]+1;r]
MyNormalRandom[seed_]:=RandomFromTable[seed]


(* ::Input::Initialization:: *)
$Seed:=0;
Initialize[$Seed];
NormalRealisation:=If[$RandomNuclearRates,MyNormalRandom[$Seed],0];


(* ::Input::Initialization:: *)
ReverseReaction[Name_,FrontFactor_,PoweronT9_,Qoverkb_]:=With[{Reversname=ToExpression["Hold@Lbar"<>Name],name=Evaluate[Symbol["L"<>Name]]},
If[FrontFactor>0,
MySet[Reversname,Function[{Tvr},With[{T9=Tvr/Giga},FrontFactor (T9)^PoweronT9*Exp[Qoverkb/T9]*name[Tvr]]]];,
MySet[Reversname,Function[{Tvr},0]];
]];



(* ::Input::Initialization:: *)
TreatData[Data_]:=Module[{reac,constants,ReferencePaper,dat,rest,list,resultat,reacreshaped,replacements},
resultat={};
list=Data;

While[Length@list>0,
reac=list[[1]];
ReferencePaper=StringDrop[list[[2,1]],2];
(*Print[ReferencePaper];*)
(*Print[reac];*)
constants=list[[3]];
rest=Drop[list,3];
dat={};
While[rest=!={}&&NumericQ[rest[[1,1]]],
dat=Append[dat,rest[[1]]];
rest=Rest@rest;
];
list=rest;
reacreshaped=Append[{Select[reac,(#=!="+"&&#=!="*-")&],constants,ReferencePaper},dat];
resultat=Append[resultat,reacreshaped];
];
replacements={"He4"->"a"};
resultat/.replacements
];


(* ::Input::Initialization:: *)
TruncateRateVariation[rate_]:=Min[$MaxVariationRate,rate]


(* ::Input::Initialization:: *)
TreatReactionLine[line_]:=Module[{rescalefactor,reac,constants,interpfunction,data,len,table,Tmin,rmin,wedgeposition,colonposition,InitialParticles,FinalParticles,BoolenFileData,Q,FrontFactor,PoweronT9,Qoverkb,Name,Lname,rv,ReferencePaper,InfoFromAudi2017},
reac=line[[1]];
(*Print["Treating reaction : ",reac];*)
constants=line[[2]];
ReferencePaper=line[[3]];
data=line[[4]];

len=Length@line;
wedgeposition=Position[reac,">"][[1,1]];
colonposition=Position[reac,";"][[1,1]];
InitialParticles=Take[reac,{1,wedgeposition-1}];
FinalParticles=Take[reac,{wedgeposition+1,colonposition-1}];

(* We quit if the reaction does not conserve formally Z or N, that is if it cannot exist *)
CheckReaction[InitialParticles,FinalParticles];


Name=StringJoin@@ToString/@InitialParticles<>"TO"<>StringJoin@@ToString/@FinalParticles;

Q=constants[[1]];
FrontFactor=constants[[2]];
PoweronT9=constants[[3]];
Qoverkb=constants[[4]];


(* We check the constants used in reverse rates *)
InfoFromAudi2017=InfoReaction[InitialParticles,FinalParticles];
(*Print[InitialParticles," ",FinalParticles," ",InfoFromAudi2017];*)

If[Abs[FrontFactor/InfoFromAudi2017[[2]]-1]>0.001,Print[Name," WARNING. We use \[Alpha]=",FrontFactor," but we should use ",InfoFromAudi2017[[2]]]
];

If[Abs[Qoverkb/InfoFromAudi2017[[4]]-1]>0.001,
Print[Name, " WARNING. We use Q/\!\(\*SubscriptBox[\(k\), \(B\)]\)=",Qoverkb," but we should use ",InfoFromAudi2017[[4]]]
];

If[PoweronT9=!=InfoFromAudi2017[[3]],
Print[Name, " WARNING. We use power on T9 =",PoweronT9," but we should use ",InfoFromAudi2017[[3]]]
];
(* ****************)


(* *** *)
(*For exploration of parameters we can redefine some front factors to recales reactions. For instance the DPG reaction*)
(* Added on request of Antony Lewis *)

rescalefactor=1;
(*Print[Name,FullForm[Name]];*)

If[Name==="dpTOHe3g",
rescalefactor=dpTOHe3gFactor;
If[rescalefactor=!=1,Print["dpTOHe3g reaction is rescaled by ",dpTOHe3gFactor," New front factor is ",rescalefactor];];];
(* *** *)



table=Map[{Giga #[[1]],#[[2]]Hz,#[[3]]}&,data];
Tmin=Last[table][[1]];
rmin=Last[table][[2]];
Lname=ToExpression["Hold@L"<>Name];
rv=NormalRealisation;
MySet[Lname,MyInterpolationRate[{#[[1]],Identity[rescalefactor #[[2]]*
If[$RandomNuclearRates,TruncateRateVariation[#[[3]]^rv],1]]}&/@table]];
(* We do not rescale the reverse because it is computed FROM the forward rate. So rescaling the forward rate by rescalefactor rescales them both *)
ReverseReaction[Name,FrontFactor,PoweronT9,Qoverkb];

{Name,InitialParticles,FinalParticles,rv,ReferencePaper}

];

SetAttributes[TreatReactionLine,SequenceHold]


(* ::Input::Initialization:: *)
ListTWagoner={0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009,0.01,0.011,0.012,0.013,0.014,0.015,0.016,0.018,0.02,0.025,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.12,0.13,0.14,0.15,0.16,0.18,0.2,0.25,0.3,0.35,0.4,0.45,0.5,0.6,0.7,0.8,0.9,1.,1.25,1.5,1.75,2.,2.5,3.,3.5,4.,5.,6.,7.,8.,9.,10.}*10^9;


(* ::Input::Initialization:: *)
$ListTWagoner = False;


(* ::Input::Initialization:: *)
TableInterpolationTemperature=If[$ListTWagoner,ListTWagoner,ListTRange[0.9 Tf,10^10]];


(* ::Input::Initialization:: *)
SimplifyReactionStringRules={"+"->" + ",">"->" > ",";"->" ; ","2n"->" n + n ","2p"->" p + p ","2g"->" g + g ","2a"->" a + a ","He4"->" a "};

ReshapheReactionString[string_String]:=Select[StringSplit[StringReplace[string,SimplifyReactionStringRules]," "],(#=!="+"&&#=!="*-"&&#=!="")&];

TreatReactionString[reac_String,source_String,f_]:=Module[{reacshaped,wedgeposition,colonposition,InitialParticles,FinalParticles,Name},
reacshaped=ReshapheReactionString[reac];
wedgeposition=Position[reacshaped,">"][[1,1]];
colonposition=Position[reacshaped,";"][[1,1]];
InitialParticles=Take[reacshaped,{1,wedgeposition-1}];
FinalParticles=Take[reacshaped,{wedgeposition+1,colonposition-1}];

(* We check tha the reaction is possible, that is it should conserve N and Z*)
(* If not the case, the code will violently quit after spitting out warning messages.*)
CheckReaction[InitialParticles,FinalParticles];

Name=StringJoin@@ToString/@InitialParticles<>"TO"<>StringJoin@@ToString/@FinalParticles;
{Name,InitialParticles,FinalParticles,NormalRealisation,source,f}
]


(* ::Input::Initialization:: *)
PostTreatT9[var_,funT9_]:=If[$InterpolateAnalytics,
MyInterpolationRate[Table[{i,var MyChop[funT9[i/10^9]]},{i,TableInterpolationTemperature}]],
(var MyChop[funT9[#/10^9]])&];

GenRateT9[var_,funT9_]:=PostTreatT9[var,funT9];


(* ::Input::Initialization:: *)
DefineAnalyticRates:=
Module[{f,Var,Name,\[Lambda]Reac,\[Lambda]barReac,treatedreac,source,reac,analyticforward,AddReaction,initialparticles,finalparticles,InfoFromAudi2017,FrontFactor,Qoverkb,PoweronT9,forward},

(* Most recent implementation with automatic computation of reverse rate *)
AddReaction[reac_String,source_String,f_,ForwardT9_,BoolBackward_]:=(
treatedreac=TreatReactionString[reac,source,f];
Name=treatedreac[[1]];

(* Building the backward ratio *)
initialparticles=treatedreac[[2]];
finalparticles=treatedreac[[3]];
InfoFromAudi2017=InfoReaction[initialparticles,finalparticles];
(*Print[InitialParticles," ",FinalParticles," ",InfoFromAudi2017];*)
FrontFactor=InfoFromAudi2017[[2]];
Qoverkb=InfoFromAudi2017[[4]];
PoweronT9=InfoFromAudi2017[[3]];
(* End of building backward ratio *)

\[Lambda]Reac=ToExpression["Hold@L"<>Name];
\[Lambda]barReac=ToExpression["Hold@Lbar"<>Name];
Sow[treatedreac];
Var=f^treatedreac[[4]];

MySet[\[Lambda]Reac,GenRateT9[Var,ForwardT9]];
(*MySet[\[Lambda]barReac,GenRateT9[Var,BackwardT9 ]];*)
If[BoolBackward,
MySet[\[Lambda]barReac,GenRateT9[Var,(FrontFactor*#^PoweronT9*Exp[Qoverkb/#]*ForwardT9[#])& ]];,
MySet[\[Lambda]barReac,GenRateT9[0,0& ]];(* No backward reaction *)
];

treatedreac);


Reap[

(* This is where all extra analytic reactions must be listed.*)
(* TODO. Explain syntax better, but it si now rather transparent *)
(* For each reactions added analytically we need to specify a String source which is the paper in which it is found *)
(* Then we give a string reac which is the reaction considered.*)
(* The factor of incertainty for Monte-Carlo is then given*)
(* The analytic function forward[T9_], which is a function of T9 (that is the temperature in GK)*)
(* With all these definitions we call AddReaction. The last argument is a boolean. If True it computes also the reverse rate from detailed balance arguments, and if False it does not do so. This is essentially for pure decay reactions that there is no need to compute the reverse rates.*)

(**=======================================================================
*4He,3He,D,7Li (Extra reactions)
	   =======================================================================*)
source="Nag06";
reac=" d + n  > t + g ; dng";
	   f=1.40;
forward[T9_]:=With[{T923=T9^(2/3)},(214. T9^0.075+7.42T9+T923)];
AddReaction[reac,source,f,forward,True];
(* End of first reaction added analytically *)


source="Nag06";
reac="t+t>a+n+n;ttn";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)},(1/T923 1.67*^9 E^(-4.872/T913) (1. -0.272 T9+0.086 T913-0.455 T923+0.148 T943+0.225 T953))];
AddReaction[reac,source,f,forward,True];


source = "Wag69";
reac="He3 +n > He4 + g ; hng";
f=3.;
forward[T9_]:=6.62*(1+905*T9);
AddReaction[reac,source,f,forward,True];


source = "CF88";
reac="He3 + t > He4 + d ; htd";
f=3.;
forward[T9_]:=With[{T9A=T9/(1.+0.128*T9),T932=T9^(3/2)},With[{T9A13=T9A^(1./3.),T9A56=T9A^(5./6.)},5.46*^9*T9A56/T932*Exp[-7.733/T9A13] 
]];
AddReaction[reac,source,f,forward,True];



source = "CF88";
reac="He3 + t > He4 + n + p ; htp";
f=3.;
forward[T9_]:=With[{T9A=T9/(1.+0.115*T9),T932=T9^(3/2)},With[{T9A13=T9A^(1./3.),T9A56=T9A^(5./6.)},
7.71*^9*T9A56/T932*Exp[-7.733/T9A13]
]];
AddReaction[reac,source,f,forward,True];


source = "NACRE";
reac="a + a + n > Be9 + g ; aang";
f=1.25;
forward[T9_]:=With[{T932=T9^(3/2),T923=T9^(2/3),T913=T9^(1/3)},
With[{he4abe8= 2.43*^9*(1.+74.5*T9)/T923*Exp[-13.49/T913-(T9/0.15)^2]+6.09*^5/T932*Exp[-1.054/T9]},
If[T9<0.03,
(he4abe8)* 6.69*^-12*(1.-192*T9+2.48*^4*T9^2-1.50*^6*T9^3+4.13*^7*T9^4-3.90*^8*T9^5),
 (he4abe8)* 2.42*^-12*(1.-1.52*Log10[T9]+0.448*(Log10[T9])^2+0.435*(Log10[T9])^3)]]];
AddReaction[reac,source,f,forward,True];


source="CF88&MF89";
reac="Li7 + t > a + a + n + n; li7ta";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},8.81*^+11/T923*Exp[-11.333/T913]];
AddReaction[reac,source,f,forward,True];
(* Problem T93 not divided in Coc's code. TODO Make sure to correct it.*)


source="CF88&MF89";
reac="Li7 + He3 > a + a + n + p; li7haa";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},1.11*^+13/T923*Exp[-17.989/T913]];
AddReaction[reac,source,f,forward,True];
(* Idem problem T93 not divided in Coc *)


(* TODO Check because the 74 at the end is strange *)
source="Bal95";
reac=" Li8 + d > Li9 + p ; li8dp";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},9.63*^6/T923*Exp[-10.324/T913]*(1.+0.404*T913)*74.];
AddReaction[reac,source,f,forward,True];


source="Has09c";
reac=" Li8 + d > Li7 + t ; li8dt";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},(3.02*^8/T9^0.624*Exp[-3.51/T9]+5.82*^11/T923*Exp[-19.72/T913]*(1.0+0.280*T913))];
AddReaction[reac,source,f,forward,True];


source="CF88";
reac="Be7 + d > a + a + p ; be7dp";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},1.07*^+12/T923*Exp[-12.428/T913]];
AddReaction[reac,source,f,forward,True];


source="CF88&MF89";
reac="Be7 + t > a + a + n + p ; be7t";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},2.91*^+12/T923*Exp[-13.729/T913]];
AddReaction[reac,source,f,forward,True];
(* Idem problem in Coc's Fortran code. *)


source="CF88&MF89";
reac="Be7 + He3 > 2a + p + p  ; be7h";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},6.11*^+13/T923*Exp[-21.793/T913]];
AddReaction[reac,source,f,forward,True];
(* Idem problem in COC since here it is a division by T93 to get the revsre reaction *)


source="Wie89";
reac="C9 + a > N12 + p ; c9an";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T932=T9^(3/2),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)},(1.668*^+15/T923*Exp[-31.272/T913-(T9/.307)^2]* (1.+1.33*^-2*T913-6.42*T923-.599*T9+14.4*T943+3.42*T953)+56.8/T932*Exp[-5.292/T9]+1.7*^+5/T932*Exp[-14.08/T9]+6.52*^7/T932*Exp[-23.09/T9])];
AddReaction[reac,source,f,forward,True];


 (* *=======================================================================
*6Li (Extra reactions)
      *=======================================================================*)

source="CF88";
f=3.;
(*(* TODO  Change this because it is presented as being endothermic. That would be better to do the opposite? *)
reac="t+a>Li6+n;tan";
forward[T9_]:=With[{T9A=T9/(1.+49.18*T9)},With[{ T9A32=T9A^(3./2.),T932=T9^(3/2)},
(1.80*^8*Exp[-55.494/T9]*(1.-.261*T9A32/T932)+2.72*^9/T932*Exp[-57.884/T9])
]];*)


(* Here is the same reaction but presented backward, such that it is exothermic in the forward direction *)
reac="Li6+n>t+a;tan";
forward[T9_]:=With[{T9A=T9/(1.+49.18*T9)},With[{ T9A32=T9A^(3./2.),T932=T9^(3/2)},
(1.80*^+8*(1.-.261*T9A32/T932)*.935+2.72*^9/T932*Exp[(55.494-57.884)/T9]*.935)
]];
AddReaction[reac,source,f,forward,True];


source="FK90";
reac="He3 + t > Li6 + g ; htg";
f=3.;forward[T9_]:=With[{T92=T9^2,T923=T9^(2/3),T932=T9^(3/2),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)}, 2.21*^5/T923*Exp[-7.720/T913]*(1.+2.68*T923+0.868*T9+0.192*T943+0.174*T953+0.044*T92)];
AddReaction[reac,source,f,forward,True];


 source="CF88";
reac="a + n + p > Li6 + g ; anpg";
f=3.;
forward[T9_]:=If[T9>1, 4.62*^-6/T9^2*(1.+0.075*T9)*Exp[-19.353/T9],0];
AddReaction[reac,source,f,forward,True];


 source="MF89";
reac="Li6 + n > Li7 + g ; li6ng";
f=3.;
forward[T9_]:= 5.10*^3;
AddReaction[reac,source,f,forward,True];

 source="MF89";
reac="Li6 + d > Li7 + p ; li6dp";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)}, 1.48*^12/T923*Exp[-10.135/T913]];
AddReaction[reac,source,f,forward,True];

 source="MF89";
reac="Li6 + d > Be7 + n ; li6dn";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)}, 1.48*^12/T923*Exp[-10.135/T913]];
AddReaction[reac,source,f,forward,True];


(**=======================================================================
*Berylium& Boron (Main reactions)
       *=======================================================================*)
source="CF88";
reac="Li6 + a > B10 + g ; li6ag";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T932=T9^(3/2),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)}, (4.06*^06/T923*Exp[-18.79/T913-(T9/1.326)^2]*(1.+0.022*T913+1.54*T923+0.239*T9+2.2*T943+0.869*T953)
+1.91*^3/T932*Exp[-3.484/T9]+1.01*^4/T9*Exp[-7.269/T9])];
AddReaction[reac,source,f,forward,True];


source="NACRE";
reac=" Li7 + a > B10 + n ; li7an / b10na";
f=1.08;
forward[T9_]:=1.325*1.66*^7*(1.+1.064*T9)*1/1.3242*Exp[-32.3755/T9];
AddReaction[reac,source,f,forward,True];

(* C MF89 remplace Wiescher et al.ApJ 464 (1989) 464.C Voir Blackmon et al.PRC 54 (1996) 383& Heil et al.ApJ 507 (1998) 997.*)
            (*%MF89Hei98   *)
source="MF89&Hei98";
            reac="Li7+n>Li8+g;li7ng";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)},(6.015*^3+ 1.141*^4/T932*Exp[-2.576/T9])];
AddReaction[reac,source,f,forward,True];


(*Replace by exothermic reaction ?*)
source="MF89";
reac="Li7 + d > Li8 + p ; li7dp ! Q<0 !";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)}, 8.31*^8/T932*Exp[-6.998/T9]];
AddReaction[reac,source,f,forward,True];


source="Rau94";
reac="Li8 + n > Li9 + g ; li8ng";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)},(3.260*^3+ 6.328*^4/T932*Exp[-2.866/T9])];
AddReaction[reac,source,f,forward,True];


source="Men12";
reac="Li8 + p > a + a + n ; li8pn";
forward[T9_]:=With[{T932=T9^(3/2),T913=T9^(1/3),T923=T9^(2/3),T92=T9^2,T93=T9^3,T94=T9^4,T95=T9^5},
If[T9<5,(
5.36*^8/T932*Exp[-4.41/T9]+1.99*^8/T932*Exp[-7.08/T9]+5.85*^10/T923*Exp[-8.50/T913]* (1.-1.70*T9+0.849*T92-0.175*T93+1.62*^-2*T94-5.60*^-4*T95)),
7.777*^7]];
AddReaction[reac,source,f,forward,True];


source="Bal95";
reac="Li8 + d > Be9 + n ; li8dn";
f=3.;forward[T9_]:=With[{T913=T9^(1/3),T923=T9^(2/3)},9.63*^6/T923*Exp[-10.324/T913]*(1.+0.404*T913)*188.];
AddReaction[reac,source,f,forward,True];

(**=======================================================================
*Berylium& Boron (Extra reactions)
      *======================================================================= *)
source="Rau94";
reac="Be9 + n > Be10 + g ; be9ng";
f=3.;
forward[T9_]:=With[{T913=T9^(1/3),T923=T9^(2/3),T932=T9^(3/2)},(1.01*^3+ 1.01*^4/T932*Exp[-6.487/T9]+5.41*^4/T932*Exp[-8.471/T9])];
AddReaction[reac,source,f,forward,True];

source="NACRE";
reac="Be9 + p > a + a + p + n ; be9pn";
f=1.05;
forward[T9_]:= 5.06*^7*Exp[-21.479/T9]*(1.+1.26*T9-0.0302*T9^2);
AddReaction[reac,source,f,forward,True];
(* I find that it is division by T93 by Coc used multiplication by T93 ! Carefull !!!*)

source="NACRE";
reac="B11 + p > C11 + n ; b11pn ! Q < 0 !";
f=1.1;
forward[T9_]:= 1.36*^8*Exp[-32.085/T9]*(1.+0.963*T9-0.285*T9^2+3.36*^-2*T9^3-1.37*^-3*T9^4);
AddReaction[reac,source,f,forward,True];


source="Rau94";
reac=" Be10 + n > Be11 + g ; be10ng";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)},(5.96*^2+ 6.67*^5/T932*Exp[-14.85/T9]) ];
AddReaction[reac,source,f,forward,True];


source="Rau94";
reac="Be11 + n > Be12 + g ; be11ng";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)}, 3.56*^2 ];
AddReaction[reac,source,f,forward,True];


source="Des99Bea01";
reac="B8 + p > C9 + g ; b8pg";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2),T913=T9^(1/3),T92=T9^2},6.253*^5*Exp[-11.971/T913]*(1.-7.03*^-2*T9+6.25*^-3*T92)];
AddReaction[reac,source,f,forward,True];

(* =====================================================================\[Equal]
*Leaks to CNO
      !*=======================================================================*)

source="NACRE";
reac="a + a + a > C12 + 2g ; aaag";
f=1.15;
forward[T9_]:=With[{T932=T9^(3/2),T923=T9^(2/3),T913=T9^(1/3)},
With[{he4abe8=2.43*^9*(1.+74.5*T9)/T923*Exp[-13.49/T913-(T9/0.15)^2]+6.09*^5/T932*Exp[-1.054/T9],
be8agc12= 2.76*^7*(1.+5.47*T9+326*T9^2)/T923*Exp[-23.570/T913-(T9/0.4)^2]+130.7/T932*Exp[-3.338/T9]+2.51*^4/T932*Exp[-20.307/T9]},
If[T9<0.03, 
he4abe8*be8agc12*3.07*^-16*(1.-29.1*T9+1308*T9^2),
he4abe8*be8agc12*3.44*^-16*(1.+0.0158/T9^0.65)]]];
AddReaction[reac,source,f,forward,True];

source="Tang03";
reac="C11+p>N12+g;c11pg";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T932=T9^(3/2),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)},(1.670*^2*Exp[-4.166/T9]/T932+2.148*^5*Exp[-13.281/T913]/T923* (1.+4.639*T913-2.641*T923-1.543*T9+2.030*T943+4.657*T953))];
AddReaction[reac,source,f,forward,True];


source="CF88";
reac="B10 + a > N13 + n ; b10an";
f=3.;forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)}, 1.2*^13/T923*Exp[-27.989/T913-(T9/9.589)^2]  ];
AddReaction[reac,source,f,forward,True];

            source="Wan91";
reac="B11+a>C14+p;b11ap";
f=3.;forward[T9_]:=With[{T923=T9^(2/3),T932=T9^(3/2),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)},(8.403*^15*Exp[-31.914/T913-(T9/0.3432)^2]*(1.+0.022*T913+5.712*T923+0.642*T9+15.982*T943+4.062*T953)
+5.44*^-3/T932*Exp[-2.868/T9]+2.419*^2/T932*Exp[-5.147/T9]+4.899*^2/T932*Exp[-5.157/T9]+4.944*^6/T9^(3/5)*Exp[-11.26/T9])];
AddReaction[reac,source,f,forward,True];


source="Rau94";
reac="C11+n>C12+g;c11ng";
f=3.;forward[T9_]:=With[{T932=T9^(3/2)},(3.18*^4+ 3.30*^3/T932*Exp[-0.917/T9]+1.05*^6/T932*Exp[-5.57/T9])];
AddReaction[reac,source,f,forward,True];


(*=======================================================================*)
(*       Decay Rates                                            *)
(*=======================================================================*)
(* %Aud03  *)
(* All decay rates from %Aud03  *)

source="Aud03";
reac="He6>Li6+Bm;";
forward[T9_]:=Log[2]/8.0670*^-1 ;
AddReaction[reac,source,1,forward,False];(* The 1 is because we do not put uncertainty on decays, and the False because we do not put reverse reactions on decays *)

reac="Li8>2a+Bm;";
forward[T9_]:=Log[2]/8.4030*^-1 ;
AddReaction[reac,source,1,forward,False];

reac="Li9>Be9+Bm;";
forward[T9_]:=Log[2]/1.7830*^-1 * 0.492 ;
AddReaction[reac,source,1,forward,False];

reac="Li9>a+a+n+Bm;";
forward[T9_]:=Log[2]/1.7830*^-1 * 0.508 ;
AddReaction[reac,source,1,forward,False];

reac="Be11>B11+Bm;";
forward[T9_]:= Log[2]/(1.3810*^1) ;
AddReaction[reac,source,1,forward,False];

reac="Be12>B12+Bm;";
forward[T9_]:=Log[2]/(2.15*^-2) ;
AddReaction[reac,source,1,forward,False];

reac="B8>a+a+Bp;";
forward[T9_]:= Log[2]/(7.70*^-1) ;
AddReaction[reac,source,1,forward,False];

reac="B12>C12+Bm;";
forward[T9_]:= Log[2]/(2.02*^-2) ;
AddReaction[reac,source,1,forward,False];

reac="B13>C13+Bm;";
(* !04/11/2010 *)
forward[T9_]:=Log[2]/(1.733*^-2) ;
AddReaction[reac,source,1,forward,False];

reac="B14>C14+Bm;";
(* !04/11/2010 *)
forward[T9_]:=Log[2]/(1.25*^-2) ;
AddReaction[reac,source,1,forward,False];

 reac="B15>C15+Bm;";
(* !04/11/2010 *)
forward[T9_]:= Log[2]/(9.87*^-3) ;
AddReaction[reac,source,1,forward,False];

reac="C9>a+a+p+Bp;";
forward[T9_]:= Log[2]/(1.26*^-1) ;
AddReaction[reac,source,1,forward,False];

reac="C10>B10+Bp;";
forward[T9_]:=Log[2]/(19.29) ;
AddReaction[reac,source,1,forward,False];

reac="C11>B11+Bp;";
forward[T9_]:= Log[2]/1.2234*^3 ;
AddReaction[reac,source,1,forward,False];

	    reac="C15>N15+Bm;";
(*28/10/2010*)
forward[T9_]:=Log[2]/2.449 ;
AddReaction[reac,source,1,forward,False];

reac="C16>N16+Bm;";
(*14/01/2011*)
forward[T9_]:= Log[2]/7.4700*^-1 ;
AddReaction[reac,source,1,forward,False];

reac="N12>C12+Bp;";
forward[T9_]:= Log[2]/1.100*^-2 ;
AddReaction[reac,source,1,forward,False];

reac="N13>C13+Bp;";
(*14/01/2011*)
forward[T9_]:=Log[2]/5.979*^2 ;
AddReaction[reac,source,1,forward,False];

reac="N16>O16+Bm;";
(*14/01/2011*)
forward[T9_]:=Log[2]/7.13 ;
AddReaction[reac,source,1,forward,False];

reac="N17>O16+n+Bm;";
(*14/01/2011*)
forward[T9_]:= Log[2]/4.1730 ;
AddReaction[reac,source,1,forward,False];

reac="O13>N13+Bp;";
(*14/01/2011*)
forward[T9_]:= Log[2]/8.58*^-3 ;
AddReaction[reac,source,1,forward,False];

reac="O14>N14+Bp;";
(*14/01/2011*)
forward[T9_]:=Log[2]/70.598 ;
AddReaction[reac,source,1,forward,False];

reac="O15>N15+Bp;";
(*14/01/2011*)
forward[T9_]:=Log[2]/122.24;
AddReaction[reac,source,1,forward,False];

reac="O19>F19+Bm;";
(*14/01/2011*)
forward[T9_]:=Log[2]/26.464;
AddReaction[reac,source,1,forward,False];

            reac="O20>F20+Bm;";
(*14/01/2011*)
forward[T9_]:=Log[2]/13.51;
AddReaction[reac,source,1,forward,False];

reac="F17>O17+Bp;";
(*04/11/2010*)
forward[T9_]:=Log[2]/64.49;
AddReaction[reac,source,1,forward,False];

reac="F18>O18+Bp;";
(*04/11/2010*)
forward[T9_]:= Log[2]/6.5863*^3;
AddReaction[reac,source,1,forward,False];

reac="F20>Ne20+Bm;";
(*04/11/2010*)
forward[T9_]:= Log[2]/11.1630;
AddReaction[reac,source,1,forward,False];

reac="Ne18>F18+Bp;";
(*04/11/2010*)
forward[T9_]:=Log[2]/1.6720;
AddReaction[reac,source,1,forward,False];

reac="Ne19>F19+Bp;";
(*04/11/2010*)
forward[T9_]:=Log[2]/17.296;
AddReaction[reac,source,1,forward,False];

reac="Ne23>Na23+Bm;";
(*04/11/2010*)
forward[T9_]:=Log[2]/37.240;
AddReaction[reac,source,1,forward,False];

reac="Na20>Ne20+Bp;";
(*14/01/2011*)
forward[T9_]:=Log[2]/4.4790*^-1;
AddReaction[reac,source,1,forward,False];

reac="Na21>Ne21+Bp;";
(*04/11/2010*)
forward[T9_]:=Log[2]/22.49;
AddReaction[reac,source,1,forward,False];

(* *=======================================================================
  *New reactions following Thomas,Schramm et al.1993;1994
      *=======================================================================*)

source="Efr96";
reac="He4 + 2n  > He6 + g ;";
f=3.;
forward[T9_]:=If[T9<2,
(2.65*^-3*T9^2.555*Exp[0.181/Max[T9,.1]]),
(2.93*^-1*T9^(-3.51*^-1)*Exp[-5.24/T9])];
AddReaction[reac,source,f,forward,True];


source="Iga95";
reac="O16 + n  > O17 + g ;";
f=3.;
forward[T9_]:=(2.7*^1+ 1.38*^4*T9 );
AddReaction[reac,source,f,forward,True];


source="CF88";
reac="N14 + n  > C14 + p ;";
f=3.;
forward[T9_]:=With[{T912=T9^(1/2)},( 7.19*^5*(1.+.361*T912+.502*T9)+3.34*^8/T912*Exp[-4.983/T9])*.333];
AddReaction[reac,source,f,forward,True];


source="CF88";
reac="O14 + n  > N14 + p ;";
f=3.;
forward[T9_]:=With[{T912=T9^(1/2)},(6.74*^7*(1.+0.658*T912+0.379*T9)*2.99 )];
AddReaction[reac,source,f,forward,True];


source="Wie87";
reac="O14 + a  > Ne18 + g ;";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)},( 1.16*^-1/T932*Exp[-11.73/T9]+3.40*^1/T932*Exp[-22.61/79]+9.10*^-3*T9^5*Exp[-12.159])];
AddReaction[reac,source,f,forward,True];


source="NACRE";
reac="C11 + a  > N14 + p ;";
f=2.;
forward[T9_]:=With[{T913=T9^(1/3),T92=T9^2},(0.2719*3.01*^16*Exp[-31.884/T913]* Exp[-1.379*T9+.215*T92-2.13*^-2*T92*T9+8*^-4*T92*T92]*(1.+0.14*Exp[-.275/T9-.210*T9]) )];
AddReaction[reac,source,f,forward,True];


source="Bar97C";
reac="O14 + a  > F17 + p ;";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2),T923=T9^(2/3),T913=T9^(1/3),T943=T9^(4/3),T953=T9^(5/3)},
With[{offset=1.330*^5/T932*Exp[-11.86/T9]+8.42*^-47*T932*Exp[-0.453/T9]+6.74*^4/T932*Exp[-13.60/T9]+1.21*^7/T932*Exp[-22.51/T9]+1.26*^8/T932*Exp[-26.00/T9]},
(offset+If[T9<1,
7.906*^15/T923*Exp[-40.33/T913]*(1.-1.884*^1*T913+2.446*^2*T923-7.735*^2*T9+9.485*^2*T943-3.961*^2*T953),0])]];
AddReaction[reac,source,f,forward,True];


source="Koe91";
reac=" O17 + n > C14 + a ;";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)},( 3.11*^4+ 9.18*^5/T932*Exp[-1.961/T9]+7.02*^7/T932*Exp[-2.759/T9])];
AddReaction[reac,source,f,forward,True];


source="NACRE";
(* Check this one because there seems to be a typo in the exponential. Or maybe this is correct but this is strange. *)
reac="F17 + n > N14 + a ;";
f=1.05;
forward[T9_]:=(1.38*^8*T9^0.053*Exp[-(55.0-54.943)/T9]* (1.+.039*Exp[-.012/T9+.217*T9])/1.478 );
AddReaction[reac,source,f,forward,True];


source="CF88";
reac="F18 + n > N15 + a ;";
f=3.;
forward[T9_]:=With[{T912=T9^(1/2)},( 3.14*^8*(1.-0.641*T912+0.108*T9)*2.)];
AddReaction[reac,source,f,forward,True];


source="Kaw91";
reac="C14 + d  > N15 + n ;";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3)},(4.27*^13/T923*Exp[-16.939])];
AddReaction[reac,source,f,forward,True];


source="CF88";
reac="p + p + n > d + p ;";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3)},(1.35*^7*Exp[-3.720/T913]*(1.+0.784*T913+0.346*T923+0.690*T9)/2.3590*^9)];
AddReaction[reac,source,f,forward,True];


source="Kaw91";
reac="C14 + n > C15 + g ;";
f=3.;
forward[T9_]:=(3240. *T9 );
AddReaction[reac,source,f,forward,True];


source="CF88";
reac=" O16 + p  > N13 + a ;";
f=3.;
forward[T9_]:=With[{T953=T9^(5/3),T932=T9^(3/2)},
With[{T9A=T9/(1.+7.76*^-2*T9+2.64*^-2*T953/(1.+7.76*^-2*T9)^(2./3.))},
With[{T9A13=T9A^(1./3.),T9A56=T9A^(5./6.)},
With[{SVRev=1.88*^18*T9A56/T932*Exp[-35.829/T9A13]*1.7232*^-1},
With[{SVDir=SVRev/0.172255*Exp[-60.5573/T9]},
SVDir]]]]];
AddReaction[reac,source,f,forward,True];



(* %TUNL&Cam08  !Camargo et al.Phys.Rev.C 78,034605 (2008) pour DC
      !Tilley (TUNL) Table 9.5 pour la res.a 87 keV (dominante)  *)
source="TUNL&Cam08";
reac="Li8 + p > Be9 + g ;";
f=3.;
forward[T9_]:=With[{T923=T9^(2/3),T913=T9^(1/3),T932=T9^(3/2)},
(3.516*^6/T923*Exp[-8.5155/T913]+2.669*^4/T932*Exp[-1.010/T9] )];
AddReaction[reac,source,f,forward,True];


source="Wan91";
reac="B11 + a  > N15 + g ;";
f=3.;
forward[T9_]:=With[{T932=T9^(3/2)},(643./T932*Exp[-5.1526/T9] )];
AddReaction[reac,source,f,forward,True];

][[2,1]]

(* The output is the list of reactions in standard format (Name,List initial,List final,f factor) which is then used by the differential equation constructor *)

];


(* ::Input::Initialization:: *)
ReactionPEN={"nTOp",{"n"},{"p"},0,"Companion Paper"};
(* Format is name, List of initial particles, List of final particles, f factor for uncertainty*)

TabulatedReactions:=
(Select[SafeImport[TabulatedReactionsFile],(NumericQ[#[[1]]]||"*-"==#[[1]]||StringMatchQ[#[[1]],"\\*%"~~__])&]);
ReshapedTabulatedReactions:=TreatData[TabulatedReactions];


(* ::Input::Initialization:: *)
$TabulatedAnalyticReactions=False;
TabulatedReactionsAnalyticFile="BBNRatesFromAnalytic.dat";


(* ::Input::Initialization:: *)
LoadRates:=Module[{len},
len=Length@ReshapedTabulatedReactions;
ListReactionsFile=TreatReactionLine/@(Take[ReshapedTabulatedReactions,Min[NumberNuclearReactions,len]]);
(* If the number is larger than the file, we also dig into the analytic expressions *)
If [NumberNuclearReactions>len,

If[$TabulatedAnalyticReactions,

TabulatedReactionsAnalytic=Select[SafeImport[TabulatedReactionsAnalyticFile],(NumericQ[#[[1]]]||"*-"==#[[1]]||StringMatchQ[#[[1]],"\\*%"~~__])&];
ExtraAnalyticReactions=TreatReactionLine/@TreatData[TabulatedReactionsAnalytic];,

ExtraAnalyticReactions=DefineAnalyticRates;];

ListReactions=Take[Join[{ReactionPEN},ListReactionsFile,ExtraAnalyticReactions],NumberNuclearReactions+1],
ListReactions=Join[{ReactionPEN},ListReactionsFile]]
];


(* ::Input::Initialization:: *)
LoadRates;


(* ::Input::Initialization:: *)
SpeciesUpToMaximumMass[A_Integer]:=SpeciesUpToMaximumMass[A]=Union@@Table[NamesMassNumberAll[i],{i,A}];
ReactionUpToMaximumMass[A_Integer][Reaction_List]:=And@@(MemberQ[SpeciesUpToMaximumMass[A],#]&/@Flatten@Reaction[[2;;3]]);
ListReactionsUpToMass[A_Integer,ListReactions_List]:=Select[ListReactions,ReactionUpToMaximumMass[A][#]&];
ListReactionsUpToMass[Infinity,ListReactions_List]:=ListReactions;
ListReactionsUpToChosenMass:=ListReactionsUpToMass[MaximumNuclearMass,ListReactions];


(* ::Input::Initialization:: *)
ReactionWithArrow[name_String]:=StringReplace[name,"TO"->" -> "]
NiceDisplayReaction[reaction_List]:=Join[{ReactionWithArrow[First[reaction]]},Rest[reaction]]


MyGrid[Join[{{"Reaction Name","Initial species","Final Species","Uncertainty","Reference"}},NiceDisplayReaction/@ListReactionsUpToChosenMass]]


MyGrid[Join[{{"Reaction Name","Q (MeV)","Front Factor","T9 power","Q/kB/10^9"}},
Join[{ReactionWithArrow[#[[1]]]},InfoReaction[#[[2]],#[[3]]]]&/@Rest@ListReactions]]


(* ::Input::Initialization:: *)
ListReactionsNames=ListReactionsUpToChosenMass[[All,1]];


(* ::Input::Initialization:: *)
ListNuclearReactionsNames=Select[ListReactionsNames,#=!="nTOp"&];


(* ::Input::Initialization:: *)
KeyNuclearReaction=Association[#->Position[ListNuclearReactionsNames,#][[1,1]]&/@ListNuclearReactionsNames];
KeyReaction=Association[#->Position[ListReactionsNames,#][[1,1]]&/@ListReactionsNames];


(* ::Input::Initialization:: *)
VariablesInEquations=Union@Flatten[Join[RemoveNonNuclear[#[[2]]],RemoveNonNuclear[#[[3]]]]&/@ListReactionsUpToChosenMass]


(* ::Input::Initialization:: *)
NumberVariable=Length@VariablesInEquations


(* ::Input::Initialization:: *)
NamesWithWeights=Select[NamesWithWeightsAll,MemberQ[VariablesInEquations,#[[1]]]&]


(* ::Input::Initialization:: *)
WeightsNuclear=(Plus@@(#[[2]]))&/@NamesWithWeights


(* ::Input::Initialization:: *)
NamesMassNumber[A_]:=Select[NamesWithWeights,((Plus@@(#[[2]]))==A)&][[All,1]]
NamesAtomicNumber[Z_]:=Select[NamesWithWeights,(#[[2,2]]==Z)&][[All,1]]


(* ::Input::Initialization:: *)
StackY[name_]:="Y"<>ToString[name];


(* ::Input::Initialization:: *)
YName[PostString_][n_,p_]:=ToExpression@StackY["n"<>ToString[n]<>"p"<>ToString[p]<>PostString];
ShortString[nameshort_,np_List]:=(Evaluate@ToExpression["Y"<>nameshort]:=YName[""]@@np;);


(* ::Input::Initialization:: *)
ShortNames=NamesWithWeights[[All,1]]
KeyVal=Association[#->Position[ShortNames,#][[1,1]]&/@ShortNames]


(* ::Input::Initialization:: *)
VarList=ToExpression/@(StackY/@ShortNames)


(* ::Input::Initialization:: *)
SetTimeDependence[list_List,tv_]:=#[tv]&/@list;


(* ::Input::Initialization:: *)
FunList[tv_]=SetTimeDependence[VarList,tv]
FunPrimeList[tv_]=FunList'[tv]


(* ::Input::Initialization:: *)
KeyQ[key_]:=MemberQ[NamesWithWeightsAll[[All,1]],key];

YHT[key_?KeyQ][t_]:=Y["HT"][key][t];
YMT[key_?KeyQ][t_]:=Y["MT"][key][t];
YLT[key_?KeyQ][t_]:=Y["LT"][key][t];


(* ::Input::Initialization:: *)
YPeriodTime[period_String][tv_]:=Y[period][#][tv]&/@ShortNames;


NumericalValueOrThermalEquilibriumValue[period_,ListThermal_,name_,Tv_,tv_]:=
Module[{Yv=Y[period][name][tv],Yn=Y[period]["n"][tv],Yp=Y[period]["p"][tv]},
If[ MemberQ[ListThermal,name],YNSE[name,Yn,Yp,Tv],Yv]];


(* ::Input::Initialization:: *)
YPeriodTimeOrStateEquilibrium[period_String,ListThermal_List][Tv_,tv_]:=NumericalValueOrThermalEquilibriumValue[period,ListThermal,#,Tv,tv]&/@ShortNames;


(* ::Input::Initialization:: *)
CNONuclei=KeyNucleons/@Join[Table[{i,6},{i,6,10}],Table[{i,7},{i,5,10}],Table[{i,8},{i,5,12}]]


(* ::Input::Initialization:: *)
YLT["CNO"][t_]:=Plus@@((YLT[#][t]&)/@CNONuclei)


(* ::Input::Initialization:: *)
FillReactionMatrix[listreac_List]:=Module[{Tab,i,j,nvar,TreatReaction,FactorInitialElements},
nvar=Length@VarList;
Tab=Table[0,{ii,1,nvar}];
FactorInitialElements[el_List]:=Times@@((A\[Rho]B/DensityUnit Y[KeyVal[#[[1]]]])^#[[2]]/(#[[2]]!)&/@el);
TreatReaction[reaction_List]:=Module[{
InitialParticles=Tally[RemoveNonNuclear@reaction[[2]]],
FinalParticles=Tally[RemoveNonNuclear@reaction[[3]]],
ReactionForward,ReactionBackward,FactorInitialForward,FactorInitialBackward},

ReactionForward=L[KeyReaction[reaction[[1]]]];
ReactionBackward=Lbar[KeyReaction[reaction[[1]]]];
FactorInitialForward=FactorInitialElements@InitialParticles;(* This computes the product Subscript[Y, i]^ni/ni! for initial particles*)
FactorInitialBackward=FactorInitialElements@FinalParticles;

(Tab[[KeyVal[#[[1]]]]]=Tab[[KeyVal[#[[1]]]]]-ReactionForward FactorInitialForward #[[2]]/A\[Rho]B*DensityUnit)&/@InitialParticles;
(Tab[[KeyVal[#[[1]]]]]=Tab[[KeyVal[#[[1]]]]]+ReactionForward FactorInitialForward #[[2]]/A\[Rho]B*DensityUnit)&/@FinalParticles;
(Tab[[KeyVal[#[[1]]]]]=Tab[[KeyVal[#[[1]]]]]-ReactionBackward FactorInitialBackward #[[2]]/A\[Rho]B*DensityUnit)&/@FinalParticles;
(Tab[[KeyVal[#[[1]]]]]=Tab[[KeyVal[#[[1]]]]]+ReactionBackward FactorInitialBackward #[[2]]/A\[Rho]B*DensityUnit)&/@InitialParticles;
];
TreatReaction/@listreac;
Tab
]


(* ::Input::Initialization:: *)
FormalReactions=FillReactionMatrix@ListReactionsUpToChosenMass;


FormalReactions[[KeyVal["Li7"]]]


NiceDisplayReaction[ListReactions[[8]]]


(* ::Input::Initialization:: *)
NReactionsSmallNetwork=Min[NumberNuclearReactions+1,18];
FormalReactions18=FillReactionMatrix@Take[ListReactionsUpToChosenMass,Min[NReactionsSmallNetwork,Length@ListReactionsUpToChosenMass]];


(* ::Input::Initialization:: *)
WeightsNuclear.FormalReactions//Simplify


(* ::Input::Initialization:: *)
FormalReactionsOnlyPEN=FillReactionMatrix[{ReactionPEN}];


(* ::Input::Initialization:: *)
Yi:=Y[KeyVal[#]]&/@ShortNames;

RulesY[tv_]:=Thread[Rule[Yi,FunList[tv]]];


Take[RulesY[tv],8]


(* ::Input::Initialization:: *)
Li=L[KeyReaction[[#]]]&/@ListReactionsNames;
Lbari=Lbar[KeyReaction[[#]]]&/@ListReactionsNames;


(* ::Input::Initialization:: *)
Rules\[Lambda]RHS[Tv_]:=Symbol["L"<>#][Tv]&/@ListReactionsNames;
Rules\[Lambda]RHS[n_,Tv_]:=Symbol["L"<>#][Tv]&/@Take[ListReactionsNames,n];

Rules\[Lambda]barRHS[Tv_]:=Symbol["Lbar"<>#][Tv]&/@ListReactionsNames;
Rules\[Lambda]barRHS[n_,Tv_]:=Symbol["Lbar"<>#][Tv]&/@Take[ListReactionsNames,n];

Rules\[Lambda][Tv_]:=Thread[Rule[Li,Rules\[Lambda]RHS[Tv]]];
Rules\[Lambda]bar[Tv_]:=Thread[Rule[Lbari,Rules\[Lambda]barRHS[Tv]]];


Take[Rules\[Lambda][Tv],4]


(* ::Input::Initialization:: *)
DYOnlyPEN[Temp_,\[Rho]B_,time_]:=(FormalReactionsOnlyPEN)/.Dispatch@Rules\[Lambda][Temp]/.Dispatch@Rules\[Lambda]bar[Temp]/.Dispatch@RulesY[time]/.A\[Rho]B->\[Rho]B;

DY18[Temp_,\[Rho]B_,time_]:=(FormalReactions18)/.Dispatch@Rules\[Lambda][Temp]/.Dispatch@Rules\[Lambda]bar[Temp]/.Dispatch@RulesY[time]/.A\[Rho]B->\[Rho]B;

DY[Temp_,\[Rho]B_,time_]:=(FormalReactions)/.Dispatch@Rules\[Lambda][Temp]/.Dispatch@Rules\[Lambda]bar[Temp]/.Dispatch@RulesY[time]/.A\[Rho]B->\[Rho]B;


(* ::Input::Initialization:: *)
CompileFromFormal[FormalReactions_List]:=ReleaseHold[Hold[Compile[{{A\[Rho]B,_Real},{L,_Real,1},{Lbar,_Real,1},{Y,_Real,1}},inside,CompilationTarget->"C","RuntimeOptions"->"Speed",CompilationOptions->{"InlineExternalDefinitions"->True}]]//.{inside->FormalReactions,Y[m_]:>Y[[m]],L[m_]:>L[[m]],Lbar[m_]:>Lbar[[m]]}]


(* ::Input::Initialization:: *)
Timing[If[$CompileNDSolve,
DYC=CompileFromFormal[FormalReactions];
DY18C=CompileFromFormal[FormalReactions18];
DYCN[A\[Rho]B_?NumericQ,L_,Lbar_,Y_]:=DYC[A\[Rho]B,L,Lbar,Y];
DY18CN[A\[Rho]B_?NumericQ,L_,Lbar_,Y_]:=DY18C[A\[Rho]B,L,Lbar,Y];
];]


Print["[PrimiNuc]: Integrating Cosmology"]


(* ::Input::Initialization:: *)
Computetofa:=(tofa=NDSolveValue[{tv'[av]==1/(av H[av]),tv[a[Ti]]==1/(2H[a[Ti]])},tv,{av,a[Ti],a[Tf]},PrecisionGoal->8,AccuracyGoal->10];)


Timing@Computetofa


(* ::Input::Initialization:: *)
Computeaoft:=(aoft=NDSolveValue[{av'[tv]==1/tofa'[av[tv]],av[Re[tofa@a[Ti]]]==a[Ti]},av,{tv,Re[tofa@a[Ti]],Re[tofa@a[Tf]]},PrecisionGoal->75,AccuracyGoal->20];)


Timing@Computeaoft


(* ::Input::Initialization:: *)
Toft[tv_]:=Tofa[aoft[tv]];


(* ::Input::Initialization:: *)
Yni[Tv_]:=1/(1+(1-3/2 Q/mn )Exp[Q/(kB Tv)]);
Ypi[Tv_]:=1-Yni[Tv];


(* ::Input::Initialization:: *)
Yn2i[Tv_]:=LpTOn[Tv]/(LpTOn[Tv]+LnTOp[Tv]);
Yp2i[Tv_]:=1-Yn2i[Tv];


(* ::Input::Initialization:: *)
CIList[Tv_]:=Table[Which[i==1,Yni[Tv],i==2,Ypi[Tv],i>=3,0],{i,1,NumberVariable}]


(* ::Input::Initialization:: *)
DefineEquations:=(

(*We build the differential system for the High temperatures *)
(* So we associate the r.h.s which is constructed thanks to DYOnlyPEN, with the l.h.s made of abundances derivatives *)
SystemEquationsHT[tv_]=Thread[Equal[FunPrimeList[tv],(DYOnlyPEN[Tv,\[Rho]Bv,tv](*/.Dispatch@ReactionProbabilities*))]]/.{Tv->Toft@tv,\[Rho]Bv->\[Rho]BForBBN@a@Toft@tv};

(* For middle and low temperature we distinguish between the compiled and the uncompiled method *)

If[$CompileNDSolve,

(* If $CompileNDSolve=True, we reinterpolate the rates for the middle and the low temperatures. *)
(* The system is a matrix system in this case and it is built directly in NDSolve below *)
Rules\[Lambda]RHSI=MyInterpolationRate@Table[{Tv,MyChop@Rules\[Lambda]RHS[Tv]},{Tv,ListTRange[Tf,T18]}];
Rules\[Lambda]barRHSI=MyInterpolationRate@Table[{Tv,MyChop@Rules\[Lambda]barRHS[Tv]},{Tv,ListTRange[Tf,T18]}];
       Rules\[Lambda]RHS18I=MyInterpolationRate@Table[{Tv,Rules\[Lambda]RHS[NReactionsSmallNetwork,Tv]},{Tv,ListTRange[T18,TMiddle]}];
Rules\[Lambda]barRHS18I=MyInterpolationRate@Table[{Tv,Rules\[Lambda]barRHS[NReactionsSmallNetwork,Tv]},{Tv,ListTRange[T18,TMiddle]}];,

(* If $CompileNDSolve=False, we (re-)define the systems of equations for Middle and Low temperatures*)
(* We associate the r.h.s formed thanks to DY18 and DY, with the l.h.s made of derivatives *)
SystemEquationsMT[tv_]=Thread[Equal[FunPrimeList[tv],(DY18[Tv,\[Rho]Bv,tv])]]/.{Tv->Toft@tv,\[Rho]Bv->\[Rho]BForBBN@a@Toft@tv};
SystemEquationsLT[tv_]=Thread[Equal[FunPrimeList[tv],(DY[Tv,\[Rho]Bv,tv])]]/.{Tv->Toft@tv,\[Rho]Bv->\[Rho]BForBBN@a@Toft@tv};
]
)


DefineEquations;//Timing


(* ::Input::Initialization:: *)
t0:=Re[tofa@a[Tstart]];
tmiddle:=Re[tofa@a[TMiddle]];
t18:=Re[tofa@a[T18]];
tend:=Re[tofa@a[Tend]];


(* ::Input::Initialization:: *)
{t0,tmiddle,t18,tend}


(* ::Input::Initialization:: *)
HoldYNames[period_String]:=ToExpression/@("Hold@Y[\""<>period<>"\"][\""<>#<>"\"]"&/@ShortNames);


(* ::Input::Initialization:: *)
InitialConditionsHT[tv_]:=Thread[Equal[FunList[tv],CIList[Toft[tv]]]];


(* ::Input::Initialization:: *)
SolveValueHighTemperatures:=(Thread[MySet[Evaluate[HoldYNames["HT"]],
NDSolveValue[
Flatten@Join[SystemEquationsHT[tv],InitialConditionsHT[t0]],
VarList,{tv,t0,tmiddle},
PrecisionGoal->8+PrecisionNDSolve,AccuracyGoal->11,InterpolationOrder->InterpOrder]]];
tHT=Y["HT"]["n"][[3,1]];
);


AbsoluteTiming[SolveValueHighTemperatures;]
Print["[PrimiNuc]: High Temperature Integration Complete"]


(* ::Input::Initialization:: *)
ListThermalValuesMT={"d","t","He3","a","Be7","Li7","Li6"};
ListThermalValuesUsedMT=Intersection[VariablesInEquations,ListThermalValuesMT]


(* ::Input::Initialization:: *)
YPeriodTimeOrStateEquilibrium["HT",ListThermalValuesUsedMT][TMiddle,tmiddle]


(* ::Input::Initialization:: *)
InitialConditionsMT[Tv_,tv_]:=Thread[Equal[FunList[tv],YPeriodTimeOrStateEquilibrium["HT",ListThermalValuesUsedMT][Tv,tv]]];


(* ::Input::Initialization:: *)
SolveValueMiddleTemperatures:=(If[$CompileNDSolve,
(* Compiled version.*)
resMT=NDSolveValue[
{Ytab'[tv]==DY18CN[\[Rho]BForBBN@a@Toft@tv,Rules\[Lambda]RHS18I[Toft@tv],Rules\[Lambda]barRHS18I[Toft@tv],Ytab[tv]],Ytab[tmiddle]==YPeriodTimeOrStateEquilibrium["HT",ListThermalValuesUsedMT][TMiddle,tmiddle]},
Ytab,{tv,tmiddle,t18},
Method->{"BDF","MaxDifferenceOrder"->$BDFOrder},
PrecisionGoal->7+PrecisionNDSolve,AccuracyGoal->11,
InterpolationOrder->InterpOrder,Compiled->Automatic];
Y["MT"][key_][tv_?NumericQ]:=resMT[tv][[KeyVal[key]]];
tMT=resMT[[3,1]];,

(* Non compiled version. Slightly slower *)
Thread[MySet[Evaluate[HoldYNames["MT"]],NDSolveValue[
Flatten@Join[SystemEquationsMT[tv],InitialConditionsMT[TMiddle,tmiddle]],
VarList,{tv,tmiddle,t18},
Method->{"BDF","MaxDifferenceOrder"->$BDFOrder},
PrecisionGoal->7+PrecisionNDSolve,AccuracyGoal->11,
InterpolationOrder->InterpOrder,Compiled->False]]];
tMT=Y["MT"]["n"][[3,1]];
]);


AbsoluteTiming[SolveValueMiddleTemperatures;]
Print["[PrimiNuc]: Middle Temperature Integration Complete"]


(* ::Input::Initialization:: *)
InitialConditionsLT[tv_]:=Thread[Equal[FunList[tv],YPeriodTime["MT"][tv]]];


(* ::Input::Initialization:: *)
SolveValueLowTemperatures:=(If[$CompileNDSolve,
(* Compiled version*)
resLT=NDSolveValue[
{Ytab'[tv]==DYCN[\[Rho]BForBBN@a@Toft@tv,Rules\[Lambda]RHSI[Toft@tv],Rules\[Lambda]barRHSI[Toft@tv],Ytab[tv]],
Ytab[t18]==YPeriodTime["MT"][t18]},
Ytab,{tv,t18,tend},
Method->{"BDF","MaxDifferenceOrder"->$BDFOrder},
PrecisionGoal->5+PrecisionNDSolve,AccuracyGoal->AccuracyNDSolve,
InterpolationOrder->InterpOrder,StartingStepSize->10^-4,MaxStepSize->500];
Y["LT"][key_][tv_?NumericQ]:=resLT[tv][[KeyVal[key]]];
tLT=resLT[[3,1]];,

(* Uncompiled version. Slower. *)
Thread[MySet[Evaluate[HoldYNames["LT"]],NDSolveValue[
Flatten@Join[SystemEquationsLT[tv],InitialConditionsLT[t18]],
VarList,{tv,t18,tend},
Method->{"BDF","MaxDifferenceOrder"->$BDFOrder,"EquationSimplification"->"Solve"},
PrecisionGoal->5+PrecisionNDSolve,AccuracyGoal->AccuracyNDSolve,
InterpolationOrder->InterpOrder,StartingStepSize->10^-4]]];
tLT=Y["LT"]["n"][[3,1]];
];)


AbsoluteTiming[SolveValueLowTemperatures;]
Print["[PrimiNuc]: Low Temperature Integration Complete"]


(* ::Input::Initialization:: *)
InterpolateResults=(
Clear[Yall,YI];
Yall[key_?KeyQ]:=Yall[key]=Function[{tv},Piecewise[{{Y["HT"][key][tv],tv<tmiddle},{Y["MT"][key][tv],tv<t18&&tv>=tmiddle},{Y["LT"][key][tv],tv<=tend&&tv>=t18}}]];

YI[key_?KeyQ]:=YI[key]=Interpolation[Table[{tv,Yall[key][tv]},{tv,Join[tHT,Rest@tMT,Rest@tLT]}],InterpolationOrder->1];);


InterpolateResults;


(* ::Input::Initialization:: *)
RunNumericalIntegralsNuclearReactions:=(
(* Middle temperature integration *)
SolveValueMiddleTemperatures;

(* Low temperature integration *)
SolveValueLowTemperatures;
);


(* ::Input::Initialization:: *)
RunNumericalIntegrals:=(

(* In case of incomplete neutrino decoupling, we recompute all the integrations a(T) then inversion T(a), then Subscript[\[Rho], \[Nu]](a).*)
If[$IncompleteNeutrinoDecoupling,RecomputeIncompleteNeutrinoDecoupling;];

(*In case the plasma conditions have changed in a MC exploration, we recompute the inversion of a[T]*)
(* This is needed if we have recomputed the neutrino decoupling, but I am wondering if this is always needed. *)
InvertaOFT;

(* scale factor integration from Friedmann equation. *)
Computetofa;
Computeaoft;

(* Build equations. Needed since rate are modified randomly by the f factor of each reaction*)
LoadRates;
DefineEquations;

(* High temperature integration with only PEN reactions *)
SolveValueHighTemperatures;

(* Middle and Low temperature WITH nuclear reactions*)
RunNumericalIntegralsNuclearReactions;

InterpolateResults;
);


(* ::Input::Initialization:: *)
XI[key_?KeyQ][t_]:=Ai[key]YI[key][t]


(* ::Input::Initialization:: *)
Yf[key_]:=YLT[key][tend]
Xf[key_]:=Ai[key]Yf[key]


(* ::Input::Initialization:: *)
YfH[key_]:=Yf[key]/Yf["p"]


(* ::Input::Initialization:: *)
MyTickst={{Automatic,Automatic},{Automatic,{{tofa@a[10^11],"\!\(\*SuperscriptBox[\(10\), \(11\)]\)K"},{tofa@a[10^10.5],"\!\(\*SuperscriptBox[\(10\), \(10.5\)]\)K"},{tofa@a[10^10],"\!\(\*SuperscriptBox[\(10\), \(10\)]\)K"},{tofa@a[10^9.5],"\!\(\*SuperscriptBox[\(10\), \(9.5\)]\)K"},{tofa@a[10^9],"\!\(\*SuperscriptBox[\(10\), \(9\)]\)K"},{tofa@a[10^8.5],"\!\(\*SuperscriptBox[\(10\), \(8.5\)]\)K"},{tofa@a[10^8],"\!\(\*SuperscriptBox[\(10\), \(8\)]\)K"}}}};


Print["[PrimiNuc]: Results"]
Print[MyGrid[{#,Yf[#]}&/@ShortNames]]


timingEndNuc = AbsoluteTime[];
Print["[PrimiNuc]: Completed. Total Time - ", Round[timingEndNuc - timingStartNuc], " seconds"]
